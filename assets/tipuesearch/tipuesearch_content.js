var tipuesearch = {"pages": [{
    "title": "SKY 멘토님으로부터 총 5,760분의 멘토링을 받고 나서",
    "text": "SW 마에스트로 연수생 생활 마무리 길고도 짧았던 6개월간의 SW 마에스트로 15기 연수생 생활을 마치고, 이제 새로운 시작을 앞두고 있다. 따뜻한 4월, 설렘과 기대로 시작했던 연수 생활은 수많은 도전과 배움으로 채워졌고, 그 안에서 나는 성장했다. 특히, SKY 멘토님은 등대와 같은 존재였다. 길을 잃을 때마다 함께 고민하며 방향을 제시해주셨고, 계속 나아갈 수 있도록 격려와 지지를 아끼지 않으셨다. 이 글을 통해 SKY 멘토님께 깊은 감사의 마음을 전하며, 연수생으로서의 소중한 경험과 멘토링 후기를 남기고자 한다. 연수생 혜택 연수생으로서의 혜택은 정말 많다. 다른 기관의 프로그램과는 결이 다르다. 개인 당 IT기기 구매 지원비, 팀별 프로젝트 지원비와 같이 금전적인 혜택도 있지만, 무엇보다도 멘토링을 받을 수 있는 것이 가장 큰 혜택이다. 각자의 분야에서 경험을 쌓아온 멘토님들로부터 직접적인 조언을 받을 수 있기 때문이다. 그들의 경험을 듣고 배울 수 있는 것이 가치가 엄청나다. 개발자, CEO, 디자이너, 마케터 등 다양한 분야에서 경험을 쌓아온 멘토님들로부터 다양한 조언을 받을 수 있다. 앞서 얘기했듯 이 글에서는 멘토링에 대한 후기를 남기고자 한다. 멘토링 우리 팀은 Ktalker라는 이름으로 온라인 한국어 학습 서비스를 기획 운영하였다. 10개가 넘는 서비스 아이디어 중에서 KPOP, KDRAMA등 대중 문화가 글로벌로 인기를 끌고 있는 요즈음, Ai와 결합하면 시장성이 높을 것이라고 판단해서 이 아이디어를 선택했던 것이다. 왜 SKY 멘토님으로부터 올 한해 동안 멘토링을 받고 싶었는지는 이유가 있다. 수 년전 부터 컴공선배의 유튜브를 즐겨보았는데, 그 중에서도 SKY 멘토님이 출연하신 영상을 많이 보았다. 그 영상을 보면서 개발자로서의 자세, 마인드, 역량에 대한 내용 등을 배울 수 있었다. 컴공선배 SW마에스트로를 처음 인지한 것은 컴공선배가 아니었다. 4월 초에는 연수과정이 어떻게 돌아가는지 정확하게 알지 못했고, 멘토님 목록을 보던 중 SKY 멘토님이 있다는 것을 알고나서 전담 멘토링을 받고 싶다고 생각했었다. 원래는 멘토로 활동하고 계신지 몰랐다. 멘토링 후기 SKY 멘토님과의 만남은 나에게 특별한 행운이었다. 멘토님은 늘 따뜻한 미소와 진심 어린 조언으로 나를 격려해주셨고, 날카로운 질문과 통찰력 있는 분석으로 내가 생각하지도 못했던 부분까지 짚어주셨다. 멘토링은 단순한 지식 전달을 넘어서, 스스로 생각하고 문제를 해결할 수 있는 역량을 키워주는 값진 경험이었다. 멘토링은 정규 멘토링과 자유 멘토링이 있는데, 정규 멘토링은 격주로 오프라인, 온라인을 병행하며 1회에 3시간씩 진행되었다. 보통은 정규 멘토링만 이뤄지고 자유 멘토링은 빈도가 적은 편인데 SKY 멘토님은 다른 팀과 함께 격주로 토요일 마다 2주간 서로 프로젝트 진행한 내용을 프레젠테이션하며 공유하는 시간을 마련해주셨다. 오픈 스프린트 리뷰라고 부르는 이 시간은 다른 팀의 프로젝트를 보며 배울 수 있는 기회가 되었다. 서로 의견도 나누고 피드백도 주고 받는 시간이어서 정말 유익했다. 이렇게 다 같이 모여서 프로젝트를 공유하는 시간은 SKY 멘토님만이 유일한 것으로 알고 있다. 오픈 스프린트 리뷰 발표 자료 커버 정규 멘토링 20회 가량, 오픈 스프린트 리뷰 10회 이상으로 대략 총 5,760분, 96시간을 멘토링 받았다. 거의 매주 멘토님을 만나서 이야기를 나누었던 것 같다. 이렇게 빈번하게 멘토님을 뵐수 있었던 건 행운이라고 생각한다. 다른 팀들 얘기들어보면 멘토님을 한 달에 한번도 만나지 못하는 경우도 있었다. 바쁘신 상황에서도 많은 시간을 투자해주셔서 감사하다. 멘토링은 크게 서비스 관련 부분과 개인적인 부분으로 나누어 진행되었다. 서비스 관련 멘토링은 단순히 기술적인 측면뿐만 아니라, 서비스의 본질적인 가치를 고민하고 실현하는 데 초점을 맞추었다. 비즈니스 모델링: 멘토님은 시장 분석, 경쟁사 분석, 고객 분석 등 다양한 방법을 소개해주셨고, 이를 토대로 어떻게 운영과 개발을 해야하는지 알 수 있었다. 서비스 기획: 사용자 중심의 서비스 기획 방법론을 배우고, 실제 서비스에 적용하며 실무 역량을 강화했다. 수익화 관련: 다양한 수익 모델을 분석하고, 서비스의 특성에 맞는 최적의 수익화 전략을 수립했다. 마케팅 전략: 효과적인 마케팅 채널 선정 및 운영, 고객 확보 및 유지 전략 등을 학습하고 실행했다. 사용자 경험 및 피드백을 위한 방법: 사용자 인터뷰, 설문조사 등 다양한 방법을 통해 사용자 경험을 개선하고, 피드백을 수용하는 방법을 익혔다. 서비스를 만듦에 있어서 개발은 정말 큰 비중이 아니라 비전, 기획 의도, 사용자 유치 전략이 대부분 인 것같다. 2024년 4월까지만 해도 개발만 주로 해왔던 지라 이런 부분이 부족했었는데, 멘토님의 도움으로 이런 부분을 채울 수 있었다. 앞으로는 혼자서 서비스를 만들더라도 이전과는 다른 방식으로 제대로 된 서비스를 만들 수 있을 것 같다. 7월에 프로젝트를 어떻게 이어나가야 할지 애를 먹고 있을 때, 뭘 해야하는지 목록을 다 작성하고 우선순위를 정하는 걸 도와주셨다. 고객 유치가 어려운 상황에서 KPT회고를 통해서 문제를 파악하고 해결 방안을 찾는 걸 도와주셨다. 또한 판서를 하시면서 쉽게 이해할 수 있도록 도와주셨고, 이해가 안되는 부분은 멘토링 시간이 끝나도 애매하게 마무리 되는 것없이 쉽게쉽게 이해할 수 있도록 도와주셨다. 6월 멘토링 중 7월 멘토링 중 9월 멘토링 중 11월 멘토링 중 멘토님의 헌신적인 마음을 느꼈던 순간 4월부터 9월까지, 나는 팀장으로서 비전을 제시하고 기획을 주도하는 역할을 맡았다. 하지만 늦었지만 9월에 들어서면서, 스스로 내 역할을 제대로 수행하지 못하고 있다는 것을 인지했고, 이는 곧 팀 전체의 혼란과 프로젝트 진행의 어려움으로 이어졌다. 서비스와 팀 모두 방향성을 잃고 표류하면서 답답해하고 있을 때, 멘토님께서는 기존보다 더 심층적인 멘토링을 진행해주셨다. 멘토님의 날카로운 분석과 조언은 팀원들과 함께 고민하고 해결책을 찾아나가는 데 큰 도움이 되었다. 이후 10월 초까지 2주 동안, 나는 매일 팀의 활동 내용을 멘토님께 보고하며 밀착 멘토링을 받았다. 멘토님은 단순히 방향을 제시하는 것을 넘어, 함께 고민하고 해결책을 찾아나가는 든든한 지원군과 같았었다. 한 번은 황금같은 주말 밤에, 개인적인 질문이 있어 조심스럽게 메시지를 드렸는데, 멘토님께서는 자정이 넘도록 4시간 가까이 정성껏 답변해주셨다. 그때 나는 멘토님의 헌신적인 마음에 깊은 감동을 받았고, 뭘 해야할지 다시 정리해가면서 앞으로 나아갈 수 있었다. 이 외에도 멘토님은 지치고 힘든 순간마다 끊임없이 격려와 지지를 보내주시면서, 내가 한 사람으로서 성장하는 데 큰 도움을 주셨다. 8:11 PM 00:24 AM ![image](https://github.com/user-attachments/assets/db0f9fd4-d3b3-46db-8a05-e13d9809f14e) ![image](https://github.com/user-attachments/assets/ee4d0de1-29d1-46d3-a378-b55e87e3ec73) 실무적인 내용 뿐만 아니라, 개인적으로 인간으로서 성장하는 데 도움이 되는 내용도 많이 배웠다. 어떤 일을 할때나 문제를 해결할 때 어떤 방식으로 접근해야 하는지, 불필요한 것을 버리고 중요한 것을 구분하는 방법 등 다양한 내용이다. 비판적인 사고: 멘토님은 항상 “왜?”라는 질문을 던지며 문제의 본질을 파악하고, 다양한 관점에서 분석하는 능력을 기를 수 있었다. 문제해결을 위한 사고: 복잡한 문제를 단순화하고, 논리적인 사고 과정을 통해 해결을 하는 방법에 대해서 조언을 얻었다. 우선순위 설정: 제한된 시간과 자원을 어떻게 효율적으로 나누고 관리해서 목표를 달성해야 하는지 배웠다. 나에게 가장 컸던 건 비판적인 사고방식이다. 이전에는 문제가 생겼을 때, 그 문제를 해결하기 위해 어떤 방법을 쓸지 고민했지만, 멘토님의 가르침 덕분에 문제의 원인을 파악하고, 그 원인을 해결하기 위한 방법을 찾게 되었다. 한 줄로 설명하면 HOW가 아니라 WHY로 시작하는 사고로 접근하는 방식인데, 이런 사고방식은 평소 일상에서도 도움이 되고 있다. 멘토님의 가르침 덕분에 저는 서비스 개발뿐만 아니라, 한 명의 주체적인 사람으로서 성장할 수 있었다. 멘토님께 다시 한번 진심으로 감사드린다. Epilogue 4월, 처음 시작했을 때만 해도 모든 것이 낯설고 막막했다. 멘토님의 말씀 하나하나가 소중했지만, 솔직히 모든 내용을 당시에 다 이해하지는 못했다. 하지만 8개월간의 SW 마에스트로 여정을 거치며 직접 프로젝트를 진행하고, 수많은 시행착오를 겪으면서 얻은 많은 조언들이 지금 돌아봤을 때는 2023년의 나와는 다른 사람이 되도록 만들어 준것 같다. 내가 얼마나 부족한지, 그리고 어떤 방식으로 행동해야 하는지를 깨닫게 되었고, 끊임없이 배우고 노력하며 부족한 부분을 채워나가는 과정에서 진정한 성장의 기쁨을 경험했다. 이제 연수생으로서의 생활은 마무리되었지만, 이곳에서의 경험과 멘토님의 가르침은 내 마음속에 깊이 새겨져 앞으로 나아가는 길에 든든한 나침반이 되어줄 것 같다. 불가능하지만 16기를 또 하고 싶다는 생각도 든다. 왜냐하면 16기를 한다면 15기로 처음 시작했을때보다 훨씬 더 잘할 수 있을거 같다는 생각때문이다. 8개월간의 값진 경험을 바탕으로 끊임없이 배우고 도전하면서 누군가에게 대체 불가능한 가치를 제공하는 사람이 되기 위해 최선을 다할 것이다. 함께했던 동기들과 멘토님들께 다시 한번 진심으로 감사드린다. 앞으로 우리 모두 각자의 자리에서 가치있는 모습을 보이기를 응원한다.",
    "tags": "SWM",
    "url": "/jekyll-theme-yat/swm/2024/12/09/SKY-%EB%A9%98%ED%86%A0%EB%8B%98%EC%9C%BC%EB%A1%9C%EB%B6%80%ED%84%B0-%EC%B4%9D-5,760%EB%B6%84%EC%9D%98-%EB%A9%98%ED%86%A0%EB%A7%81%EC%9D%84-%EB%B0%9B%EA%B3%A0-%EB%82%98%EC%84%9C.html"
  },{
    "title": "스크롤 가능한 커스텀 TopAppBar만들기",
    "text": "내용이 심하게 부실해서 수정하고 있습니다. 다음과 같이 스크롤 할 수 있는 TopAppBar를 만들어 보고자 합니다. 만들게된 계기 자체적으로 LargeTopAppBar를 제공하지만 가장 큰 Title 컴포저블의 높이가 최대 152dp로 제한되어 있다. 아래 코드는 Compose material3의 TopAppBar를 구현한 클래스의 코드 중 일부이다. 보다시피 최대 높이인 ContainerHeight가 152.0.dp로 고정되어 있다. 이로 인해서 더 큰 높이의 Title 컴포저블을 사용하면 아래 일부가 잘리게 되는 문제가 생긴다. 또한 기본적으로 이 컴포저블은 material3의 스타일을 따른 것이므로 커스텀이 제한된다. 아래처럼 좀 더 높이가 큰 TopAppBar가 필요하고, 제한을 벗어나 커스텀이 가능한게 필요하여 구현하게 되었다. 기본제공 구현하고자 하는 것 ![](https://developer.android.com/static/images/jetpack/compose/components/appbar-large.svg) ![](https://github.com/pknujsp/pknujsp/assets/48265129/fa263fe9-cfa4-4ba5-b463-70c74b4008bf) // package androidx.compose.material3.tokens.TopAppBarLargeTokens.kt internal object TopAppBarLargeTokens { ... val ContainerHeight = 152.0.dp ... } // package androidx.compose.material3.AppBar.kt @OptIn(ExperimentalMaterial3Api::class) @Composable private fun TwoRowsTopAppBar( ... maxHeight: Dp, pinnedHeight: Dp, ... ) { val pinnedHeightPx: Float // 작은 Title 컴포저블의 높이 val maxHeightPx: Float // 허용하는 최대 Title 컴포저블의 높이 val titleBottomPaddingPx: Int LocalDensity.current.run { pinnedHeightPx = pinnedHeight.toPx() maxHeightPx = maxHeight.toPx() titleBottomPaddingPx = titleBottomPadding.roundToPx() } 구현 먼저 기본 TopAppBar의 구현 코드를 살펴보자. LargeTopAppBar 컴포저블의 구현은 다음과 같다. Scaffold에서 topBar를 사용하여 TopAppBar를 배치할 때 이 함수를 사용한다. 실제 구현하는 컴포저블 함수를 따로 TwoRowsTopAppBar로 구현하고 있다. @ExperimentalMaterial3Api @Composable fun LargeTopAppBar( title: @Composable () -&gt; Unit, modifier: Modifier = Modifier, navigationIcon: @Composable () -&gt; Unit = {}, actions: @Composable RowScope.() -&gt; Unit = {}, windowInsets: WindowInsets = TopAppBarDefaults.windowInsets, colors: TopAppBarColors = TopAppBarDefaults.largeTopAppBarColors(), scrollBehavior: TopAppBarScrollBehavior? = null ) { TwoRowsTopAppBar( title = title, titleTextStyle = MaterialTheme.typography.fromToken(TopAppBarLargeTokens.HeadlineFont), smallTitleTextStyle = MaterialTheme.typography.fromToken(TopAppBarSmallTokens.HeadlineFont), titleBottomPadding = LargeTitleBottomPadding, smallTitle = title, modifier = modifier, navigationIcon = navigationIcon, actions = actions, colors = colors, windowInsets = windowInsets, maxHeight = TopAppBarLargeTokens.ContainerHeight, pinnedHeight = TopAppBarSmallTokens.ContainerHeight, scrollBehavior = scrollBehavior ) } TwoRowsTopAppBar은 다음과 같이 구현되어 있다. 먼저 높이를 체크하고 dp인 값을 px로 변환한다. 하단 타이틀의 접히고 펼치는 동작이 자연스럽게 이루어지도록 드래그 시 y축의 드래그 양의 상한을 조정한다. 앱 바가 접힌 상태를 0.0 - 1.0 사이의 값으로 결정한다. 컴포저블의 경우 Surface에 Column을 배치하고 순서대로 상단 타이틀과 하단 타이틀을 배치한다. @Composable private fun TwoRowsTopAppBar( modifier: Modifier = Modifier, title: @Composable () -&gt; Unit, titleTextStyle: TextStyle, titleBottomPadding: Dp, smallTitle: @Composable () -&gt; Unit, smallTitleTextStyle: TextStyle, navigationIcon: @Composable () -&gt; Unit, actions: @Composable RowScope.() -&gt; Unit, windowInsets: WindowInsets, colors: TopAppBarColors, maxHeight: Dp, pinnedHeight: Dp, scrollBehavior: TopAppBarScrollBehavior? ) { // maxHeight가 pinnedHeight 이하일 경우 예외를 던진다. // 이 부분은 private 내부 함수이므로, 개발자가 직접 API에서 접근이 불가능하다. if (maxHeight &lt;= pinnedHeight) { ... } // 높이를 픽셀로 변환 val pinnedHeightPx: Float val maxHeightPx: Float val titleBottomPaddingPx: Int LocalDensity.current.run { pinnedHeightPx = pinnedHeight.toPx() maxHeightPx = maxHeight.toPx() titleBottomPaddingPx = titleBottomPadding.roundToPx() } // 앱 바가 드래그 될 때 접히기 시작해야 하는 y축 드래그 양의 상한을 조정해서 상단, 하단 타이틀 영역이 올바르게 보이도록 한다. SideEffect { if (scrollBehavior?.state?.heightOffsetLimit != pinnedHeightPx - maxHeightPx) { scrollBehavior?.state?.heightOffsetLimit = pinnedHeightPx - maxHeightPx } } // 스크롤 동작이 발생할 때, 상하단 타이틀의 가시성을 조정하기 위한 값으로 사용된다. // 이 값이 0.5f 라면 반 정도 접힌 상태, 1.0f 라면 완전히 펼쳐진 상태를 의미한다. val colorTransitionFraction = scrollBehavior?.state?.collapsedFraction ?: 0f val appBarContainerColor = colors.containerColor(colorTransitionFraction) // 액션 아이콘들을 Row로 묶어서 표시한다. val actionsRow = @Composable { Row( horizontalArrangement = Arrangement.End, verticalAlignment = Alignment.CenterVertically, content = actions ) } val topTitleAlpha = TopTitleAlphaEasing.transform(colorTransitionFraction) val bottomTitleAlpha = 1f - colorTransitionFraction // 하단 타이틀을 표시할지 여부를 결정하는 기준 값 // 0.5f 이하일 경우 상단 타이틀을 표시하고, 그렇지 않을 경우 하단 타이틀을 표시한다. val hideTopRowSemantics = colorTransitionFraction &lt; 0.5f val hideBottomRowSemantics = !hideTopRowSemantics // 앱 바에 드래그 동작을 가능하게 한다. val appBarDragModifier = if (scrollBehavior != null &amp;&amp; !scrollBehavior.isPinned) { Modifier.draggable( orientation = Orientation.Vertical, state = rememberDraggableState { delta -&gt; scrollBehavior.state.heightOffset = scrollBehavior.state.heightOffset + delta }, onDragStopped = { velocity -&gt; // 드래그가 멈췄을 때 앱 바의 확장 또는 접힘 동작을 결정한다. // colorTransitionFraction 값이 0.5f를 기준으로 접힐지 펼쳐질지 결정한다. // 이 때 애니메이션이 발생하게 된다. settleAppBar( scrollBehavior.state, velocity, scrollBehavior.flingAnimationSpec, scrollBehavior.snapAnimationSpec ) } ) } else { Modifier } Surface(modifier = modifier.then(appBarDragModifier), color = appBarContainerColor) { Column { TopAppBarLayout( modifier = Modifier .windowInsetsPadding(windowInsets) .clipToBounds(), heightPx = pinnedHeightPx, navigationIconContentColor = colors.navigationIconContentColor, titleContentColor = colors.titleContentColor, actionIconContentColor = colors.actionIconContentColor, title = smallTitle, titleTextStyle = smallTitleTextStyle, titleAlpha = topTitleAlpha, titleVerticalArrangement = Arrangement.Center, titleHorizontalArrangement = Arrangement.Start, titleBottomPadding = 0, hideTitleSemantics = hideTopRowSemantics, navigationIcon = navigationIcon, actions = actionsRow, ) TopAppBarLayout( modifier = Modifier .windowInsetsPadding(windowInsets.only(WindowInsetsSides.Horizontal)) .clipToBounds(), heightPx = maxHeightPx - pinnedHeightPx + (scrollBehavior?.state?.heightOffset ?: 0f), navigationIconContentColor = colors.navigationIconContentColor, titleContentColor = colors.titleContentColor, actionIconContentColor = colors.actionIconContentColor, title = title, titleTextStyle = titleTextStyle, titleAlpha = bottomTitleAlpha, titleVerticalArrangement = Arrangement.Bottom, titleHorizontalArrangement = Arrangement.Start, titleBottomPadding = titleBottomPaddingPx, hideTitleSemantics = hideBottomRowSemantics, navigationIcon = {}, actions = {} ) } } } TopAppBarLayout은 다음과 같이 구현되어 있다. Layout을 사용하여 TopAppBar의 레이아웃을 구성한다. 네비게이션 아이콘, 액션, 타이틀을 모두 따로 Box로 감싼다. 각각의 Box에 layoutId를 부여하여 각각의 Box를 구분한다. layout 함수를 사용하여 각각의 컴포넌트의 크기에 따라 Box의 위치를 결정한다. 하단 타이틀이 접히고 펼쳐지는 동작을 자연스럽게 하기 위해 alpha값을 가지고 투명도를 조절하는 방식을 사용한다. @Composable private fun TopAppBarLayout( modifier: Modifier, heightPx: Float, navigationIconContentColor: Color, titleContentColor: Color, actionIconContentColor: Color, title: @Composable () -&gt; Unit, titleTextStyle: TextStyle, titleAlpha: Float, titleVerticalArrangement: Arrangement.Vertical, titleHorizontalArrangement: Arrangement.Horizontal, titleBottomPadding: Int, hideTitleSemantics: Boolean, navigationIcon: @Composable () -&gt; Unit, actions: @Composable () -&gt; Unit, ) { Layout( { Box( Modifier .layoutId(\"navigationIcon\") .padding(start = TopAppBarHorizontalPadding) ) { CompositionLocalProvider( LocalContentColor provides navigationIconContentColor, content = navigationIcon ) } Box( Modifier .layoutId(\"title\") .padding(horizontal = TopAppBarHorizontalPadding) .then(if (hideTitleSemantics) Modifier.clearAndSetSemantics { } else Modifier) .graphicsLayer(alpha = titleAlpha) ) { ProvideContentColorTextStyle( contentColor = titleContentColor, textStyle = titleTextStyle, content = title) } Box( Modifier .layoutId(\"actionIcons\") .padding(end = TopAppBarHorizontalPadding) ) { CompositionLocalProvider( LocalContentColor provides actionIconContentColor, content = actions ) } }, modifier = modifier ) { measurables, constraints -&gt; val navigationIconPlaceable = measurables.fastFirst { it.layoutId == \"navigationIcon\" } .measure(constraints.copy(minWidth = 0)) val actionIconsPlaceable = measurables.fastFirst { it.layoutId == \"actionIcons\" } .measure(constraints.copy(minWidth = 0)) val maxTitleWidth = if (constraints.maxWidth == Constraints.Infinity) { constraints.maxWidth } else { (constraints.maxWidth - navigationIconPlaceable.width - actionIconsPlaceable.width) .coerceAtLeast(0) } val titlePlaceable = measurables.fastFirst { it.layoutId == \"title\" } .measure(constraints.copy(minWidth = 0, maxWidth = maxTitleWidth)) val titleBaseline = if (titlePlaceable[LastBaseline] != AlignmentLine.Unspecified) { titlePlaceable[LastBaseline] } else { 0 } val layoutHeight = if (heightPx.isNaN()) 0 else heightPx.roundToInt() layout(constraints.maxWidth, layoutHeight) { navigationIconPlaceable.placeRelative( x = 0, y = (layoutHeight - navigationIconPlaceable.height) / 2 ) titlePlaceable.placeRelative( x = when (titleHorizontalArrangement) { Arrangement.Center -&gt; { var baseX = (constraints.maxWidth - titlePlaceable.width) / 2 if (baseX &lt; navigationIconPlaceable.width) { baseX += (navigationIconPlaceable.width - baseX) } else if (baseX + titlePlaceable.width &gt; constraints.maxWidth - actionIconsPlaceable.width ) { baseX += ((constraints.maxWidth - actionIconsPlaceable.width) - (baseX + titlePlaceable.width)) } baseX } Arrangement.End -&gt; constraints.maxWidth - titlePlaceable.width - actionIconsPlaceable.width else -&gt; max(TopAppBarTitleInset.roundToPx(), navigationIconPlaceable.width) }, y = when (titleVerticalArrangement) { Arrangement.Center -&gt; (layoutHeight - titlePlaceable.height) / 2 Arrangement.Bottom -&gt; if (titleBottomPadding == 0) layoutHeight - titlePlaceable.height else layoutHeight - titlePlaceable.height - max( 0, titleBottomPadding - titlePlaceable.height + titleBaseline ) else -&gt; 0 } ) actionIconsPlaceable.placeRelative( x = constraints.maxWidth - actionIconsPlaceable.width, y = (layoutHeight - actionIconsPlaceable.height) / 2 ) } } } 기본적인 레이아웃은 TopAppBar의 형식을 그대로 따르므로, material3에 구현된 코드를 일부 가져왔다. 그대로 따오지는 않았으며, 일부 수정하여 사용하였다. - 상단, 하단 타이블의 배치 방식을 수정하였다. Column에 상단, 하단 타이틀이 배치된 부분을 수정하여 단일 컴포저블 함수로 만들었다. 왜냐하면, 상단, 하단 타이틀의 배치 방식이 다르지 않고, 상단 타이틀이 접히고 펼쳐지는 동작을 자연스럽게 하기 위해 alpha값을 가지고 투명도를 조절하는 방식을 사용하기 때문이다. 그래서 단일 함수로 만들어서 코드 길이를 줄이는 방향이 좋다고 판단하였다. private val topAppBarHorizontalPadding = 4.dp private val topAppBarTitleInset = 16.dp @Composable fun CustomTopAppBar( modifier: Modifier = Modifier, windowInsets: WindowInsets, colors: CustomTopAppBarColors, scrollState: ScrollState, bigTitle: @Composable () -&gt; Unit, smallTitle: @Composable () -&gt; Unit, navigationIcon: @Composable (() -&gt; Unit)? = null, actions: @Composable (RowScope.() -&gt; Unit)? = null, ) { val coroutineScope = rememberCoroutineScope() var bigTitleHeight by remember { mutableIntStateOf(0) } val collapsedFraction by remember { derivedStateOf { if (scrollState.value &lt; bigTitleHeight) scrollState.value / bigTitleHeight.toFloat() else 1f } } val nestedScrollConnection = remember { object : NestedScrollConnection { override suspend fun onPostFling(consumed: Velocity, available: Velocity): Velocity { coroutineScope.onScroll(scrollState, bigTitleHeight, collapsedFraction) return super.onPostFling(consumed, available) } } } if (scrollState.isScrollInProgress &amp;&amp; scrollState.value != 0) { DisposableEffect(scrollState.isScrollInProgress) { onDispose { coroutineScope.onScroll(scrollState, bigTitleHeight, collapsedFraction) } } } val actionsRow: @Composable (() -&gt; Unit)? = actions?.run { @Composable { Row(verticalAlignment = Alignment.CenterVertically, content = this) } } val bigTitleBox: @Composable () -&gt; Unit = { Box(modifier = Modifier.onGloballyPositioned { if (bigTitleHeight == 0) { bigTitleHeight = it.size.height } }) { bigTitle() } } Box(modifier = modifier.nestedScroll(nestedScrollConnection)) { TopAppBarLayout( modifier = Modifier .windowInsetsPadding(windowInsets), navigationIconContentColor = colors.navigationIconContentColor, actionIconContentColor = colors.actionIconContentColor, smallTitleAlpha = collapsedFraction, smallTitle = smallTitle, bigTitle = bigTitleBox, navigationIcon = navigationIcon, actions = actionsRow, ) } } - 드래그 동작 부분이 가장 큰 문제였다. 이 부분은 직접 구현하였다. 기본 API 함수의 경우 드래그를 처리하는 코드가 internal 접근자로 되어 있는 클래스들과 복잡하게 연결되어 있어서 그대로 복사하는 것은 너무 많은 내용을 복사해야 해서 엄청 비효율적이라서 직접 구현하였다. 구현에 많은 시간이 소요되었다. 이 앱 바를 배치한 상위 컴포저블에서 scrollState를 함수 파라미터로 받아온다. 앱 바 영역이 펼치고 접힐 때 하단 타이틀 영역의 높이를 가지고 계산되어야 하므로 onGloballyPositioned를 사용하여 하단 타이틀 영역의 높이를 따로 저장한다. nestedScrollConnection 객체를 생성하여 앱 바 전체 영역을 가지는 루트 컴포저블에 nestedScroll을 적용한다. nestedScroll만 그대로 적용하면 날리는 식으로 스크롤을 할 때 제대로 동작이 발생하지 않고 끊기는 현상이 발생한다. 이를 해결하기 위해 onPostFling을 오버라이드하여 스크롤이 멈추면 앱 바의 확장 또는 접힘 동작을 결정한다. 이 때 애니메이션이 발생하게 된다. API의 settleAppBar 함수가 쓰이는 목적을 구현하기 위해 DisposableEffect를 사용하여 앱바가 중간에 펼쳐진 상태에서 스크롤이 멈췄을 때 앱바의 확장 또는 접힘 동작을 결정한다. 이 때도 애니메이션이 발생하게 된다. 최종 구현은 기본 API를 사용하였을 때와 차이가 없음을 확인하였다. CoroutineScope.onScroll 함수에서 scrollState의 상태를 직접 갱신하여 앱 바를 드래그하여도 Column을 드래그하는 것과 똑같은 동작을 하도록 구현하였다. 실제 사용에서 화면 어느 영역을 드래그 하더라도 완전히 동일한 터치감이 나타난다. scrollState의 animateScrollTo 메서드를 사용하면 nestedScrollConnection에서 따로 드래그 상태에 따른 로직을 구현하지 않더라도 자연스러운 드래그 동작을 만들 수 있다. private const val BIG_TITLE = \"bigTitle\" private const val SMALL_TITLE = \"smallTitle\" private const val NAVIGATION_ICON = \"navigationIcon\" private const val ACTION_ROW = \"actionRow\" @Composable private fun TopAppBarLayout( modifier: Modifier, navigationIconContentColor: Color, actionIconContentColor: Color, smallTitleAlpha: Float, bigTitle: @Composable () -&gt; Unit, smallTitle: @Composable () -&gt; Unit, navigationIcon: @Composable (() -&gt; Unit)? = null, actions: @Composable (() -&gt; Unit)? = null, ) { Layout({ Box(Modifier .layoutId(NAVIGATION_ICON) .padding(start = topAppBarHorizontalPadding)) { navigationIcon?.run { CompositionLocalProvider(LocalContentColor provides navigationIconContentColor, content = this) } } Box(Modifier .layoutId(BIG_TITLE) .padding(horizontal = topAppBarHorizontalPadding) .graphicsLayer(alpha = 1f - smallTitleAlpha)) { bigTitle() } Box(Modifier .layoutId(SMALL_TITLE) .padding(horizontal = topAppBarHorizontalPadding) .graphicsLayer(alpha = smallTitleAlpha)) { smallTitle() } Box(Modifier .layoutId(ACTION_ROW) .padding(end = topAppBarHorizontalPadding)) { actions?.run { CompositionLocalProvider(LocalContentColor provides actionIconContentColor, content = this) } } }, modifier = modifier) { measurables, constraints -&gt; val navigationIconPlaceable = measurables.first { it.layoutId == NAVIGATION_ICON }.measure(constraints.copy(minWidth = 0)) val actionIconsPlaceable = measurables.first { it.layoutId == ACTION_ROW }.measure(constraints.copy(minWidth = 0)) val bigTitlePlaceable = measurables.first { it.layoutId == BIG_TITLE }.measure(constraints.copy(minWidth = 0)) val smallTitlePlaceable = measurables.first { it.layoutId == SMALL_TITLE }.measure(constraints.copy(minWidth = 0)) val expandedRatio = 1f - (1f - smallTitleAlpha) val layoutHeight = navigationIconPlaceable.height + (bigTitlePlaceable.height * (1f - expandedRatio)).toInt() val titleInset = topAppBarTitleInset.roundToPx() layout(constraints.maxWidth, layoutHeight) { navigationIconPlaceable.place(x = 0, y = 0) actionIconsPlaceable.place(x = constraints.maxWidth - actionIconsPlaceable.width, y = 0) bigTitlePlaceable.place(x = (titleInset + navigationIconPlaceable.width * expandedRatio).toInt(), y = navigationIconPlaceable.height - (bigTitlePlaceable.height * expandedRatio).toInt()) smallTitlePlaceable.place(x = navigationIconPlaceable.width + titleInset, y = (layoutHeight - smallTitlePlaceable.height) / 2) } } } private val animationSpec: AnimationSpec&lt;Float&gt; = SpringSpec(dampingRatio = Spring.DampingRatioLowBouncy, stiffness = Spring.StiffnessMediumLow) private const val COLLAPSE_THRESHOLD = 0.5f private fun CoroutineScope.onScroll(scrollState: ScrollState, shiftY: Int, collapsedFraction: Float) { if (scrollState.value &lt; shiftY) { launch { scrollState.animateScrollTo(if (collapsedFraction &lt; COLLAPSE_THRESHOLD) 0 else shiftY, animationSpec) } } } 최종 구현",
    "tags": "Android Compose",
    "url": "/jekyll-theme-yat/android/2024/03/07/%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%BB%A4%EC%8A%A4%ED%85%80-TopAppBar%EB%A7%8C%EB%93%A4%EA%B8%B0.html"
  },{
    "title": "자동으로 폰트 크기 조절되는 Text Composable만들기",
    "text": "자동으로 폰트 크기 조절되는 Text Composable만들기 필요성     &lt;img src=\"https://github.com/pknujsp/pknujsp/assets/48265129/154a7984-643f-4e67-9a5c-bc5d40514b60\"&gt; &lt;img src=\"https://github.com/pknujsp/pknujsp/assets/48265129/53127974-2c00-4f2a-b654-037b9fea7e46\"&gt; Text를 화면에 보여줄 때, 값의 길이가 길어지면 위와 같이 내용이 잘리게 된다.(maxLines = 1인 경우) 잘리지 않게하려면 길이에 따라 폰트 크기를 조절한 후 Text를 그리면 된다. 이를 위해 다음 단계를 따르면 된다. BoxWithConstraintsComposable 내에 Text Composable을 배치한다. BoxWithConstraints를 사용하면 화면상에 그려질 수 있는 크기를 알 수 있다. TextMeasurer를 사용해 Text가 화면에서 실제로 보여지는 크기를 구하고, 폰트 크기를 바꿔준다. 구현 1 @Composable fun AutoText( modifier: Modifier = Modifier, text: String, style: TextStyle, overflow: TextOverflow = TextOverflow.Clip, minFontSize: Int = MIN_AUTO_SIZING_TEXT_SIZE, defaultFontSize: Int = DEFAULT_AUTO_SIZING_TEXT_SIZE, step: Int = 1 ) { BoxWithConstraints(modifier = modifier) { val textMeasurer = rememberTextMeasurer() val textOverflow = remember(overflow) { if (overflow == TextOverflow.Ellipsis) TextOverflow.Clip else overflow } var textStyle by remember(text) { mutableStateOf(style.copy(fontSize = defaultFontSize.sp)) } LaunchedEffect(textStyle) { textMeasurer.measure(text, textStyle).run { if (textStyle.fontSize.value.toInt() &gt; minFontSize &amp;&amp; size.width &gt;= constraints.maxWidth || size.height &gt;= constraints.maxHeight) { val newFontSize = (textStyle.fontSize.value.toInt() - step).coerceAtLeast(minFontSize) textStyle = textStyle.copy(fontSize = newFontSize.sp) } } } Text(text = text, maxLines = 1, style = textStyle, overflow = textOverflow) } } val textMeasurer = rememberTextMeasurer() : Text의 크기를 측정하는 데 쓰인다. var textStyle by remember(text) { mutableStateOf(style.copy(fontSize = defaultFontSize.sp)) } : textStyle을 조정해야 하므로 State로 생성한다. text가 변경되면, textStyle는 초기화된다. LaunchedEffect(textStyle) { ... } : textStyle이 변경될 때 마다 실행된다. textStyle이 변경되면, Text의 크기를 다시 측정하고, constraints와 비교하여 동적으로 폰트 크기를 조절한다. if (textStyle.fontSize.value.toInt() &gt; minFontSize &amp;&amp; size.width &gt;= constraints.maxWidth || size.height &gt;= constraints.maxHeight) : textStyle의 폰트 크기가 minFontSize보다 크고, Text의 크기가 constraints를 초과하는지 검사 위 코드의 단점 코드가 길다 현재 textMeasurer으로 text의 크기를 측정하여 처리하는 로직을 직접 구현했는데, 이 부분은 감사하게도 Text Composable 파라미터로 제공되는 onTextLayout을 사용해서 코드를 간결하게 정리할 수 있다. 간편하게 Text(..., onTextLayout = {})의 onTextLayout람다를 사용하면 된다. 이 람다는 text의 레이아웃이 새롭게 계산될 때 실행되는 콜백이기 때문에, 람다 인자로 전달되는 TextLayoutResult의 didOverflowWidth와 didOverflowHeight를 통해 Text의 크기가 주어진 크기를 초과하는지 알수 있다. 구현 2, 최종 private const val MIN_AUTO_SIZING_TEXT_SIZE = 12 private const val MAX_AUTO_SIZING_TEXT_SIZE = 30 /** * [minFontSize] ~ [defaultFontSize] 범위 내에서, [step]만큼 fontSize를 동적으로 * 조절하면서, [TextOverflow]가 발생하지 않도록 하는 Text Composable * * @param modifier * @param text * @param style * @param overflow [TextOverflow.Ellipsis]는 사용 불가(동적 크기 조절이 이루어지지 않는다) * @param minFontSize * @param defaultFontSize * @param step * */ @Composable fun AutoAdjustingFontSizeText( modifier: Modifier = Modifier, text: String, style: TextStyle, overflow: TextOverflow = TextOverflow.Clip, minFontSize: Int = MIN_AUTO_SIZING_TEXT_SIZE, defaultFontSize: Int = DEFAULT_AUTO_SIZING_TEXT_SIZE, step: Int = 1 ) { BoxWithConstraints(modifier = modifier) { val textOverflow = remember(overflow) { if (overflow == TextOverflow.Ellipsis) TextOverflow.Clip else overflow } var textStyle by remember(text) { mutableStateOf(style.copy(fontSize = defaultFontSize.sp)) } Text(text = text, maxLines = 1, style = textStyle, overflow = textOverflow, modifier = Modifier, onTextLayout = { if (textStyle.fontSize.value.toInt() &gt; minFontSize &amp;&amp; it.didOverflowWidth || it.didOverflowHeight) { val newFontSize = (textStyle.fontSize.value.toInt() - step).coerceAtLeast(minFontSize) textStyle = textStyle.copy(fontSize = newFontSize.sp) } }) } } 사용 예시 Box { AutoAdjustingFontSizeText( text = \"value\", modifier = Modifier.fillMaxWidth(), style = TextStyle(color = Color.Black, fontWeight = FontWeight.SemiBold), ) } 다음과 같이 자동으로 조절됨을 확인할 수 있다.",
    "tags": "Android Compose Text AutoAdjustingFontSize",
    "url": "/jekyll-theme-yat/android/2024/01/09/%EC%9E%90%EB%8F%99-%ED%8F%B0%ED%8A%B8-%ED%81%AC%EA%B8%B0-%EC%A1%B0%EC%A0%88-Text-Composable%EB%A7%8C%EB%93%A4%EA%B8%B0.html"
  },{
    "title": "2023년을 돌아보며",
    "text": "2023년의 마지막이 코 앞으로 다가온 현재, 올해 내가 했던(지금까지도 하고 있는) 일들과 그 과정에서 느끼고 생각하며 배운 점을 정리하여 2024년을 어떻게 살아갈지 작성해보고자 한다. 2023, 다양하게 많은 일이 있었다 1. 대학교 4학년 시작 전 겨울방학 동안 현장 실습 진행 2022년 12월 ~ 1월 한 달간 계절 학기로 한 기업체에서 현장 실습(인턴)을 진행하였다. 주 업무는 이미지 분류, 객체 탐지를 위한 Ai 학습 이미지에 대한 전 처리 작업 수행이었다. 추가적인 업무로 내가 잘 모르는 분야인 Ai 비전 모델 학습 및 검증도 수행했다. 회사의 사업 모델이 건강 관련 Ai인데, 여기서 Ai로 분류하고자 하는 이미지(데이터)는 특징과 패턴이 명확하지 않고, 의사도 정확하게 구분 짓지 못하는 정도라 괜찮은 Ai 모델을 학습 시키는 데에 큰 어려움이 있었다. 일하면서 논문과 자료를 찾는데 많은 시간을 할애했다. 또한 OpenCV로 코딩도 많이 했었고, Ai 모델들을 학습도 시켜봤었다. 마침 그 시기에 ChatGPT가 오픈해서 도움을 많이 받기도 했다. 짦은 기간 이었지만 여러모로 많은 걸 느끼고 배웠다. 하루종일 자료 찾고 코딩하는게 흥미롭고 재밌었는데 이 때 내 적성이 개발임을 확신하게 되었다. 좋았던 추억이다. 회사에서 키우던 귀여운 고양이, 사장님, 직원분들 모두 좋은 분들이라서 느끼는 감정이지 싶다. 이 때 경험이 취업 후에 도움이 될 거 라고 생각한다. 2. Medilenz 앱 개발 3월 ~ 현재 진행 의약품 정보를 찾고, 사람들과 댓글로 이야기를 나눌 수 있으며, 카메라로 약을 비추면 비전 Ai가 2000개 종류의 약을 자동 검색해주는 앱 교내 동아리 WAP 에서 팀을 꾸려 진행하고 있는 프로젝트로, 내게 큰 전환점이라 여기는데, 그 이유는 정말 많은 기술과 API를 배우고 적용해볼 수 있었기 때문이다. 백엔드 개발자 분들과 함께 진행해본 첫 프로젝트 코루틴을 전체적으로 적용해본 첫 프로젝트 이기도 하다 소스코드 패키지 모듈화 Compose 사용 있는지도 몰랐던 바인딩 어댑터 등 여러 API를 사용 내부적으로 구현한 기능을 외부 라이브러리로 배포 현장 실습 때의 경험으로 Ai 모델 학습 Ai학습을 위해 데이터 전처리, Ai 작업에 상당히 많은 시간이 걸렸다 백엔드 관련 지식 습득 이 중에서 안드로이드 관련해서는 같이 안드로이드 개발을 진행한 @tgyuuAn님이 열정적으로 함께 해주신 덕분에 얻은 경험과 지식이다. 정말 감사하다. 실제로는 더 길고 많은 내용이 있다 또한 앱의 규모를 내가 처음 구상했던 것 보다 많이 키웠는데, 이 선택이 개발자로서 성장하는데 내게 큰 도움이 되었고, 키우길 잘했다고 느낀다. 처음 앱을 구상했을 때 빠르게 개발하고자 기능을 최대한 단순하게 가려고 했었다. 먼저 의약품 관련 앱을 구상한 시점이 현장 실습 때였는데, 그 때 Ai 모델을 단순히 가져다 학습을 시키는 건 간단하다는 걸 알게 되었다. 그래서 다음 번에 앱을 만든다면 Ai를 적용하고자 했었고, 마침 그 때 내가 먹던 약이 있었는데, 약을 카메라로 찍으면 자동으로 찾아주는 앱이 있었으면 좋겠다는 생각이 들면서, 이번 프로젝트를 진행하게 되었다. 기능으로 간단하게 Ai로 약을 찾고 정보를 볼 수 있는 정도만 구현하자 했었는데, 점점 계속 생각하면 할 수록 이거 잘 만들면 되게 괜찮을 거 같았다. 이 때문에 단순히 Ai가 있는게 아니라 다른 사람들과 소통하면서 약 정보를 알아갈 수 있는 커뮤니티 앱으로 발전시켜나갔고, 현재는 약 정보를 찾고, 커뮤니티와, Ai 기능을 모두 다 갖춘 앱으로 만들고 있다. 기능이 늘어나니 서버가 필요하게 되었고, 백엔드 개발자 분들도 모집하여 함께하게 되었다. 백엔드 개발자 분들(@ho-sick99, @winocreative)은 내가 생각했던 기능을 다 구현해주셔서 정말 감사했다. 백엔드 개발자 분들과 함께 작업하면서 관련 지식(JWT, HTTP 등)을 습득할 수 있었고, 서버와 클라이언트가 어떻게 통신하는지, 어떤 방식으로 데이터를 주고 받는지 등을 알 수 있었다. 백엔드 개발자와는 처음 작업을 한거라 클라이언트만 다루는 내겐 소중한 경험이었다. 작업 진행 3 ~ 6월 기획, 디자인, 개발, 배포(알파 단계) 동아리에서 3차 까지 프로젝트 진행 현황을 발표(기획: 3월 말, 중간: 4월 초, 최종: 6월 초)하였다. 나는 안드로이드, Ai(혼자)를 담당했다. 학교 수업과 시험 때문에 오로지 개발에 시간을 쏟을 수 있는 시간은 짧은 편이었지만, 정말 재밌고 행복하게 개발했다. 서로 코드 리뷰 하면서 의견을 나누고 코드를 고치는 등 협업이 잘 진행되었는데, 내 코드를 다른 분이 읽고 피드백을 하는 게 필요했기 때문에 이 과정에서 나의 잘못된 습관이나 코드 형태를 어느 정도 파악하고 개선할 수 있었다. 또한 내가 잘 모르는 것을 배울 수 있어 좋았다. 그런데 Ai 작업은 달랐다. Ai 학습 자체는 간단하지만, 다른게 문제였다. 학습 데이터는 Ai Hub에 있다는 걸 알고 기획했던 거라 지장이 없었는데, 학습할 컴퓨터가 가장 큰 문제였던 거다. 인턴 때는 초기 데이터 세트가 크지 않아서 지장이 크게 없었는데, Medilenz는 다르다. 의약품 5,000개를 분류해야 하는 Ai이기 때문에, 학습하려면 약 하나 당 최소 100장은 써야하며, 이걸 다 합치면 크기가 어마어마하다. 이런 이유로 컴퓨터 성능이 절대적으로 중요한데, 슬프게도 학습이 가능한 컴퓨터가 없어서 구글 코랩, AutoML 등 여러 방법을 시도해봤지만, 결국 만족할 만한 성과는 얻지 못했다. 따라서 Ai 작업은 제대로 못했고 최종 발표에서 Ai기능 시연은 당연하게도 실망적이었다. 그래도 Ai만 빼면 기획 당시 얘기했던 걸 다 구현했기에 발표는 잘 마무리했다. 7월 ~ 현재 리팩터링, 기능 추가 백엔드, Ai 작업 진행 학교 종강 후 7월에 다시 작업을 재개 했다. 다른 팀원 분들과 같이 열심히 으쌰으쌰 하며 개발했다. 나는 Ai를 어떻게든 처리해보고자 8월에 좀 싸게 컴퓨터를 샀었다. 열심히 데이터 라벨링과 수 많은 모델 별로 학습을 두 달 동안 한 결과, 60% 이상의 추론능력을 가진 Ai 모델을 마침내 구축하는데 성공했다. 컴퓨터가 좋지는 않아서 약은 2,000개 종류만 학습시켰다. 그래도 2,000개 종류의 약을 분류할 수 있는 Ai 모델을 만들었다는 것에 만족한다. 아쉽지만 몇 백만원 컴퓨터를 구입할 여력은 없었기에 어쩔수 없다. 그리고 백엔드 개발도 좀 해보았다. 서버가 8월 까지 @winocreative님의 개인 컴퓨터에서 돌아가는 상황이었다.(지난 몇 달 동안 서버를 돌릴 수 있게 해주셔서 정말 감사하다) 하지만 언제까지나 계속 그렇게 운영할 수는 없다고 생각했다. 내 컴퓨터가 아니니까. 그래서 한번 백엔드 개발해보는 것도 흥미로울거 같아 개발하기 시작했다. 스프링이나 노드.js를 배워서 구축하기에는 비효율적이라 생각했고, AWS를 기반으로 서버를 구축하기로 했다. 이쪽 분야는 초급 수준도 안되기 때문에 많이 어려웠다. 다행히 만들 기능이 적고 단순한거라 냈고, API Gateway에 연동하여 클라이언트와 실제 통신 하는 작업만이 남았다. 아직 끝나지 않았고 현재 진행형이다. 그런데도 참 많이 배우고 성장할 수 있었다. 특히 얇게 나마 백엔드, Ai를 다뤄보는 경험이 지식의 폭을 넓혀주었기 때문에 상당히 긍정적이다. 최근에 작업을 멈췄지만 곧 재개해서, 플레이스토어에 출시 하겠다. Medilenz를 위해 함께 해주시는 팀원 @tgyuuAn, @winocreative, @ho-sick99 세 분 모두 감사하고 리스펙을 보낸다. 3. 안드로이드 개발 스터디 5월 ~ 현재 진행 항상 하고 싶었던 거였고, 마침내 시작했다. 이 스터디도 WAP 내에서 그룹을 만들어 진행하고 있다. 개인 블로그에 공부한 내용을 작성한 것을 매주 발표하는 식으로 진행하고 있다. 많은 도움이 되고 있고 정말 잘 했다고 생각한다. 내가 몰랐던 부분을 알아갈 수 있고, 코드도 참고하기 좋다. 특히 기술 내용을 얘기할 수 있는게 나에겐 참 좋은 부분이다. 이 스터디가 아니라면 다수와 코딩얘기 하는게 쉽지 않기 때문이다. 기술적인 내용을 공유하는 것 뿐만 아니라, 개인 발표를 한다는 것에서도 큰 힘이 된다. 공부한 내용을 말로 누군가에게 설명하는게 좋은 공부법 인데다가, 나서서 발표를 하는 경험을 하기가 쉽지 않은데 지금 경험을 쌓아갈 수 있으니 얼마나 다행인지 모르겠다. 나중에 회사나 어떠한 자리에서 발표를 하게 되는 경우에 경험이 별로 없다면 앞이 컴컴할거다. 스터디를 함께 한 @jeongjaino, @tgyuuAn, @Zepelown, @Redish03, @SeongHoonC 다섯분 모두에게도 감사와 리스펙을 보낸다. 4. 라이브러리 배포 개발하면서 외부 라이브러리 사용은 필수적이다. 어느 순간 나도 라이브러리를 만들어 배포하고 싶다는 생각이 들었다. 다른 개발자가 가져다 쓰면 고맙지만, 안쓰더라도 경험 삼아 만들어보고 싶었다. 물론 버그 덩어리면서 쓸모없는 라이브러리여서는 안된다. 이렇게 생각만 가지고 있다가 같은 동아리인 @alstn113님이 리액트 라이브러리를 배포하는 것을 보고 실행에 옮겼다. 배포한 건 두 개이다. smartdeeplink: 안드로이드 네비게이션 컴포넌트로 딥링크 이동시에 데이터 전달을 간편하게 해주는 라이브러리 ksealedbinding: 코틀린 sealed class 바인딩 함수를 자동으로 생성해주는 라이브러리 Medilenz개발 시 딥링크로 다른 모듈의 화면으로 이동할 때 네비게이션 컴포넌트를 사용했는데, 제공하는 API로는 출발지에서 도착지 화면으로 데이터를 전달하기가 까다로웠다. 그래서 이를 간편하게 해주는 라이브러리(smartdeeplink)를 만들어 배포했다. ksealedbinding은 코틀린 sealed class사용 시 불편함을 느꼈기 때문에 제작했다. enum의 기능을 제공하는 sealed class가 있다. 보통 부모 sealed class의 자식 클래스 별로 when, if로 분기 처리를 하여 다음 작업을 진행하게 된다. 이 때, 자식 클래스가 많아지면 분기 처리가 많아지고, 코드가 길어지는 단점이 있다. 이를 좀 개선해보고자 @KBindFunc 어노테이션을 부모 sealed class에 붙여주면, on자식클래스명의 이름으로 컴파일 시 자동으로 함수를 생성해주는 기능을 만들었다. 이걸 쓰면 분기문 없이 함수형으로 다음 작업을 진행할 수 있다. 이 라이브러리를 사용하면 코드가 간결해지고 가독성이 좋아진다. 따로 개인 개발 중인 앱이 있는데 잘 써먹고 있다. @KBindFunc sealed class TestSealed { data object A : TestSealed() data object B : TestSealed() data object C : TestSealed() } // 적용 전 when(result) { is TestSealed.A -&gt; { // A일 때 실행 } is TestSealed.B -&gt; { // B일 때 실행 } is TestSealed.C -&gt; { // C일 때 실행 } } // 적용 후, 함수형으로 사용한다 result.onA { // A일 때 실행 }.onB { // B일 때 실행 }.onC { // C일 때 실행 } 라이브러리를 실제로 사용하는 지는 모르겠는데, ksealedbinding은 Github clone 기록을 보니 최소 수십명이 클론했다고 나온다. 사용자가 거의 없는 건 맞는거 같다. 하지만 아쉽거나 괜히 만들었나 싶은 생각은 전혀없는데 수요를 기대하고 개발한 게 아니라서 그렇다. 몇 달간 유기해놓아서 조만간 업데이트를 진행할 것이다. 꾸준히 관리해나가다 보면 수요는 늘지 않을까. smartdeeplink는 뷰에 최적화 되어 있어 컴포즈를 지원하도록 업데이트 할 예정이고, ksealedbinding은 자식 클래스의 속성이 많아지면 간간히 컴파일 시 오류가 발생하는 문제가 있어, 오류를 해결해야 한다. 또한, 현재는 컴파일 시에 함수가 자동 생성되는데 Gradle 플러그인으로 변경해서 실시간으로 자동 함수 생성이 되도록 업데이트 할 예정이다. 5. GDG I/O Extended, Devfest 컨퍼런스 참가 및 두 번의 연사 경험 연사 WAP(11월) GDSC PKNU 2023년도 2분기 TechTalk(5월) &lt;img src=\"https://github.com/pknujsp/pknujsp/assets/48265129/e2af6eda-324d-4fd4-bcf5-6651c665571f\" width=\"auto\" height=\"auto\"&gt; &lt;img src=\"https://github.com/pknujsp/pknujsp/assets/48265129/52fc09ed-a83b-47e3-baa8-a9f35dad18c3\" width=\"50%\"&gt; 좌측부터 여러 프로그래밍 언어를 비슷한 구문과 문법에 따라 한번에 배우기, 앱 아이콘 클릭부터 앱 실행까지의 여정을 주제로 발표했었다. 여러 프로그래밍 언어를 비슷한 구문과 문법에 따라 한번에 배우기: 프로그래밍 언어는 대체적으로 기본적으로 비슷한 형태를 가지고 있기 때문에, 언어를 배우면 다른 언어를 배우기가 쉬워진다는 것을 알려주고자 발표했다. 발표를 준비하면서 여러 언어들을 비교해보면서 프로그래밍 패러다임 관련한(객체지향) 부분이나 자료형 등 몇몇 영역을 제외하고는 비슷한 구조를 가지고 있음을 다시 한번 알 수 있었다. 공부할 게 많아 준비에 시간을 나름 많이 투자했는데, 개인적으로 발표를 잘 못해서 아쉽다. 앱 아이콘 클릭부터 앱 실행까지의 여정: 안드로이드 액티비티가 열리는 과정에 대한 내용이 궁금했는데, 인터넷에 관련한 자료가 거의 없어서 직접 공부해본 후 공유해보고자 발표를 하였다. 자료가 너무 없다보니 Android Code Search에서 코드를 뒤적뒤적 하면서 공부했는데, 보다보니 안드로이드 OS 코드는 아주 정교하고 추상화가 잘 되어있다는 생각이 들었고, Zygote, Application Thread등 여러 모듈이 상호 작용하면서 앱이 실행되는 과정이 흥미로웠다. 안드로이드 개발자 공식 문서에 이런 내용이 있으면 좋겠다는 생각이 든다. GDG Songdo Devfest, GDG I/O Extended GDG Songdo Devfest(12월) GDG I/O Extended Busan(9월) &lt;img src=\"https://github.com/pknujsp/pknujsp/assets/48265129/41a3e156-47bc-4295-b608-9f232b52b209\" width=\"auto\"&gt; &lt;img src=\"https://github.com/pknujsp/pknujsp/assets/48265129/e9037efc-1310-4f03-a523-e44ed95f673a\" width=\"50%\"&gt; 9월 I/O Extended Busan에서 현업자 분과 길게 대화하면서 많은 걸 얻어갔기 때문에, 그런 컨퍼런스를 또 한다면 꼭 가야겠다고 다짐했었다. 마침 12월에 인천에서 GDG Songdo Devfest가 열렸고, 멀지만 당일치기로 다녀왔다. 연사자 분들께 내가 평소에 궁금했던 것들을 질문하고, 답변을 들을 수 있어서 좋았다. 그리고 내 옆에는 광주광역시에서 왔다는 고등학생 분이 계셨는데 신기하면서도 대단하다고 느꼈다. 열심히 들으시는 걸 보면서 나중에 뛰어난 개발자가 될거 같았다. 여기를 다녀와서 여러 생각과 고민을 하게 되었다. 원래는 SSAFY, 우아한테크코스, 소프트웨어 마에스트로 등 교육 프로그램은 최대 1년의 긴 기간 동안 연수를 받아야 하니 그냥 빨리 취업하자 였는데, 같은 분야에 몸 담고 계시는 다른 분들과 얘기하고 강연을 듣고 나니, 내가 아직 한참 부족하고 멀었다는 느낌이 더 크게 들었다. 그러다보니, 내가 더 성장할 수 있는 환경에서 공부하는 것도 좋을거 같다는 생각이 들었고, 평소 알고있던 소프트웨어 마에스트로가 최적이라고 생각되어 여기에 합격하기 위해 준비하고 있는 상태이다. 너무 매력적이고 좋아보인다. 확실하게 여러 단계 내가 더 성장할 수 있지 않을까 싶다. 학교 다닐 때는 학교 공부 때문에 개발에 온 집중을 못했는데, 연수 기간 동안에는 집중이 가능할테니 기대된다. 하지만 취업 준비는 여전히 하고 있다. 6. 알고리즘 스터디 10월 ~ 현재 진행 평소에 코딩 테스트를 위해 알고리즘 문제 풀이를 하고 있었는데, 어려운 문제는 맞춰도 내가 괜찮게 푼건지를 잘 모르겠어서 같이 풀이를 공유하고 서로 피드백을 주고받으면서 성장할 수 있는 스터디를 하고 싶었다. 마침 동아리 내에서 스터디를 할 수 있게 되어서 현재까지 계속 진행 하고 있다. 문제 풀이를 공유하고 리뷰를 하고, 받아가면서 점점 실력이 향상 됨을 느끼고 있다. 요즘 코딩 테스트가 워낙 중요하다보니 걱정이 앞서는데, 스터디로 자신감이 점점 붙고 있다. 그래서, 2024년은 어떻게 보낼까 현재로서는 앱 개발, 알고리즘 문제 풀이 이 두 개가 최우선이다. 빠른 시일 내로 앱을 출시해서, 포트폴리오를 추가하고자 한다. 알고리즘 문제 풀이는 점점 난이도를 올려서 실전에서도 흔들리지 않고 풀어낼 수 있게 준비해야 겠다. 취업은 걱정이 안되면 좋겠지만, 걱정이 된다. 근데 걱정이 되는게 사람으로서 당연한거라고 생각한다. 안되는게 신기한거다. 내가 할 수 있는 만큼 다 해보고, 더 노력해보자. 보니까 다른 사람들도 다 비슷한 상태인 거 같다. 개발에 미치고 성장을 갈망하자.",
    "tags": "Private",
    "url": "/jekyll-theme-yat/private/2023/12/30/2023%EB%85%84%EC%9D%84-%EB%8F%8C%EC%95%84%EB%B3%B4%EB%A9%B0.html"
  },{
    "title": "코틀린 코루틴을 활용해 데이터 메모리 캐시 기능 구현하기",
    "text": "구현 목적 앱을 제작하면서 온라인에서 가져온 데이터를 메모리에 캐싱해야 할 필요가 있었다. 그 이유는 해당 데이터의 서버 상에서 업데이트 주기가 수 십분 ~ 수 시간 단위로 긴데, 이 데이터를 짧은 간격으로 다시 중복으로 가져오는 것은 비효율적이기 때문이다. 그래서 메모리에 캐싱하는 기능을 만들었고 효율성을 개선할 수 있었다. 비효율적인 기존 방식 총 세 가지의 지역(A, B, C)에 대해서 대기질 데이터를 가져오는 기능을 구현했다고 가정하였다. 흐름 A의 대기질 데이터를 로드 B 정보 화면으로 전환 -&gt; B의 대기질 데이터를 로드 A 정보 화면으로 재 전환 -&gt; A의 대기질 데이터를 로드 C 정보 화면으로 전환 -&gt; C의 대기질 데이터를 로드 A 정보 화면으로 재 전환 -&gt; A의 대기질 데이터를 로드 20초간 A의 데이터를 3번 로드하였고, 이 시간동안 서버 상에서 데이터가 갱신되지 않았다면 중복된 데이터를 2번 불러오게 된다. 만약 업데이트 주기가 길고, 화면 전환이 잦다면 위와 같은 상황은 빈번하게 발생할 것이다. 최근에 날씨 앱을 제작하고 있는데, 여러 부분에서 이런 상황이 발생하였다. 화면을 전환하였다가 다시 돌아왔을때 데이터를 다시 불러옴(짧은 주기) 날씨 정보 화면 -&gt; 앱 설정 화면 -&gt; 날씨 정보 화면 같은 지역의 데이터를 비슷한 시점에 다른 기능 구현을 위해 불러옴 위젯, 알림, 앱 날씨 화면이 거의 동시에 업데이트 되는 경우 계속 최신 데이터만 받아온다면, 최악의 경우 같은 데이터를 수십번 동시다발적으로 불러올 수도 있다. 예보 비교 화면(시간별, 일별) 예를 들어, A지역의 시간별 예보를 불러온지 몇초 밖에 지나지 않은 상태에서 여러 날씨 제공사의 예보를 비교하려고 한다면, 같은 제공사의 데이터를 다시 불러올 수도 있다. 다수의 문제점이 발생하였고, 데이터를 좀더 효율적으로 관리할 필요가 있었다. 그래서 코틀린 코루틴을 활용하여 데이터를 관리하는 기능을 구현하였다. !이러한 상황이 무조건 비효율적이라고 정답을 내릴 수는 없다. 만약 업데이트 주기가 아주 짧으면서, 최신 데이터만을 UI에 보여주려고 한다면 위와 같은 방식을 사용하는 것이 더 나을 수도 있다. 구현 방식 코루틴 앱에서 코루틴을 사용하여 비동기 로직을 처리하고 있기 때문에, 코루틴으로 구현하였다. 캐시 관리 캐시 시간 제한 Lru Cache 캐시 시간 제한 캐시 기능이 필요한 이유이기 때문에, 가장 우선적으로 구현하였다. 서버에서 데이터를 가져와서 캐시에 저장할 때, 데이터의 유효 시간을 함께 저장한다. 이후 캐시를 불러올 때 현재 시간과 캐시의 유효 시간을 비교하여 캐시가 유효한지 확인한다. 만약 유효하지 않다면, 다시 서버에서 데이터를 가져와서 캐시에 저장한다. Lru Cache 설계시 미처 고려하지 못한 것으로, 한창 구현하다가 저장된 캐시의 크기가 너무 커지는 문제가 발생할 수 있음을 깨달았다. 이를 해결하기 위해 Lru Cache를 사용하였다. Lru Cache는 가장 오랫동안 사용되지 않은 데이터를 삭제하는 캐시 관리 기법이며, 저장할 캐시의 최대 개수(크기)를 지정할 수 있다. 예를 들어, 최대 크기를 3으로 지정하였을 때, 4번째로 캐시가 추가될 때 1번째로 추가된 캐시는 삭제된다. Lru Cache에 대해선 이전에 작성한 포스팅 ArrayMap, SparseArray, LruCache에 대해서 알아보기 을 참고하면 도움이 될 것이다. 데이터 동기화 여러 스레드에서 동시에 캐시에 접근할 수 있기 때문에, 데이터 동기화를 해주어야 한다. 가장 중요한 부분, 섬세한 로직이 요구되었다. 적용해본 동기화 방식 Mutex, Synchronized ConcurrentHashMap ReentrantReadWriteLock Actor 여러 방식으로 테스트 해보면서 Actor로 최종 구현하였다. 이 과정에서 코루틴의 동작 방식에 대해 더욱 깊게 이해할 수 있었다. 1. Mutex, Synchronized 제일 먼저 적용한 기법이다. Mutex는 Mutual Exclusion의 약자로 상호 배제를 의미한다. 임계 구역을 만들고 그 구역을 통해서 스레드가 데이터에 접근한 뒤 구역을 잠궈서, 다른 스레드는 접근할 수 없도록 막는 기법이다. 스레드 A, B가 동시에 어떤 로직을 시작하려고 할 때, A가 먼저 시작하면 B는 A가 끝낼 때 까지 그 로직 수행을 못하고, A가 작업을 끝내야만 B가 수행할 수 있다. Synchrnoized도 이와 유사하다. 예를 들어, Map을 Mutex 또는 Synchronized로 동기화하면, 그 Map은 동시에 하나의 스레드만 다룰수 있기 때문에, 데이터 동기화가 보장되는 것이다. Mutex, Synchronized의 차이   Mutex Synchronized 동작 기반 프로그램 구동 플랫폼, 코루틴에 최적화 JVM 소유권 접근하는 스레드가 잠그고,해제하는 소유권을 가짐 소유 개념이 없음 잠금해제 대기 방식 코루틴 동작을 일시중지 스레드 동작을 일시중지 재진입 불가능, 스레드 A가 Mutex를 잠그고 다시 Mutex를 접근하면 그대로 무한 대기에 빠질 수 있음 가능, 한 스레드가 Synchronized에 접근한 상태에서 다시 Synchronized하더라도 문제없이 그대로 접근가능 잠금해제를 대기하는 방식에서 확실한 차이가 있다. Mutex : 대기하는 동안 다른 작업 가능, 코루틴에 최적화되어 있어 대기하는 동안 다른 코루틴으로 작업을 넘길 수 있다. Synchronized : 대기하는 동안 다른 작업 불가능 하나의 칸만 있는 화장실이 있는 상황으로 비교해보자면 다음과 같다. Mutex : 다른 사람이 나올때 까지 기다리는 동안, 휴대폰을 보는 등 다른 작업을 할 수 있다. Synchronized : 기다리는 동안 아무것도 못한다. 휴대폰도 없고 뭐도 못한다. 그냥 기다린다. 2. ConcurrentHashMap 우리가 직접 따로 임계 구역을 만들어 동기화 할 필요없이 자체적으로 동기화를 지원하는 Map이다. Map을 예로 들어, Mutex, Synchronized로 임계 구역을 통해 동기화를 하게 되면 Map전체에 대해서 다른 스레드는 접근할 수 없게 된다. 하지만 ConcurrentHashMap은 Map의 일부분만 잠그고, 나머지 부분은 다른 스레드가 접근할 수 있게 해준다. Map의 key로 1, 2가 있을 때 Mutex, Synchronized 를 쓴다면, 1에 대한 작업을 하고 있는 동안 2에 대한 작업을 할 수 없다. ConcurrentHashMap을 쓴다면, 1에 대한 작업을 하고 있는 동안 2에 대한 작업을 할 수 있다. 3. ReentrantReadWriteLock ReentrantReadWriteLock은 Mutex와 Synchronized와 다르게, 읽기와 쓰기 각각에 대해 잠금을 걸 수 있다. 즉, 읽기 잠금과 쓰기 잠금을 따로 걸 수 있다. 쓰기 잠금을 걸었다면 다른 스레드는 읽기와 쓰기 모두 불가능하다. 읽기 잠금을 걸었더라도 다른 키로 접근한다면 읽을 수 있다. 4. Actor Actor Model 패턴으로 동기화를 구현하는 방법이다. Concurrency with Actor Model(행위자 모델) 페이지에 상세히 정리되어 있어 추가로 참조하면 도움이 될 것이다. 특정 기능을 전문적으로 수행하는 기능을 하는 것이 Actor이다. 외부에서 Actor에게 메시지를 보내면, Actor는 메시지를 처리하고 결과를 다시 보내준다. 하나의 Actor는 동시에 작업을 수행하지 않고 동기적으로 하나씩 처리하기 때문에, 데이터 동기화가 보장된다. 액터 모델 패턴을 실생활로 비유하자면, 액터는 어떤 특정한 기능을 전문적으로 수행하는 사람이다. 다른 사람은 이 사람과 메시지 채팅으로 소통을 할 수 있다. 특징 작업을 메시지를 받는 순서대로 처리한다. (메시지 큐) 순서대로 처리하므로 별도의 동기화를 해줄 필요가 없다. 메시지 별로 분기하여 독립적인 작업을 수행하기 때문에, 다른 방식 대비 코드가 더 직관적이고 간결하다. 최종 구현 방식 Actor, 여러 방식을 적용해보면서, 개인적으로 코드가 가장 직관적이면서 관리하기 편했고 코루틴에 최적화 되어 있어 이를 선택했다. ! 가장 좋은 방식을 뽑는다면 정답이 없다고 할 수 있다. 구현 코드 CacheManager 캐시 관리 기능을 담당하는 클래스이다. 캐시를 저장하고, 불러오고, 삭제하는 기능을 제공한다. defaultCacheExpiryTime : 캐시의 기본 유효 시간 cleaningInterval : 캐시 정리 주기 cacheMaxSize : 캐시 최대 개수 abstract class CacheManager&lt;K, V&gt;( protected val defaultCacheExpiryTime: Long, protected val cleaningInterval: Long, protected val cacheMaxSize: Int ) { abstract suspend fun get(key: K): CacheState&lt;V&gt; abstract suspend fun remove(key: K): Boolean abstract suspend fun put(key: K, value: V, cacheExpiryTime: Long = defaultCacheExpiryTime) abstract suspend fun entries(): List&lt;Pair&lt;K, Cache&lt;V&gt;&gt;&gt; sealed interface CacheState&lt;out V&gt; { data class Hit&lt;V&gt;(val value: V) : CacheState&lt;V&gt; data object Miss : CacheState&lt;Nothing&gt; } } CacheCleaner 코루틴 작업으로 에약되어 설정한 주기마다 자동으로 만료된 캐시를 정리하는 기능을 on/off 할 수 있는 인터페이스이다. interface CacheCleaner { fun start() fun stop() } Cache Map으로 키와 함께 저장되는 캐시 값이다. value : 캐시 값 cacheExpiryTime : 캐시 유효 시간 addedTime : 캐시 추가 시간 data class Cache&lt;V&gt;( val value: V, val cacheExpiryTime: Long, val addedTime: Long = System.currentTimeMillis() ) { fun isExpired(now: Long = System.currentTimeMillis()): Boolean = now - addedTime &gt; cacheExpiryTime } CacheManagerImpl(실제 구현체) 위 추상클래스와 인터페이스를 구현한 클래스이다. cacheExpiryTime : 캐시의 기본 유효 시간 cleaningInterval : 캐시 정리 주기 cacheMaxSize : 캐시 최대 개수 dispatcher : 코루틴 디스패처 cacheActor : 캐시 관리 기능을 담당하는 Actor isCacheCleanerRunning : 캐시 정리 작업이 실행중인지 여부 waitTimeForCacheCleaning : 캐시 정리 작업이 실행중일 때, 대기할 시간 cacheCleanerJob : 캐시 정리 코루틴 작업 class CacheManagerImpl&lt;K, V&gt;( cacheExpiryTime: Duration = Duration.ofMinutes(5), cleaningInterval: Duration = Duration.ofMinutes(5), cacheMaxSize: Int = 10, dispatcher: CoroutineDispatcher ) : CacheManager&lt;K, V&gt;(cacheExpiryTime.toMillis(), cleaningInterval.toMillis(), cacheMaxSize), CacheCleaner, CoroutineScope by CoroutineScope(dispatcher) { private val cacheActor = cacheManagerActor() private val isCacheCleanerRunning = AtomicBoolean(false) private val waitTimeForCacheCleaning = 20L private var cacheCleanerJob: Job? = null init { start() } override fun start() { if (cacheCleanerJob?.isActive == true) { return } cacheCleanerJob = launch(SupervisorJob()) { while (true) { delay(cleaningInterval) isCacheCleanerRunning.getAndSet(true) val response = CompletableDeferred&lt;Int&gt;() cacheActor.send(CacheMessage.Clear(response)) response.await() isCacheCleanerRunning.getAndSet(false) } } } override fun stop() { launch { while (isCacheCleanerRunning.get()) { delay(waitTimeForCacheCleaning) } cacheCleanerJob?.cancel() cacheCleanerJob = null } } override suspend fun get(key: K): CacheState&lt;V&gt; { val response = CompletableDeferred&lt;CacheState&lt;V&gt;&gt;() cacheActor.send(CacheMessage.Get(key, response)) return response.await() } override suspend fun put(key: K, value: V, cacheExpiryTime: Long) { cacheActor.send(CacheMessage.Put(key, value, cacheExpiryTime)) } override suspend fun remove(key: K): Boolean { val response = CompletableDeferred&lt;Boolean&gt;() cacheActor.send(CacheMessage.Remove(key, response)) return response.await() } override suspend fun entries(): List&lt;Pair&lt;K, Cache&lt;V&gt;&gt;&gt; { val response = CompletableDeferred&lt;List&lt;Pair&lt;K, Cache&lt;V&gt;&gt;&gt;&gt;() cacheActor.send(CacheMessage.Entries(response)) return response.await() } @OptIn(ObsoleteCoroutinesApi::class) private fun CoroutineScope.cacheManagerActor( ) = actor&lt;CacheMessage&lt;K, V&gt;&gt;(start = CoroutineStart.LAZY) { val cacheMap = LruCache&lt;K, Cache&lt;V&gt;&gt;(cacheMaxSize) for (msg in channel) { msg.process(cacheMap) } } private sealed interface CacheMessage&lt;K, V&gt; { fun process(cacheMap: LruCache&lt;K, Cache&lt;V&gt;&gt;) data class Put&lt;K, V&gt;(val key: K, val value: V, val expiryTime: Long) : CacheMessage&lt;K, V&gt; { override fun process(cacheMap: LruCache&lt;K, Cache&lt;V&gt;&gt;) { cacheMap.put(key, Cache(value, expiryTime)) } } data class Remove&lt;K, V&gt;(val key: K, val response: CompletableDeferred&lt;Boolean&gt;) : CacheMessage&lt;K, V&gt; { override fun process(cacheMap: LruCache&lt;K, Cache&lt;V&gt;&gt;) { response.complete(cacheMap.remove(key) != null) } } data class Clear&lt;K, V&gt;(val response: CompletableDeferred&lt;Int&gt;) : CacheMessage&lt;K, V&gt; { override fun process(cacheMap: LruCache&lt;K, Cache&lt;V&gt;&gt;) { val now = System.currentTimeMillis() var removedCount = 0 cacheMap.snapshot().forEach { (key, cache) -&gt; if (cache.isExpired(now)) { cacheMap.remove(key) removedCount++ } } response.complete(removedCount) } } data class Get&lt;K, V&gt;( val key: K, val response: CompletableDeferred&lt;CacheState&lt;V&gt;&gt; ) : CacheMessage&lt;K, V&gt; { override fun process(cacheMap: LruCache&lt;K, Cache&lt;V&gt;&gt;) { val cacheState = cacheMap[key]?.run { if (isExpired()) { CacheState.Miss } else { CacheState.Hit(value) } } ?: run { CacheState.Miss } response.complete(cacheState) } } data class Entries&lt;K, V&gt;( val response: CompletableDeferred&lt;List&lt;Pair&lt;K, Cache&lt;V&gt;&gt;&gt;&gt; ) : CacheMessage&lt;K, V&gt; { override fun process(cacheMap: LruCache&lt;K, Cache&lt;V&gt;&gt;) { response.complete(cacheMap.snapshot().map { it.key to it.value }) } } } } Actor 코루틴 스코프 내에서 Actor를 생성하였다. CacheManagerImpl 인스턴스의 생명주기(앱 실행 ~ 종료)와 동일하다. private fun CoroutineScope.cacheManagerActor( ) = actor&lt;CacheMessage&lt;K, V&gt;&gt;(start = CoroutineStart.LAZY) { } 가능한 작업 Get : 캐시를 불러온다. Put : 캐시를 저장한다. Remove : 캐시를 삭제한다. Clear : 캐시를 모두 삭제한다. Entries : 캐시를 모두 불러온다. cacheCleanerJob, 캐시 자동 정리기 캐시 매니저를 사용할 떄 수동으로 캐시 정리 코드를 만드는 수고를 덜기 위해, 캐시 자동 정리기를 구현하였다. cleaningInterval 주기마다 캐시 정리 작업을 Actor에게 요청한다. cacheCleanerJob = launch(SupervisorJob()) { while (true) { delay(cleaningInterval) isCacheCleanerRunning.getAndSet(true) val response = CompletableDeferred&lt;Int&gt;() cacheActor.send(CacheMessage.Clear(response)) response.await() isCacheCleanerRunning.getAndSet(false) } } 캐시 클리너 on/off 앱에서 캐시 클리너를 on/off 할 수 있도록 구현하였다. 앱이 닫힌 상태라면 캐시 클리너를 굳이 실행할 필요가 없기 때문에, 앱이 닫힌 상태(액티비티 onStop)가 될 때 코루틴 작업을 취소시키고, 다시 앱이 실행될 때(액티비티 onRestart) 코루틴 작업을 다시 시작한다. override fun stop() { launch { while (isCacheCleanerRunning.get()) { delay(waitTimeForCacheCleaning) } cacheCleanerJob?.cancel() cacheCleanerJob = null } } stop()을 호출하면 cacheCleanerJob을 취소시키는데, 만약 캐시 정리를 진행 중이라면 캐시 정리 작업이 끝날 때 까지 대기한다. 대기하다가 캐시 정리가 끝나면 그때 cacheCleanerJob을 취소시킨다. 캐시 정리 작업 진행여부를 확실하게 동기화 시키기 위해 AtomicBoolean을 사용해서 isCacheCleanerRunning을 만들었다. 실제 적용 대기질 정보를 가져오는 기능을 구현하면서 적용해보았다. 구조는 다음과 같다. AirQualityRepository : 대기질 정보를 가져오는 기능을 담당 RepositoryCacheManager : AirQualityRepository내 캐시 매니저의 자동 클리너 기능을 on/off 할 수 있도록 함 GlobalRepositoryCacheManager : CacheManager를 사용하는 Repository의 캐시 클리너를 일괄적으로 다룸 Activity 생명주기에 따라 ActivityViewModel을 통해 호출된다 테스트 LruCache는 android 의존성이 있기 때문에, Robolectric을 사용하여 테스트했고, 모두 통과했다. @RunWith(RobolectricTestRunner::class) @Config(manifest = Config.NONE) class CacheManagerImplTest { private lateinit var cacheManager: CacheManagerImpl&lt;String, FakeCache&gt; private val testDispatcher = UnconfinedTestDispatcher() @Test fun put_and_get() = runTest { cacheManager = CacheManagerImpl(dispatcher = testDispatcher) val fakeHitCache = FakeCache(1, \"test\") cacheManager.put(fakeHitCache.key, fakeHitCache) // 간단하게 캐시를 저장하고 불러오는 기능을 테스트 assert(cacheManager.get(fakeHitCache.key) is CacheManager.CacheState.Hit) assert(cacheManager.get(\"missKey\") is CacheManager.CacheState.Miss) } @Test fun test_lru_cache_only() = runTest { val cacheMaxSize = 3 cacheManager = CacheManagerImpl(dispatcher = testDispatcher, cacheMaxSize = cacheMaxSize) val fakeCaches = List(5) { FakeCache(it, \"test $it\").apply { cacheManager.put(key, this) } } // 추가한 목록에서 키 0, 1 은 캐시 miss // 키 2, 3, 4는 캐시 hit가 되어야 한다 val missKeys = (0..&lt;(fakeCaches.size - cacheMaxSize)).toList() val hitKeys = (fakeCaches.size - cacheMaxSize until fakeCaches.size).toList() missKeys.forEach { assert(cacheManager.get(fakeCaches[it].key) is CacheManager.CacheState.Miss) } hitKeys.forEach { assert(cacheManager.get(fakeCaches[it].key) is CacheManager.CacheState.Hit) } } @Test fun test_time_out_only() = runBlocking { val cacheExpiryTime = Duration.ofSeconds(1) cacheManager = CacheManagerImpl(dispatcher = testDispatcher, cacheExpiryTime = cacheExpiryTime) val fakeCaches = List(6) { FakeCache(it, \"test $it\") } // miss 유도 val missList = fakeCaches.subList(0, 3) // hit 유도 val hitList = fakeCaches.subList(missList.size, fakeCaches.size) missList.forEach { cacheManager.put(it.key, it) } delay(cacheExpiryTime.toMillis()) hitList.forEach { cacheManager.put(it.key, it) } missList.forEach { assert(cacheManager.get(it.key) is CacheManager.CacheState.Miss) } hitList.forEach { assert(cacheManager.get(it.key) is CacheManager.CacheState.Hit) } } @Test fun cache_cleaner_removes_expired_items() = runBlocking { val cacheExpiryTime = Duration.ofMillis(5) val cleaningInterval = Duration.ofMillis(10) val fakeCaches = List(100) { FakeCache(it, \"test $it\") } cacheManager = CacheManagerImpl(dispatcher = testDispatcher, cacheMaxSize = 100, cacheExpiryTime = cacheExpiryTime, cleaningInterval = cleaningInterval) fakeCaches.forEach { cacheManager.put(it.key, it) } // 자동으로 캐시가 정리되어 캐시맵은 비어있어야 한다. delay(cleaningInterval.toMillis() + 10) assertTrue(cacheManager.entries().isEmpty()) } @Test fun items_should_not_be_deleted_if_cache_cleaner_didnt_work() = runBlocking { val cacheExpiryTime = Duration.ofMillis(5) val cleaningInterval = Duration.ofSeconds(10) val fakeCaches = List(100) { FakeCache(it, \"test $it\") } cacheManager = CacheManagerImpl(dispatcher = testDispatcher, cacheMaxSize = 100, cacheExpiryTime = cacheExpiryTime, cleaningInterval = cleaningInterval) fakeCaches.forEach { cacheManager.put(it.key, it) } // 캐시 클리너가 동작하지 않았으므로 아이템의 개수는 유지되어야 한다 assertTrue(cacheManager.entries().size == fakeCaches.size) } } data class FakeCache(val id: Int, val value: String) { val key: String = id.toString() } 실제 테스트 결과 아래 화면은 각 지역을 선택하면 날씨 정보 화면으로 전환되는 기능을 제공한다. 테스트를 위해 캐시의 크기를 4로 설정했고, 다음 순서로 지역을 선택해나갔다. 청주시 영동군 의령군 김해시 내동 경산시 내동 청주시 의령군 다음과 같이 의도대로 정확하게 동작한다. 청주시 : Miss -&gt; 서버에서 데이터를 가져옴 영동군 : Miss -&gt; 서버에서 데이터를 가져옴 의령군 : Miss -&gt; 서버에서 데이터를 가져옴 김해시 내동 : Miss -&gt; 서버에서 데이터를 가져옴 경산시 내동 : Miss -&gt; 서버에서 데이터를 가져옴 청주시 : Miss 5번째 경산시를 선택하면서 청주시의 캐시가 삭제되었기 때문에, 다시 서버에서 데이터를 가져옴 의령군 : Hit 만약 8번째에서 다른 지역을 선택한다면, 그 때 의령군이 캐시에서 삭제된다.",
    "tags": "Kotlin Cache Coroutines Actor LruCache",
    "url": "/jekyll-theme-yat/kotlin/2023/12/10/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%BA%90%EC%8B%9C-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0.html"
  },{
    "title": "DroidKnights 2023 ‘빈혈 도메인 모델과 쓸모없는 유스케이스 그리고 비대한 뷰모델에 대해 생각해보기’내용 정리",
    "text": "이번 글은 아래의 영상으로 부터 얻은 내용을 바탕으로 작성하였습니다. 빈혈 도메인, 쓸모없는 유스케이스, 비대한 뷰모델에 대하여를 주제로 DroidKnights 2023에서 강연하신 박종혁님(카카오스타일)의 영상입니다. Video: 빈혈(anemic) 도메인 모델과 쓸모없는 유스케이스 그리고 비대한(Bloated) 뷰모델에 대해 생각해보기 개발에서 발생할 수 있는 문제점들로 빈혈 도메인 모델, 쓸모없는 유스케이스, 비대한 뷰모델 세 가지가 소개되었습니다. - 빈혈, 무기력한, 빈약한(Anemic) 도메인 모델 도메인 모델(클래스)이 데이터만 가지고 있고, 어떠한 로직이 없는 상태, AnemicDomainModel 안티 패턴 중 하나(특정 경우에는 적절할 수 있으므로 무조건 사용하지 말아야 하는 것은 아닙니다) 객체의 의미와 책임을 제대로 반영하지 못하기 때문에 객체지향적인 설계를 벗어납니다. 단순 구조체와 다를 바 없으므로, 모델을 생성하는 의미가 없다고 볼수 있습니다. data class Developer( val name: String, val age: Int, ) data class DeveloperList( val list: List&lt;Developer&gt; ) - 쓸모없는 유스케이스 유스케이스(클래스)가 단순히 레포지토리와 뷰모델을 연결만 해주는 상태, 특별한 기능이 없음 비즈니스 로직을 서버에 위임하는 아키텍처에서 주로 보입니다. 안티 패턴으로 간주되기도 하지만, 코드 일관성 및 미래의 수정에 대비하는 등의 이유로 사용되기도 합니다. interface SpeakerRepository { suspend fun getSpeakerList(): List&lt;Speaker&gt; } class LoadSpeakerListUseCase( private val speakerRepository: SpeakerRepository ) { suspend operator fun invoke() = speakerRepository.getSpeakerList() } 오직 speakerRepository.getSpeakerList()를 위해서 유스케이스가 쓰입니다. - 비대한(Bloated) 뷰모델 뷰모델이 과하게 크고 복잡한 상태 뷰모델이 너무 많은 책임과 로직을 가지고 있으면 유지보수성이 떨어집니다. class SpeakerListViewModel( private val loadSpeakerList: LoadSpeakerListUseCase ) : ViewModel() { private val speakerList // ... fun load() { viewModelScope.launch { speakerList = loadSpeaker() // ... } } fun getYoungDevelopers() = speakerList.filter { it.age &lt; 30 } // ... } 이러한 문제들을 해결하는 방법 명확한 정답은 없음, 끊임없는 고민으로 적절한 방법을 찾도록 합니다. 팀 프로젝트라면 팀원들과의 끊임없는 토의로 가이드라인을 찾아가는 것이 중요합니다. 카카오스타일 지그재그 앱 개발팀이 적용한 방법 팀원들과의 토의를 통해 다음과 같은 가이드라인으로 합의점을 찾았다고 합니다. 가이드라인 프레젠테이션 레이어에 도메인 로직을 구현하지 않는다. 단일 도메인 모델에 대한 비즈니스 로직은, 도메인 모델이 책임지도록 한다. 여러 도메인 모델에 대한 비즈니스 로직은, 유스케이스가 해결할 수 있다. 1. 프레젠테이션 레이어에 도메인 로직을 구현하지 않는다. 뷰모델은 프레젠테이션 레이어(UI 레이어)이므로, 뷰모델에는 데이터를 뷰에 표현하거나, 사용자 상호작용을 위한 로직을 구현하도록 한다. 2. 단일 도메인 모델에 대한 비즈니스 로직은, 도메인 모델이 책임지도록 한다. 도메인 모델은 필요한 로직을 직접 구현해야 한다. 빈혈 도메인 모델을 개선시키기 위해 관련 로직을 구현하는 것이다. 뷰모델에서 도메인 모델을 직접 다루는 로직은 구현해서는 안된다. 프레젠테이션 로직이 아니라면, 도메인 메서드에 구현하는 것을 우선으로 고려한다. 3. 여러 도메인 모델에 대한 비즈니스 로직은, 유스케이스가 해결할 수 있다. 도메인 로직은 아래 기준에 따라 유스케이스로 구현되어야 한다. 여러 도메인 모델이 참조되는 복잡한 비즈니스 로직 프레젠테이션 레이어에서 직접 데이터 레이어를 참조하지 않도록 하는 Wrapper 레이어 로직 간단하게 SAM interface로 구현 가능 개선 예시 위와 같은 가이드라인에 따라 아래와 같이 개선이 가능합니다. 도메인 모델에 책임을 부여 data class Developer( val name: String, val age: Int, ){ fun isYoung() = age &lt; 30 } data class DeveloperList( val list: List&lt;Developer&gt; ){ fun getYoungDevelopers() = list.filter { it.isYoung() } } 여러 도메인 모델에 대한 비즈니스 로직을 유스케이스에서 구현 class LoadSpeakerListWithCompanyNameUseCase( private val speakerRepository: SpeakerRepository ) { suspend operator fun invoke(company: Company) = speakerRepository.getSpeakerList().concatCompanyName(company) } class SpeakerListViewModel( private val loadSpeakerList: LoadSpeakerListUseCase ) : ViewModel() { private val speakerList // ... fun load() { viewModelScope.launch { speakerList = loadSpeaker() // ... } } // 도메인 모델 내에서 필터링 로직이 구현된 메서드를 호출하여 사용 fun getYoungDevelopers() = speakerList.getYoungDevelopers() // ... } 정리 빈혈 도메인 모델을 개선하기 위해서 도메인 모델에 책임을 부여할수 있다. 여러 도메인 모델에 대한 비즈니스 로직을 유스케이스에서 구현하여, 유스케이스의 책임을 확장할 수 있다. 뷰모델은 프레젠테이션 레이어이므로, 도메인 모델을 직접 다루는 로직은 구현해서는 안된다. 이러한 개선 방법이 무조건 정답이라고 볼수 없으며, 현재 프로젝트의 구조, 상황에 따라 적절한 가이드라인을 찾아가는 것이 중요합니다.",
    "tags": "Android",
    "url": "/jekyll-theme-yat/android/2023/11/27/%EB%B9%88%ED%98%88-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%AA%A8%EB%8D%B8,-%EC%93%B8%EB%AA%A8%EC%97%86%EB%8A%94-%EC%9C%A0%EC%8A%A4%EC%BC%80%EC%9D%B4%EC%8A%A4,-%EB%B9%84%EB%8C%80%ED%95%9C-%EB%B7%B0%EB%AA%A8%EB%8D%B8%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-DroidKnights-2023.html"
  },{
    "title": "About the UI layer",
    "text": "UI layer UI layer 공식문서를 정리한 내용입니다. UI : 앱의 데이터를 화면에 표시하고 사용자와 상호 작용하는 부분입니다, Data 계층으로 부터 변경되는 앱의 상태를 시각적으로 표현하는 역할 데이터가 변경될 때마다 UI는 그에 맞게 바뀌어야 합니다.(버튼 클릭, 네트워크 응답 등) 보통 Data 계층에서 받은 데이터를 화면에 바로 보여주기에는 적절하지 않습니다. 예를 들어, 일부 데이터만 보여줘야 하거나, 여러 개의 데이터들을 합쳐서 보여줘야 하는 경우가 있습니다. UI 계층은 이러한 데이터를 UI로 표시할 수 있게 가공하여, 화면에 보여주는 역할을 중요한 과정을 담당합니다. Android 앱 아키텍처에서 UI 계층의 역할 참고 : 이 페이지에 제시된 권장 사항 및 모범 사례는 다양한 앱에 적용하여 앱의 확장성, 품질 및 견고성을 개선하고 테스트하기 쉽게 만들 수 있습니다. 하지만 이를 가이드라인으로 간주하고 필요에 따라 요구 사항에 맞게 조정해야 합니다. Video : Architecture: The UI layer 기본 사례 뉴스 기사를 가져오는 앱을 생각해봅시다. 기사 목록을 표시하는 기사 목록 화면이 있고, 로그인한 사용자는 기사를 즐겨찾기에 추가할 수 있습니다. 기사가 너무 많을 수 있으니 사용자는 카테고리별로 기사를 볼수도 있습니다. 사용자가 할 수 있는 기능 기사 목록을 볼 수 있습니다. 카테고리별로 기사를 볼 수 있습니다. 로그인하여 기사를 즐겨찾기에 추가할 수 있습니다. 자격이 된다면 일부 프리미엄 기능을 사용할 수 있습니다.(유료 결제) 샘플 뉴스 앱 다음 내용에서는 이 앱을 예시로 하여 단방향 데이터 흐름 원칙을 설명하고, 이러한 원칙이 UI 계층에 대하여 앱 아키텍처의 관점에서 도움이 되는 문제를 설명합니다. UI 계층 아키텍처 Android에서 UI는 데이터를 보여주는 액티비티 또는 프래그먼트와 같은 UI 요소를 의미합니다. 이를 구현하기 위해 쓰이는 뷰와 컴포즈 같은 API와는 무관합니다. Data 계층의 역할은 앱 데이터를 보유/관리하고 접근하는 권한을 제공하는 것이므로, UI 계층은 다음 과정을 따라야 합니다. 앱 데이터를 사용하고 UI가 쉽게 표시할 수 있도록 데이터를 가공합니다. UI가 표시가능한 데이터를 사용하고, 사용자에게 표시할 수 있도록 UI 요소로 가공합니다. UI 요소에서 사용자의 입력을 받고, 필요에 따라 UI 데이터에 관련 효과를 적용합니다. 필요한 만큼 1~3 과정을 반복합니다. 지금부터는 UI 계층에서 이런 과정을 수행하도록 구현하는 방법을 설명하겠습니다. 구체적으로 다음과 같은 내용을 다루겠습니다. UI 상태 정의: 앱의 화면과 사용자간의 상호작용을 어떻게 데이터로 표현할지 정의하는 방법. 단방향 데이터 흐름(UDF): UI 상태를 만들고 관리하는 데 사용되는 방식. 데이터가 한 방향으로만 흐르며, 이로 인해 데이터 관리가 더 명확해집니다. 관찰 가능한 데이터 타입으로 UI 상태를 나타내기: UDF 원칙을 따라 UI 상태를 어떻게 다른 부분들이 관찰하고 반응할 수 있는 형태로 만드는지 설명합니다. 관찰 가능한 UI 상태를 사용하는 UI 구현: 실제 UI가 이러한 상태를 어떻게 받아들이고 화면에 표시하는지 보여줍니다. 이 중에서 가장 중요한 것은 UI 상태의 정의 입니다. UI 상태(State)의 정의 UI State: 앱이 사용자에게 보여주는 데이터 UI와 UI State는 정의가 다릅니다. UI: 사용자가 화면으로 보고 있는 것 UI 상태: 앱이 사용자에게 보여주는 것 동전을 예로 들어보겠습니다. UI: UI 상태의 시각적 표현(눈으로 보이는 동전의 모습), 앞면이나 뒷면이 보이는 것 UI 상태: 동전의 양면 중 어느 쪽이 위로 향하고 있는지 ‘앞면’ 또는 ‘뒷면’과 같이 현재 상태를 나타내는 정보 UI 상태가 바뀌면 그에 따라서 UI도 바뀝니다. UI는 화면 상의 UI 요소와 UI 상태가 결합한 것입니다 뉴스 앱의 요구 사항을 따라 UI를 만들기 위해서 NewsUiState 라는 클래스에 데이터를 담을 수 있습니다. data class NewsUiState( val isSignedIn: Boolean = false, val isPremium: Boolean = false, val newsItems: List&lt;NewsItemUiState&gt; = listOf(), val userMessages: List&lt;Message&gt; = listOf() ) data class NewsItemUiState( val title: String, val body: String, val bookmarked: Boolean = false, ... ) 불변성(Immutability) 위 예제 코드의 UI 상태는 불변합니다. 불변 객체의 장점은 앱의 상태가 특정 시점에서 어떤 상태인지 보장해준다는 것입니다. 이로 인해 UI가 하나의 역할(상태를 읽고 적절하게 UI 요소를 업데이트)만 집중할 수 있게 됩니다. 그래서 UI자체가 데이터의 유일한 출처가 아니라면 개발자는 UI 상태를 직접 변경하면 안됩니다. 직접 변경한다면 같은 데이터에 대해 여러개의 출처가 생기면서 데이터의 일관성이 깨지며 버그가 발생할 수 있습니다. 예를 들어, NewsUiState내 bookmarked의 값이 Activity에서 바뀐다면 bookmarked는 실제 북마크 상태를 두고 Data 계층과 충돌하게 됩니다. 왜냐하면 북마크 상태를 실제로 변경하는 작업은 Data 계층에서 이루어져야 하기 때문입니다. 이런 문제를 방지하기 위해서 불변 클래스를 사용하는 것이 좋습니다. 데이터를 소유하거나 직접적으로 변경하는 객체는 스스로 노출시키는 데이터를 업데이트 할 책임이 있습니다. 이름 짓기(Naming conventions) 현재 문서에서는 UI 상태 클래스의 이름을 화면의 기능 또는 데이터가 표현되는 화면의 일부를 기반으로 하여 짓습니다. functionality + UiState.kt NewsUiState: 뉴스를 표시하는 화면의 상태 NewsItemUiState: 기사 목록내 각 아이템의 상태 단방향 데이터 흐름(UDF, Unidirectional Data Flow)으로 UI 상태를 관리하기 위에서 UI 상태가 UI를 표시하기 위해 필요한 세부 사항의 불변 스냅샷이라고 설명했습니다. 그러나 보통 데이터는 동적으로 바뀌고 따라서 상태도 계속 변경됩니다. 사용자가 앱을 쓰기 때문입니다. 이러한 상호작용은 중개자(이벤트에 적용할 로직을 정의하고 UI 상태를 만들기 위한 데이터를 가공하는 작업을 수행)의 도움을 받아야 합니다. 이런 상호작용과 로직은 UI 자체에 포함될 수는 있지만, UI가 이를 처리하는 것은 좋지 않습니다. 왜냐하면 UI는 UI 상태를 표시하는 것에만 집중해야 하기 때문입니다. 데이터 소유, 생산, 변환과 같은 역할까지 해야 한다면 UI는 너무 많은 역할을 하게 됩니다. 이는 코드를 이해하기 어렵게 만들고, 테스트하기 어렵게 만들며, 유지보수하기 어렵게 만듭니다. UI는 오직 UI 상태를 가지고 화면에 보여주는 역할만을 하여야 합니다. 상태 홀더(State holders) 상태 홀더 : UI 상태를 만들고 관련 로직을 가지고 있는 클래스 상태 홀더 클래스의 규모는 관리하는 UI 요소(App bar와 같은 작은 요소에서 부터 화면 전체 또는 화면 이동 대상)에 따라 다양합니다. Data 계층에 접근하는 화면 수준의 UI 상태를 관리하는 경우에는 ViewModel을 사용하는 것을 권장합니다. ViewModel은 구성이 변경되더라도 데이터를 유지할 수 있습니다.ViewModel은 앱의 이벤트를 처리하는 로직을 정의하고 처리 결과를 상태로 만들어 내는데 사용합니다. UI와 상태 생성간의 상호 의존성을 만드는 방법은 다양합니다. 그러나 UI와 ViewModel간의 상호작용은 크게 이벤트의 입력과 그에 따른 상태를 출력하는 것으로 이해할 수 있는데, 다이어그램으로 표현하면 다음과 같습니다. 앱 아키텍처에서 UDF의 흐름 상태가 아래로 흐르고 이벤트가 위로 흐르는 이러한 패턴이 바로 단방향 데이터 흐름(UDF)입니다. UDF를 통해 앱 아키텍처는 다음과 같이 변화합니다. ViewModel은 UI가 사용할 상태를 보유하고 노출시킵니다. UI 상태는 ViewModel에서 변환되는 앱 데이터입니다. UI는 ViewModel에 사용자 이벤트를 알립니다. ViewModel은 사용자 이벤트를 처리하고 상태를 업데이트합니다. 업데이트된 상태는 UI에 전달됩니다. 위 과정은 상태를 바꾸는 이벤트에 의해서 반복됩니다. 네비게이션 목적지나 화면에 대해서 ViewModel은 Repository 또는 UseCase에 접근하여 데이터를 가져오고, 이를 UI 상태로 변환합니다. 이때 상태를 변화시킬수 있는 이벤트(사용자 입력, 데이터 변경 등)의 영향을 고려하여 처리합니다. 현재 문서의 예제에서 기사 목록의 경우는 제목, 내용, 출처, 기자, 작성 날짜, 북마크 여부를 포함하고 있고 목록 내 각 아이템에 대한 UI는 다음과 같습니다. 기사 하나를 표현하는 아이템의 UI 기사를 북마크에 추가하는 사용자는 상태를 변화시키는 이벤트입니다. ViewModel은 상태를 생산하는 역할을 맡고 있으므로 UI 상태 내의 모든 필드를 다루고 UI가 표시되기 위해 필요한 이벤트를 처리하여야 합니다. UDF에서 이벤트와 데이터가 처리되는 흐름 아래에서는 상태 변경을 일으키는 이벤트와 이를 UDF를 사용하여 처리하는 방법을 자세히 설명합니다. 로직의 유형 기사를 북마크하는 것은 비즈니스 로직의 예입니다. (이 부분에 대한 자세한 내용은 Data 계층페이지를 살펴보세요) 정의해야하는 주요 로직의 유형은 다음과 같습니다. Business logic: 앱의 데이터에 대한 요구 사항을 구현하는 로직 예시: 기사를 북마크하는 것 보통 도메인 또는 Data 계층에서 구현합니다. UI 계층에서는 구현하지 않도록 합니다. UI behavior logic, UI logic: 화면에 상태 변경을 보여주는 로직 예시: Resource를 사용하여 표시할 문자열을 가져오는 것, 사용자가 버튼을 눌렀을때 다른 화면으로 이동하는 것, toast 또는 snackbar를 표시하는 것 Context와 같은 UI 유형과 관련된 로직의 경우, ViewModel이 아닌 UI에서 구현해야 합니다. 해당 로직이 너무 복잡해진다면 State holder와 같이 간단한 클래스를 만들어서 위임하면 됩니다. Jetpack Compose State guide에서 State holder와 UI 생성과 관련된 내용을 살펴보실수 있습니다. UDF를 사용해야 하는 이유 UDF로 상태를 생성하는 흐름을 모델링할 수 있습니다. 또한 상태 변화가 일어나는 곳/변환되는 곳/최종적으로 소비되는 곳 세 가지를 명확하게 분리할 수 있습니다. 이를 통해 UI는 상태를 관찰하면서 데이터를 표시하고 변경 사항을 ViewModel에 전달하여 사용자의 의도를 전달할 수 있습니다. UDF 사용의 이점 데이터 일관성 유지: UI에 대한 데이터는 하나의 출처만 존재하게 됩니다. 테스트 용이성: 상태 소스가 분리되어 있어 UI와 독립적으로 테스트 가능합니다. 유지보수성: 상태의 변화는 잘 정의된 패턴을 따르며, 변화는 사용자의 이벤트와 이벤트에 의해 얻은 데이터 소스의 결과입니다. UI 상태 노출 UI 상태를 정의하고 해당 상태의 생성을 관리하는 방법을 결정한 후, 다음 단계는 생성된 상태를 UI에 표시하는 것입니다. UDF를 사용하여 상태 생성을 관리하기 때문에 생성된 상태를 스트림(흐름)으로 간주할 수 있습니다. 다시 말해, 시간이 지남에 따라 여러 버전의 상태가 생성될 것입니다. 따라서 UI 상태를 LiveData 또는 StateFlow와 같은 관찰 가능한 데이터 홀더에 노출해야 합니다. 그 이유는 ViewModel에서 직접 데이터를 수동으로 가져올 필요 없이 UI가 상태의 모든 변경 사항에 반응할 수 있도록 하기 위해서입니다. 또한 이러한 유형은 항상 최신의 UI 상태가 캐시되어 있어 구성 변경 후 상태를 빠르게 복원하는 데 유용합니다. class NewsViewModel(...) : ViewModel() { // Compose val uiState: NewsUiState = … // Views val uiState: StateFlow&lt;NewsUiState&gt; = … } 참고: Compose에서는 Compose 전용인 관찰 가능한 State APIs를 사용할 수 있습니다. mutableStateOf, snapshotFlow등이 있으며 UI 상태를 노출하는데에 쓰입니다. 물론 LiveData와 StateFlow도 추가적인 확장 함수를 통해 쓸수 있습니다. UI에 노출되는 데이터가 단순하다면, 데이터를 UI 상태로 감싸는 것이 좋습니다. 왜냐하면 UI 상태는 State holder의 방출과 관련된 화면 또는 UI 요소 사이의 관계를 전달하기 때문입니다. 또한 UI 요소가 더 복잡해진다면 UI 요소를 표시하는데 필요한 추가 정보를 수용하기 위해 UI 상태 정의에 추가하는게 더 낫습니다. UiState 스트림을 만들려면 ViewModel의 가변 스트림을 불변 스트림으로 노출시키면 됩니다. class NewsViewModel(...) : ViewModel() { // Compose var uiState by mutableStateOf(NewsUiState()) private set // Views private val _uiState = MutableStateFlow(NewsUiState()) val uiState: StateFlow&lt;NewsUiState&gt; = _uiState.asStateFlow() } ViewModel은 내부적으로 상태를 바꾸는 메서드를 노출시켜서 UI가 사용할 업데이트를 만들어 낼 수 있습니다. 예를 들어, 다음과 같은 비동기 작업을 가정해봅시다. viewModelScope에서 동작하는 코루틴이 있고 코루틴이 완료될 때 상태가 업데이트 되는 로직입니다. class NewsViewModel( private val repository: NewsRepository, ... ) : ViewModel() { // Compose var uiState by mutableStateOf(NewsUiState()) private set // Views private val _uiState = MutableStateFlow(NewsUiState()) val uiState: StateFlow&lt;NewsUiState&gt; = _uiState.asStateFlow() private var fetchJob: Job? = null fun fetchArticles(category: String) { fetchJob?.cancel() fetchJob = viewModelScope.launch { try { val newsItems = repository.newsItemsForCategory(category) // Compose uiState = uiState.copy(newsItems = newsItems) // Views _uiState.update { it.copy(newsItems = newsItems) } } catch (ioe: IOException) { // 오류를 처리하여 UI에 알립니다 // Compose val messages = getMessagesFromThrowable(ioe) uiState = uiState.copy(userMessages = messages) // Views _uiState.update { val messages = getMessagesFromThrowable(ioe) it.copy(userMessages = messages) } } } } } NewsViewModel은 특정 카테고리의 기사들을 가져와서 UI가 반응할 수 있도록 UI 상태에 성공 또는 실패의 결과를 반영하는 작업을 합니다. 위의 예제에서 ViewModel의 메서드로 상태가 변경되는 것은 가장 널리쓰이는 UDF의 구현 방식입니다. 추가 고려 사항 UI 상태를 노출할 때에는 다음의 내용들을 고려해야 합니다. UI 상태 객체는 서로 연관된 상태들을 다루어야 합니다. 이를 지키면 상태의 불일치가 줄어들고 코드를 이해하기 더 수월해집니다. 만약 뉴스 기사 목록과 북마크한 개수를 서로 다른 스트림에 노출시킨다면, 한 스트림이 제대로 업데이트 되지 않는 오류가 발생할 수 있습니다. 이를 방지하기 위해서 단일 스트림에 두 개를 노출시켜야 합니다. 또한 일부 비즈니스 로직에는 여러 개의 소스들의 조합이 필요할 수도 있습니다. 예를 들어, 사용자가 로그인한 상태이면서 프리미엄 뉴스 구독자인 경우에만 북마크 버튼을 보여줘야 하는 경우가 있습니다. 이때 다음과 같이 UI 상태를 정의할 수 있습니다. data class NewsUiState( val isSignedIn: Boolean = false, val isPremium: Boolean = false, val newsItems: List&lt;NewsItemUiState&gt; = listOf() ) val NewsUiState.canBookmarkNews: Boolean get() = isSignedIn &amp;&amp; isPremium 북마크 버튼의 표시 여부를 두 개의 속성을 조합하여 결정하고 있습니다. 비즈니스 로직이 복잡해짐에 따라 모든 속성을 즉시 사용할 수 있는 단일 UiState클래스가 점점 더 중요해지고 있습니다. UI 상태: 단일 스트림 또는 복수 스트림 UI 상태를 단일과 복수 스트림 중 무엇으로 노출시켜야 할지를 결정할 때 중요한 것은 앞서 방출되는 항목 간의 관계를 살피는 것 입니다. 단일 스트림 노출의 장점은 편의성과 데이터 일관성에 입니다. 상태를 소비하는 측에서는 항상 최신의 정보를 사용할 수 있습니다. 하지만 분리된 상태 스트림을 쓰는게 더 적절한 경우도 있습니다. 서로 관련이 없는 데이터 유형일 때 UI를 표시하기 위해 필요한 일부 상태는 서로 관련이 없을 수도 있습니다. 이러한 상태 중 하나가 다른 것보다 훨씬 빈번하게 업데이트 된다면 스트림을 분리하는게 더 낫습니다. 서로 다른 상태를 묶는 비용이 이점보다 더 클 수 있기 때문입니다. UI 상태 차이 UiState 객체에 필드가 많을수록 필드 중 하나가 업데이트될 때 스트림이 생성될 가능성이 높아집니다. 뷰는 연속적인 방출이 같거나 다른지의 여부를 파악할 수 없기 때문에, 모든 방출은 뷰의 업데이트를 발생시킵니다. 이러한 부분은 Flow 또는 LiveData의 distinctUntilChanged같은 메서드를 사용하여 완화시킬 수 있습니다. UI 상태를 사용(소비) UI에서 UiState 객체의 스트림을 사용하려면, 사용중인 관찰 가능한 데이터 유형에 대해 종단(terminal) 연산자를 사용하면 됩니다. 예를 들어, LiveData에는 observe()메서드를, Flow에는 collect()메서드, 또는 그 변형을 사용합니다. UI에서 관찰 가능한 Data holders를 사용할 때는, UI의 생명 주기를 따라야 합니다. 뷰가 화면에 보이지 않을 때는 UI가 UI 상태를 관찰하지 않아야 하기 때문입니다. 이와 관련된 내용은 A safer way to collect flows from Android UIs 페이지를 추천드립니다. LiveData를 쓰는 경우에는, LifecyclerOwner는 암시적으로 생명 주기 문제를 처리하며, Flow를 쓴다면 적절한 Coroutine scope와 repeatOnLifecycle API를 사용하여 생명 주기에 따른 로직을 처리해야 합니다. // Views class NewsActivity : AppCompatActivity() { private val viewModel: NewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { ... lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { // UI 요소를 업데이트 } } } } } // Compose @Composable fun LatestNewsScreen( viewModel: NewsViewModel = viewModel() ) { // viewModel.uiState에 따라 UI 요소를 업데이트 } 예제의 StateFlow 객체는 활성화된 수집기가 없을 때 작업을 중단하지 않지만, flow로 작업할 때 그것들이 어떻게 구현되는지 모를 수 있습니다. 생명 주기를 인식하는 flow를 사용하면 나중에 ViewModel flow에 이러한 변경을 하더라도 하위 수집 코드를 다시 검토할 필요 없이 조정할 수 있습니다. 작업 중임을 나타내기 UiState에서 로딩중이라는 것을 나타내는 가장 쉬운 방법은 boolean 필드를 사용하는 것입니다. data class NewsUiState( val isFetchingArticles: Boolean = false, ... ) 이 flag의 값은 UI에서 progress bar의 표시 여부를 나타냅니다. ```kotlin // Views class NewsActivity : AppCompatActivity() { private val viewModel: NewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { ... lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { // progressBar의 가시성을 isFetchingArticles의 상태와 결합 viewModel.uiState .map { it.isFetchingArticles } .distinctUntilChanged() .collect { progressBar.isVisible = it } } } } } // Compose @Composable fun LatestNewsScreen( modifier: Modifier = Modifier, viewModel: NewsViewModel = viewModel() ) { Box(modifier.fillMaxSize()) { if (viewModel.uiState.isFetchingArticles) { CircularProgressIndicator(Modifier.align(Alignment.Center)) } // 리스트같은 다른 UI 요소를 업데이트 } } 화면에서 오류 발생을 나타내기 화면에서 오류 발생을 표시하는 것과 로딩 중임을 표시하는 것 모두 유사합니다. 왜냐하면 둘다 boolean 필드로 간단히 표현될 수 있기 때문입니다. 그러나 오류는 때에 따라서 사용자에게 관련한 메시지를 보여주거나 실패한 작업을 재시도하는 작업을 포함하기도 합니다. 따라서 진행 중인 작업을 로딩 중이거나 로딩 중이지 않은 두 가지로 분류하는 것처럼 오류 상태는 오류와 관련된 데이터를 포함하는 데이터 클래스로 모델링될 필요가 있습니다. 예를 들어, 기사 목록을 가져오고 있을 때 progress bar를 보여주는 작업을 생각해보세요. 만약 작업이 실패한다면 사용자에게 오류 메시지를 보여줘야 할 수 있습니다. data class Message(val id: Long, val message: String) data class NewsUiState( val userMessages: List&lt;Message&gt; = listOf(), ... ) 오류 메시지는 snackbar와 같은 UI 요소로 사용자에게 보여져야 합니다. 왜냐하면 이는 UI 요소가 어떻게 생성/소비되는지와 연관되어있기 때문입니다. 더 자세한 내용은 UI events 페이지를 참고하세요. 스레드와 동시성 ViewModel에서 수행되는 작업은 메인 스레드에서 호출되어도 안전해야합니다. 왜냐하면 Data/Domain 계층은 다른 스레드로 작업을 넘기는 것에 대한 책임이 있기 때문입니다. 만약 ViewModel에서 오래 걸리는 작업을 수행한다면, 백그라운드 스레드에서 수행하는게 좋습니다. 코루틴은 동시 작업을 관리하는 데 좋은 방법입니다. 그리고 Jetpack 아키텍처 컴포넌트는 이를 위한 기능을 지원하고 있습니다. Kotlin coroutines on Android 페이지를 살펴보세요. 네비게이션 앱 네비게이션의 변경은 종종 이벤트와 같은 방출로 인해 일어납니다. 예를 들어, SignInViewModel에서 로그인 작업을 수행한 후에 UI 상태 클래스는 isSignedIn의 값을 true로 설정되어야 합니다. 이러한 트리거는 UI 상태를 사용(소비)에서 다룬 것과 같이 소비되어야 하지만, 소비 로직의 구현은 Navigation component에 의존해야 합니다. 페이징 Paging library는 PagingData라는 타입으로 UI에서 소비됩니다. PagingData는 시간이 지남에 따라 바뀔 수 있는 데이터를 보여주고 표현한다는 점에서 불변 타입이 아니므로 불변 UI 상태로 표시되어선 안됩니다. 대신 독립적인 스트림으로 ViewModel에서 노출시켜야 합니다. 자세한 내용은 Android Paging을 참고해보세요. 애니메이션 자연스럽고 부드러운 최상위 수준의 네비게이션 전환을 제공하려면, 애니메이션이 시작되기 전에 데이터를 불러고기 위해 잠시동안 화면을 대기 상태로 만들어야 합니다. Android View 프레임워크는 postponeEnteTransition(), startPostponedEnterTransition()으로 프래그먼트 목적지 간 전환에 지연을 시키는 기능을 제공합니다. 이런 API는 두 번째 화면(네트워크에서 가져온 사진)으로 전환하는 애니메이션을 시작하기 전에 화면의 UI 요소가 준비되었는지 확인하는 방법을 제공합니다. 자세한 내용은 Android Motion sample을 참고해보세요. 샘플 [Sunflower with Compose](https://github.com/android/sunflower/tree/main) [Now in Android App](https://github.com/android/nowinandroid/tree/main) [Architecture starter template(single module)](https://github.com/android/architecture-templates/tree/base) ![](https://raw.github.com/android/sunflower//main//screenshots/SunflowerM3Screenshots.png) ![](https://raw.github.com/android/nowinandroid//main//docs/images/screenshots.png) ![](https://github.com/android/architecture-templates/raw/main/screenshots.png) [Architecture](https://github.com/android/architecture-samples/tree/main) [Architecture starter template(multi module)](https://github.com/android/architecture-templates/tree/multimodule) [Jetcaster sample](https://github.com/android/compose-samples/tree/main/Jetcaster) ![](https://raw.github.com/android/architecture-samples//main//screenshots/screenshots.png) ![](https://github.com/android/architecture-templates/raw/main/screenshots.png) ![](https://raw.github.com/android/compose-samples//main/Jetcaster//docs/screenshots.png)",
    "tags": "Android",
    "url": "/jekyll-theme-yat/android/2023/11/14/UI-Layer%EB%9E%80(Android-%EA%B3%B5%EC%8B%9D-%EB%AC%B8%EC%84%9C-%EC%A0%95%EB%8F%85)-copy.html"
  },{
    "title": "코루틴에서의 예외 처리 정리",
    "text": "코루틴에서 예외가 발생하면, 부모 코루틴으로 예외가 전파되고, 부모와 형제 코루틴이 모두 취소된다. fun main(): Unit = runBlocking { // A launch { // A-A launch { throw Error(\"A-A의 예외\") } // A-B launch { println(\"A-B\") } // A-C launch { println(\"A-C\") } } // B launch { println(\"B\") } } B Exception in thread \"main\" java.lang.Error: A-A의 예외 A-A에서 발생한 예외가 전파되어, 모든 코루틴[A-B, A-C, B]이 취소된다. 다음 그림은 위 코드내 코루틴의 계층도를 나타낸다. 작업하나가 실패하더라도 다른 작업에 영향을 주지 않아야 하는 경우, 이를 처리하는 방법을 알아보자. 코루틴에서 발생한 오류를 전파시키지 않도록 하는 방법 1. SupervisorJob SupervisorJob를 사용하는 코루틴은 다른 코루틴에게 영향을 주지 않는다. SupervisorJob : 자식 코루틴들은 서로 독립적으로 동작하여, 해당 코루틴에서 발생한 예외가 부모와 형제 코루틴에게 영향을 주지 않는다. Job : 부모와 자식 코루틴은 서로 연결되어 있어, 예외가 전파된다. suspend fun main(): Unit = coroutineScope { // A launch { println(\"A\") } // B launch { println(\"B\") } // C val scope = CoroutineScope(SupervisorJob()) scope.launch { try { println(\"C\") throw Exception(\"C의 예외\") } catch (e: Exception) { println(e) } } } A B C java.lang.Exception: C의 예외 C에서 예외가 발생하였으나, 다른 코루틴에게 영향을 주지 않았다. 사용 방법 // 1. Scope를 만들 때 SupervisorJob을 컨텍스트로 포함시키기 val scope = CoroutineScope(SupervisorJob()) scope.launch { // ... } // 2. 기존 Scope에 SupervisorJob을 추가하기 launch(SupervisorJob()) { // ... } 부적절한 사용 : withContext(SupervisorJob()) withContext(SupervisorJob())으로 사용하면, 의도와 달리 예외가 전파된다. 왜냐하면 withContext은 새로운 코루틴을 만드는 것이 아니라 기존 코루틴의 context를 임시적으로 변경하는 것이기 때문이다. 다시 말해, SupervisorJob으로 지정하여도 코루틴의 동작 방식을 바꿀 수 없기 떄문에 SupervisorJob의 특성이 적용되지 않는다. suspend fun analyzeData(dataList: List&lt;Data&gt;) = withContext(SupervisorJob()) { dataList.forEach { data -&gt; launch { val result = analyze(data) notifyResult(result) } } } launch내에서 예외가 발생하면 다른 코루틴이 모두 취소된다. 2. supervisorScope supervisorScope내의 코루틴은 서로 독립적으로 동작하여, 예외가 발생해도 다른 코루틴에게 영향을 주지 않는다. Scope내에서 생성되는 코루틴은 SupervisorJob으로 동작한다. suspend fun main(): Unit = coroutineScope { // A launch { println(\"A\") } // B launch { println(\"B\") } // C supervisorScope { launch { try { println(\"C\") throw Exception(\"C의 예외\") } catch (e: Exception) { println(e) } } } } A B C java.lang.Exception: C의 예외 3. Exception클래스가 CancellationException를 상속받도록 하기 예시 : 값이 홀수일 때 예외를 발생시키는 코드 예외가 발생하면 부모, 자식 코루틴이 종료된다. 짝수일 때는 정상적으로 동작해야 하는데 취소되기 때문에 개선이 필요하다. data class OddException(val value: Int) : Exception() suspend fun main(): Unit = coroutineScope { repeat(100) { launch { if (it % 2 == 1) { throw OddException(it) } println(it) } } } 0 2 4 Exception in thread \"main\" OddException(value=1) OddException를 CancellationException를 상속받도록 하면, 예외는 부모로 전파되지 않고, 예외가 발생한 코루틴만 취소된다. data class OddException(val value: Int) : CancellationException() 0 2 4 6 8 10 12 14 ... 98 코루틴에서 발생한 예외를 감지하는 방법 1. try-catch, 일반적인 방법 가장 기초적인 방법으로 try-catch를 사용하여 예외를 감지할 수 있다. 코루틴 빌더 내에서 try-catch를 사용하면 된다. launch { try { throw Exception(\"예외 발생\") } catch (e: Exception) { // try 내에서 발생한 예외에 대한 대응 로직을 작성 } } 그러나 try문 내에 자식 코루틴이 있는 경우, 자식 코루틴에서 발생한 예외는 try-catch로 감지할 수 없다. try-catch로 예외를 감지할 수 없는 경우 try문 내에 자식 코루틴이 있을 때 다음 코드와 같이 내부적으로 또 다른 코루틴이 있다면 그 코루틴에서 발생하는 예외는 catch로 감지할 수 없다. 즉, 계층 구조가 있는 코루틴에서는 try-catch로 예외를 감지할 수 없다는 것이다. try { launch { // 자식 코루틴 A throw Exception(\"코루틴 A 예외\") } // 새로운 Scope에서 코루틴 B를 실행 val scope = CoroutineScope(Dispatchers.Default) scope.launch { throw Exception(\"코루틴 B 예외\") } } catch (e: Exception) { // 호출되지 않음 // 자식 코루틴의 예외를 감지할 수 없다. } 이러한 경우에는 루트 코루틴에서 CoroutineExceptionHandler를 사용하면 자식 코루틴의 예외를 감지할 수 있다. 2. CoroutineExceptionHandler Scope내의 코루틴에서 발생한 예외를 감지할 수 있다, 보통 launch 빌더와 함께 쓰인다 supervisorScope { val exceptionHandler = CoroutineExceptionHandler { _, throwable -&gt; println(\"예외 감지: $throwable\") } println(\"ROOT\") launch(exceptionHandler) { println(\"job : ROOT-A\") launch { println(\"job : ROOT-A-B\") launch { println(\"job : ROOT-A-B-C\") supervisorScope { launch { throw Exception(\"ROOT-A-B-C의 예외\") } } } } } launch(exceptionHandler) { println(\"job : ROOT-B\") throw Exception(\"ROOT-B의 예외\") } } ROOT job : ROOT-A job : ROOT-B 예외 감지: java.lang.Exception: ROOT-B의 예외 job : ROOT-A-B job : ROOT-A-B-C 예외 감지: java.lang.Exception: ROOT-A-B-C의 예외 주의 사항 예외에 대해 복구한 후 후속 작업을 해야한다면 부적합 예외가 CoroutineExceptionHandler에서 감지되었을 때, 해당 코루틴은 이미 실패 상태로 완료된 것이다. 따라서 CoroutineExceptionHandler에서 예외를 복구하고 다음 작업을 진행하는 것은 불가능하다. try-catch를 사용하여 따로 처리 예외에 대해서 대응하고 작업을 이어나가려면, 해당 코드를 try-catch 로 감싸서 예외를 직접 처리해야 한다. async에서는 try-catch를 사용해야 한다. 다음과 같이 async에서 발생한 예외는 CoroutineExceptionHandler에서 감지되지 않는다. suspend fun main(): Unit = supervisorScope { val exceptionHandler = CoroutineExceptionHandler { _, throwable -&gt; println(\"Handler 예외 감지: $throwable\") } launch(exceptionHandler) { throw AssertionError() } val deferred = async(exceptionHandler) { throw ArithmeticException() } try { deferred.await() } catch (e: Exception) { println(\"catch 예외 감지: $e\") } } Handler 예외 감지: java.lang.AssertionError catch 예외 감지: java.lang.ArithmeticException 핸들러에서 감지되지 않는 이유는 async의 동작 방식의 특징 때문이다. async는 결과를 Deferred 객체에 담아서 반환하는데, async에서 발생하는 예외는 이 Deferred객체에 저장되고, await() 호출 시에 예외에 대해서 처리가 가능하다. 따라서, async에서 발생한 예외는 CoroutineExceptionHandler에 도달하지 않으므로, await()를 호출하는 쪽에서 try-catch로 예외를 처리해야 한다. delay(), yield() 등의 취소가능한 중단 함수는 취소될 때 CancellationException을 발생시킨다. 다음은 50MS 동안 대기한 후에 코루틴 B를 취소시키는 코드이다. suspend fun main(): Unit = coroutineScope { val exceptionHandler = CoroutineExceptionHandler { _, throwable -&gt; println(\"예외 감지: $throwable\") } // A launch { println(\"A 시작, 200ms 대기\") delay(200) println(\"200ms 대기 종료, A 완료\") } // B val b = launch { try { delay(100) } catch (e: Exception) { println(\"catch에서 예외 처리: $e\") } println(\"B 완료\") } delay(50) b.cancel() } A 시작, 200ms 대기 catch에서 예외 처리: kotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled; job=StandaloneCoroutine{Cancelling}@17036f98 B 완료 200ms 대기 종료, A 완료 위 코드에는 다음과 같은 문제가 있다. B가 취소되었음에도 불구하고 B 완료가 출력됨 SupervisorJob, supervisorScope에서 처리되지 않음에도 B의 예외가 전파되지 않고 A가 정상적으로 동작함 문제의 원인 및 해결 방법 코루틴이 취소된다면 동작중인 delay는 CancellationException을 발생시키는데, catch에서 이 예외를 잡아서 대응을 하였기 때문에 A 완료가 출력된 것이며, 이 예외가 catch에서 잡히면서 부모로 전파되지 않아 A가 정상적으로 동작한 것이다. 이는 다음과 같이 정확하게 잡아야하는 예외를 감지하도록 하면 해결된다. try { delay(100) } catch (e: IllegalArgumentException) { println(\"catch에서 예외 처리: $e\") } println(\"B 완료\") A 시작, 200ms 대기 200ms 대기 종료, A 완료 CancellationException를 잡지 않고 정상적으로 코루틴 취소 예외가 부모 코루틴으로 전파되어 A가 취소되며 B 완료가 출력되지 않는다. CoroutineExceptionHandler에서 CancellationException는 감지하지 않는다. CancellationException은 코루틴이 취소 될 때 작동하는 메커니즘의 일부이므로, 오류가 아니기 때문에 굳이 이 예외를 감지하여 처리할 필요가 없다. 3. runCatching runCatching을 사용하여 좀 더 간결하게 예외를 감지할 수 있다. 예외가 발생하면 onFailure 함수에서 처리하며, onSuccess 함수에서는 정상적인 동작을 처리한다. suspend fun main(): Unit = supervisorScope { println(\"ROOT\") launch { println(\"job : ROOT-A\") launch { println(\"job : ROOT-A-B\") launch { println(\"job : ROOT-A-B-C\") runCatching { throw Exception(\"ROOT-A-B-C의 예외\") }.onFailure { throwable -&gt; println(\"예외 감지: $throwable\") } } delay(100L) println(\"job : ROOT-A-B\") } } launch { println(\"job : ROOT-B\") runCatching { throw Exception(\"ROOT-B의 예외\") }.onFailure { throwable -&gt; println(\"예외 감지: $throwable\") } } } ROOT job : ROOT-A job : ROOT-A-B-C job : ROOT-B 예외 감지: java.lang.Exception: ROOT-B의 예외 예외 감지: java.lang.Exception: ROOT-A-B-C의 예외 job : ROOT-A-B 이 함수는 try-catch와 유사한 역할을 하기 때문에, 자식 코루틴에서 발생하는 예외에 대해서는 감지하지 못한다. 다음 코드에서는 ROOT-A-B-C에서 발생한 예외를 runCatching으로 감지할 수 없으며, 예외가 전파되어 모든 코루틴이 종료된다.(CoroutineExceptionHandler를 사용하면 된다) runCatching { launch { throw Exception(\"ROOT-A-B-C의 예외\") } }.onFailure { throwable -&gt; println(\"예외 감지: $throwable\") } 사용 방법 runCatching { throw Exception(\"ROOT-A-B-C의 예외\") }.onFailure { throwable -&gt; println(\"예외 감지: $throwable\") }.onSuccess { println(\"정상 동작\") } // 함수 형태 inline fun &lt;T, R&gt; T.runCatching(block: T.() -&gt; R): Result&lt;R&gt; inline fun &lt;R&gt; runCatching(block: () -&gt; R): Result&lt;R&gt; 위와 같이 onFailure와 onSuccess를 사용하면 되고, 반환 타입은 Result&lt;R&gt;이다. 정리 기본적으로 코루틴에서 발생하는 예외는 부모 코루틴으로 전파되며, 이는 연결된 모든 자식 코루틴들에 영향을 미친다. 따라서, 각 코루틴에서 예외를 어떻게 처리할지를 명확히 결정하는 것이 중요하다. try-catch 는 특정 코루틴 내에서 발생한 예외를 직접 처리하는 가장 기본적인 방법이다. 반면 SupervisorJob과 supervisorScope는 코루틴 간 예외의 독립적 처리를 가능하게 하여, 하나의 코루틴 실패가 다른 코루틴에 영향을 미치지 않도록 한다. CoroutineExceptionHandler는 감지되지 못한 예외를 감지할 수 있는데, 주로 로깅, 에러 메시지 표시, 프로그램의 재시작 등에 사용된다. 하지만, CoroutineExceptionHandler에서 예외를 복구하거나 코루틴의 실행을 계속하는 것은 불가능하다. 코루틴의 취소 메커니즘은 CancellationException을 통해 이루어되며, 코루틴의 취소는 프로그램의 정상적인 흐름의 일부로, 별도의 처리를 요구하지 않는다.",
    "tags": "Kotlin Coroutines",
    "url": "/jekyll-theme-yat/kotlin/coroutines/2023/11/12/%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%97%90%EC%84%9C%EC%9D%98-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC.html"
  },{
    "title": "Android DataBinding, ViewBinding이 파일을 생성하는 방법",
    "text": "Android DataBinding에 대한 이해가 있다는 전제하에 작성하였습니다. 주요 클래스 클래스명 설명 AndroidDataBinding 데이터바인딩의 핵심 클래스, 데이터 바인딩 작업을 총괄한다 LayoutFileParser XML을 파싱하여 ResourceBundle 목록을 만든다 LayoutXmlProcessor 레이아웃 XML파일을 읽고 처리한다. 내부적으로 사용할 XML파일도 만든다 BaseDataBinder 바인딩 클래스 파일을 생성/삭제한다 ResourceBundle 레이아웃 파일 구문 분석 결과를 보관한다. 레이아웃 XML파일 내의 코드를 분석한다 DataBindingGenBaseClassesTask 데이터바인딩 클래스 생성을 위한 작업을 처리한다.(데이터바인딩 라이브러리가 아닌 Android Gradle Plugin에 포함되어있다) LayoutInfoInput XML 파일에 대한 바인딩 정보를 담고 있다 LayoutFileBundle XML 파일에서 데이터 바인딩 관련 정보를 파싱한 결과를 가진다 DataBinding 파일의 생성 과정 1. 프로젝트 빌드 시, 바인딩 처리할 파일 등에 대한 정보를 AndroidDataBinding에 전달한다. 전달 인자 appId : 애플리케이션 패키지 명 resInput : 리소스(layout, drawable 등)를 담고 있는 폴더 resOutput : 처리한 리소스를 담을 폴더 layoutInfoOutput : 레이아웃 파일에 대한 데이터 바인딩 정보를 가지고 있는 XML파일을 저장할 폴더 2. AndroidDataBinding의 processResources() 호출 LayoutXmlProcessor를 초기화한다. 3. LayoutXmlProcessor의 processResources() 호출 4. LayoutXmlProcessor의 processAllInputFiles() 호출 입력으로 받은 폴더의 모든 파일을 하나씩 확인한다. layout 폴더 내에 있는 파일에 대해서 processLayoutFile()을 호출한다. processLayoutFile()에서는 processSingleFile()을 호출한다. 5. processSingleFile() LayoutFileParser의 parseXml()을 호출하여 XML을 파싱한다. parseOriginalXml()를 호출하여 실제로 파싱을 한다. RootView 분석 data태그 내의 import, variable, class 정보를 분석하고, LayoutFileBundle에 저장한다. 배치된 View에 대한 정보(id, tag, class)와 바인딩 정보(@{}과 같은 표현식)를 분석하여 LayoutFileBundle에 저장한다. 분석한 데이터 바인딩 정보는 추가적으로 XML파일을 만들어 저장해둔다. 원본 파일이 activity_main.xml 이라면 activity_main-layout.xml이름으로 생성한다. 원본 레이아웃 파일 코드 출처 : https://viblo.asia/p/understanding-data-bindings-generated-code-and-how-does-android-data-binding-compiler-work-Ljy5Vd1yZra R.layout.activity_main &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;data&gt; &lt;variable name=\"viewModel\" type=\"com.example.main.MainViewModel\" /&gt; &lt;/data&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"@{viewModel.text}\" /&gt; &lt;/layout&gt; 바인딩 정보만을 담고있는 추가로 생성된 파일 activity_main-layout.xml &lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt; &lt;Layout layout=\"activity_main\" absoluteFilePath=\"/home/framgia/Projects/harpa-crista/harpacrista/android/app/src/main/res/layout/activity_main.xml\" directory=\"layout\" isMerge=\"false\" modulePackage=\"com.harpacrista\"&gt; &lt;Variables declared=\"true\" name=\"viewModel\" type=\"com.example.main.MainViewModel\"&gt; &lt;location endLine=\"8\" endOffset=\"51\" startLine=\"6\" startOffset=\"8\" /&gt; &lt;/Variables&gt; &lt;Imports name=\"View\" type=\"android.view.View\"&gt; &lt;location endLine=\"10\" endOffset=\"42\" startLine=\"10\" startOffset=\"8\" /&gt; &lt;/Imports&gt; &lt;Targets&gt; &lt;Target tag=\"layout/activity_main_0\" view=\"TextView\"&gt; &lt;Expressions&gt; &lt;Expression attribute=\"android:text\" text=\" viewModel.text \"&gt; &lt;Location endLine=\"16\" endOffset=\"41\" startLine=\"16\" startOffset=\"8\" /&gt; &lt;TwoWay&gt;false&lt;/TwoWay&gt; &lt;ValueLocation endLine=\"16\" endOffset=\"39\" startLine=\"16\" startOffset=\"24\" /&gt; &lt;/Expression&gt; &lt;/Expressions&gt; &lt;location endLine=\"16\" endOffset=\"44\" startLine=\"14\" startOffset=\"4\" /&gt; &lt;/Target&gt; &lt;/Targets&gt; &lt;/Layout&gt; android:text=\"@{ viewModel.text }\"은 아래와 같이 변환된다. &lt;Expression attribute=\"android:text\" text=\" viewModel.text \"&gt; &lt;Location endLine=\"23\" endOffset=\"45\" startLine=\"23\" startOffset=\"12\" /&gt; &lt;TwoWay&gt;false&lt;/TwoWay&gt; &lt;ValueLocation endLine=\"23\" endOffset=\"43\" startLine=\"23\" startOffset=\"28\" /&gt; &lt;/Expression&gt; &lt;Expression attribute=\"android:text\" text=\"viewModel.text\"&gt; : android:text=\"@{ viewModel.text }\" &lt;location endLine=\"16\" endOffset=\"44\" startLine=\"14\" startOffset=\"4\" /&gt; : android:text=\"@{viewModel.text}\"가 위치한 라인과 오프셋 &lt;TwoWay&gt;false&lt;/TwoWay&gt; : 양방향 바인딩의 여부 &lt;ValueLocation endLine=\"16\" endOffset=\"39\" startLine=\"16\" startOffset=\"24\" /&gt; : viewModel.text가 위치한 라인과 오프셋 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;TextView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:tag=\"layout/activity_main_0\" /&gt; 6. writeLayoutInfoFiles() writeXmlFile()을 호출하여 바인딩 정보를 담은 XML파일을 생성 이때 불필요한 파일(제거된 레이아웃에 대한 바인딩 파일)이 있다면 제거한다. 7. java, kotlin 파일 생성 BaseDataBinder generateAll()을 호출하여 생성 ActivityMainBinding.java파일을 생성한다. &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"@{viewModel.text}\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:visibility=\"@{viewModel.isVisible ? View.VISIBLE : View.INVISIBLE}\" /&gt; &lt;/LinearLayout&gt; public class ActivityMainBinding extends android.databinding.ViewDataBinding { private static final android.databinding.ViewDataBinding.IncludedLayouts sIncludes; private static final android.util.SparseIntArray sViewsWithIds; static { sIncludes = null; sViewsWithIds = null; } private final android.widget.LinearLayout mboundView0; private final android.widget.TextView mboundView1; private final android.widget.Button mboundView2; ... } View 변수명은 XML에 id가 지정되어있으면 id를 사용하고, 지정되어있지 않다면 mBoundView + index로 만들어진다. View의 Binding 클래스 파일이 자동으로 생성되는 과정 Gradle Sync buildFeatures의 viewBinding, dataBinding 둘 중 최소 하나가 활성화되어있는지 확인 활성화되어 있다면 아래의 메서드를 호출하고, Gradle Task에 DataBindingGenBaseClassesTask를 추가한다. XML파일이 추가/수정/삭제 될때마다 DataBindingGenBaseClassesTask가 동작한다. BaseDataBinder를 사용하여 바인딩 파일을 처리한다. TaskManager : Android Gradle Plugin의 클래스, Gradle 작업을 관리한다. DataBindingGenBaseClassesTask : 데이터바인딩 처리를 위한 작업 두 클래스는 Jetpack DataBinding 라이브러리에 종속되어있지 않다. in TaskManager.kt protected fun createDataBindingTasksIfNecessary(creationConfig: ComponentCreationConfig) { val dataBindingEnabled = creationConfig.buildFeatures.dataBinding val viewBindingEnabled = creationConfig.buildFeatures.viewBinding if (!dataBindingEnabled &amp;&amp; !viewBindingEnabled) { return } taskFactory.register( DataBindingMergeDependencyArtifactsTask.CreationAction(creationConfig)) DataBindingBuilder.setDebugLogEnabled(logger.isDebugEnabled) taskFactory.register(DataBindingGenBaseClassesTask.CreationAction(creationConfig)) ... in DataBindingGenBaseClassesTask.kt @TaskAction fun writeBaseClasses(inputChanges: InputChanges) { // TODO extend NewIncrementalTask when moved to new API so that we can remove the manual call to recordTaskAction recordTaskAction(analyticsService.get()) { // TODO figure out why worker execution makes the task flake. // Some files cannot be accessed even though they show up when directory listing is // invoked. // b/69652332 val args = buildInputArgs(inputChanges) CodeGenerator( args, sourceOutFolder.get().asFile, Logger.getLogger(DataBindingGenBaseClassesTask::class.java), encodeErrors, getRPackageProvider()).run() } } }",
    "tags": "Android",
    "url": "/jekyll-theme-yat/android/2023/11/04/Android-DataBinding,-ViewBinding%EC%9D%B4-%ED%8C%8C%EC%9D%BC%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95.html"
  },{
    "title": "Android Dalvik과 ART에 대해서",
    "text": "Dalvik 이란? Android에서 Java 애플리케이션을 구동하는 가상머신(Virtual Machine)이다. Java의 라이센스 문제(오라클, 이 문제로 10년간 소송)와 최적화 등의 이유로 인해, 구글은 JVM을 사용하지 않고, 자체적으로 DVM(Dalvik Virtual Machine)을 개발하였다. 특징 JIT(Just-In-Time) Android 2.2(2011)이전에는 JIT 컴파일이 없어, 앱이 실행 될 때마다 컴파일을 하여 메모리 효율이 나빴고 앱 구동 성능이 좋지 않았다. Android 2.2(2011)부터 JIT 컴파일이 도입되었다. 자주 사용되는 코드는 캐싱하여 재 사용하기 때문에 전반적으로 성능이 향상되었다. .dex(Dalvik Executable, Dalvik Bytecode) 앱 빌드 시 .class 파일을 .dex 파일로 변환한다. .dex 파일을 Dalvik에서 실행한다. CMS(Concurrent Mark Sweep) Garbage Collector 사용 Java Garbage Collection GC동작 시 스레드가 멈추는 시간이 다른 알고리즘들 보다 짧다. 메모리 효율 향상 레지스터 기반으로 스택 기반인 JVM보다 메모리를 적게 사용한다. JVM은 연산 수행 시 피연산자를 스택을 사용하여 처리한다. 반면 DVM은 레지스터를 사용하여 처리한다. 레지스터 머신의 속도가 스택 머신보다 32% 더 빠르다는 연구 결과도 있다. Virtual Machine Showdown: Stack Versus Registers Android 기기의 보급이 늘어나기 시작했던 2010년 즈음에는 메모리의 용량이 요즘 나오는 고성능 기기의 1/10 수준(512MB 이하)으로 매우 작았다. 이러한 상황에서 메모리 사용을 최적화하고자, Dalvik은 JIT(Just-In-Time) 컴파일 형식을 사용하여 앱이 실행되고 있을 때 필요한 부분만 컴파일한다. 필요한 것만 처리하기 때문에 메모리 절약이 가능한 것이다. 그러나, 실행 중에 컴파일을 하기 때문에 앱의 성능에 영향을 미칠 수 밖에 없는 단점이 있었다. 시간이 흐르면서 애플리케이션의 규모가 커져감과 동시에 하드웨어의 성능이 향상되어갔고 Dalvik을 대체할 ART가 도입되었다. ART(Android Runtime)의 도입 Android 4.4에서 처음 도입된 Runtime Dalvik과 달리 AOT 방식을 사용한다. 앱을 설치할 때 바이트 코드인 .dex파일들을 기계어로 컴파일하여 .oat파일들로 저장한 후 앱 실행 시 .oat파일을 불러와서 실행한다. 특징 AOT(Ahead-Of-Time) .oat(Optimized Ahead-of-Time) ART에서 사용하는 파일 dex2oat도구를 통해 .dex를 .odex로 변환한 후 다시 .oat로 변환한다. .odex(Optimized Dalvik Executable) Dalvik에서 사용하는 파일 dexopt도구를 통해 .dex 파일을 .odex 파일로 변환한다. 앱 실행 시 이 파일을 기계어로 변환한다. Garbage Collector에서 상당한 개선 Dalvik보다 처리가 2배 빠르다. Dalvik과 ART의 비교 간단히 각각의 장단점을 정리하면 다음과 같다.   Dalvik ART 앱 설치 속도 빠름 느림 앱 실행 속도 느림 빠름 앱 설치 용량 적음 많음 서로 장단점이 반대이다. 그래서 시간이 지나면서 런타임에 여러 번 변경이 있었다. Android에서 ART의 적용 역사 Android 4.4(2013)에서 처음 도입(기본 설정은 Dalvik), 호환성 문제 Android 5.0(2014)에서 기본 Runtime으로 적용 Android 7.0(2016)부터 JIT와 AOT를 혼합하여 사용한다 Android 7.0(2016)에서 다시 JIT를 사용하는 Profile Guided Compilation 방식이 도입되었다. Profile Guided Compilation JIT와 AOT를 혼합하여 컴파일을 수행 앱 설치 시 AOT컴파일 없이 수행되도록 바뀌었고 이로인해 설치 속도가 빨라졌다. 앱이 실행되면 JIT 컴파일을 수행하여 자주 사용되는 코드는 캐싱된다. 기기가 유휴 상태 또는 충전 중일 때 자주 사용되는 코드룰 AOT컴파일 한다. 이후 앱이 실행될 때 AOT컴파일된 코드를 사용한다.",
    "tags": "Dalvik ART Android",
    "url": "/jekyll-theme-yat/dalvik/art/android/2023/10/15/Android-Dalvik%EA%B3%BC-Art%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C.html"
  },{
    "title": "JVM (Java Virtual Machine)이란?",
    "text": "가상 머신, JVM이란? Java코드를 구동하기 위한 프로그램(컴퓨터)이다. C와 같은 Native 언어는 컴파일러를 통해 기계어로 변환되어 실행된다. 하지만 Java는 컴파일러를 통해 바로 기계어로 변환되는 것이 아니라, JVM이라는 가상머신을 통해 실행된다. JVM은 Java Virtual Machine의 약자로, Java를 실행하기 위한 가상의 컴퓨터라고 생각하면 된다. JVM은 OS에 종속적이지 않고, Java가 설치되어 있다면 어디서든지 실행할 수 있다. Native언어로 개발하면, CPU아키텍처나 운영체제 마다 다른 기계어를 사용하기 때문에, 특정 운영체제나 CPU에 종속적이며, 개발자는 각각의 CPU나 운영체제에 대해서 프로그램을 만들어야 한다. 가상 머신에서 동작하는 언어는 가상 머신만 있으면 어디서든지 실행할 수 있으며, 개발자는 CPU나 운영 체제 각각에 대해서 프로그램을 만들 필요가 없다. JVM의 동작 과정 .java 파일을 javac(컴파일러)를 통해 Bytecode인 .class 파일로 변환한다. .class 파일을 JVM의 클래스 로더에게 전달한다. 클래스 로더는 .class 파일을 JVM의 메모리에 로드한다. 로드된 .class 파일은 Execution engine을 통해 해석된다. 해석된 Bytecode는 Runtime Data Area에 배치되어 실질적인 수행이 이루어진다. .java -&gt; .class -&gt; JVM -&gt; 기계어 -&gt; 실행 JVM의 구성 Class Loader .class 파일을 불러와서 JVM 메모리에 탑재하는 역할을 수행한다. Execution Engine 내부에 Interpreter, JIT Compiler, Garbage Collector를 포함 class를 실행한다. class loader에 의해 JVM 내의 Runtime Data Area에 배치된 바이트 코드를 실행한다. Runtime Data Area 프로그램을 동작하기 위해 OS에서 할당받은 메모리 공간 Heap, Stack, Method, Native Method Stack, PC Register, Native Method Stack 등으로 구성 Heap 실행 시 동적으로 할당된 객체를 저장하는 공간 Stack 지역변수, 매개변수, 메서드, 임시 데이터 등을 저장하는 공간 메서드 호출 시 내부에 공간이 생성되며, 메서드가 종료되면 그 공간은 사라진다. Method 클래스, 인터페이스, 메서드, 필드, static 변수 등의 바이트 코드를 보관하는 공간 PC Register Thread가 시작될 때 생성되며, Thread가 어떤 부분을 어떤 명령으로 실행해야 할지에 대한 기록을 하는 공간 Native Method Stack 실제로 구동되는 기계어로 작성된 프로그램을 실행하기 위한 공간 JNI(Java native interface)를 통해 호출되는 C코드를 처리하는 공간 JIT Compiler, AOT Compiler JIT(Just-In-Time, Dynamic translation) 런타임에 Bytecode를 기계어로 컴파일 장점 프로그램 설치 속도가 빠르다 단점 실행 속도가 느릴 수도 있다 런타임 시 계속 컴파일을 하기 때문에 CPU사용량이 AOT 대비 높다 프로그램 실행 시 많은 양의 코드를 한번에 메모리에 탑재하기 때문에 메모리 사용량이 높다 종류 JVM(Java), CLR(C#), CPython(Python) AOT(Ahead-Of-Time) 런타임 이전(설치 시)에 Bytecode를 미리 기계어로 컴파일 장점 더 빠른 실행 시간을 가져온다. 단점 JIT사용 대비 프로그램 설치 속도가 느려진다 두 방식은 각각 장단점이 있으며, 최신 Android OS의 경우 JIT와 AOT를 혼합한 방식을 사용한다. 다음 포스팅에서는 JIT와 AOT를 중점으로 Android의 Runtime에 대해 알아보겠다.",
    "tags": "JVM",
    "url": "/jekyll-theme-yat/jvm/2023/10/08/JVM(Java-Virtual-Machine)%EC%9D%B4%EB%9E%80.html"
  },{
    "title": "Garbage collector에 대해서 알아보자",
    "text": "Garbage collector(GC)란 C, C++과 같이 GC가 없는 언어에서는 동적으로 할당한 메모리를 모두 개발자가 직접 관리해야 한다. // int array를 동적 할당 int *arr = new int[5]; for(int i = 0; i &lt; 5; ++i) { arr[i] = i; } // 해제 delete[] arr; 위와 같은 방식으로 할당시켜주는데, 사용 후 해제를 하지 않는다면 메모리 누수가 발생하게 되며 지속적으로 이러한 상황이 누적될 경우 프로그램에 치명적으로 작용하게 된다. Java/Kotlin(Jvm), C#(.Net)과 같은 고 수준 언어에서는 GC가 메모리 관리를 대신 해주기 때문에 상대적으로 편리하다. GC의 구조 GC는 크게 3가지 영역으로 나뉘어져 있다. 메모리 Heap영역에서 Young generation, Old generation으로 나뉘어진다. Young generation Eden : 새로운 객체가 생성될 때 할당되는 영역 Survivor 0, 1 : Eden에서 GC가 발생하면 살아남은 객체가 이곳으로 이동한다. Minor GC가 발생. Old generation : Young generation에서 살아남은 객체가 특정 조건을 넘어서면 이곳으로 이동한다.(Promotion) Major GC가 발생. 용어 Minor GC : Young generation에서 발생하는 GC Major(Full) GC : Old generation에서 발생하는 GC Reacheable : 객체가 참조되고 있는 상태, 다른 영역으로 이동하게 된다. Unreacheable : 객체가 참조되고 있지 않은 상태, 회수 대상 Age bit : 객체가 Young generation에서 살아남은 횟수를 기록한다.(보통 정수로 표현) GC Root : GC가 동작할 때 참조를 따라가며 참조 상태를 확인하는 시작점이 되는 객체들이다. GC Root로부터 참조되고 있는 객체들은 살아남고, 그렇지 않은 객체들은 회수된다. 동작 방식 Mark and Sweep 이라는 알고리즘으로 동작한다. Young(Eden, Survivor), Old에서 어떤 영역의 용량이 가득차게 된다면 GC는 해당 영역의 객체들을 검사한다. GC Root로부터 참조되고 있는 객체를 따라가며 참조 상태를 확인한다. 여전히 참조되고 있는(유효한, Reachable) 객체는 살아남고, 그렇지 않은(Unreacheable) 객체는 회수된다. 이동할 때 Age bit를 1씩 증가시킨다. 이때, Reacheable 객체가 존재하는 영역이 바뀐다. Eden에 있다면 Survivor 영역으로 이동.(두 영역 중 하나로 이동) Survivor 0/1 에 있다면 Survivor 1/0으로 이동. Age bit가 특정 조건을 넘어서면 Old 영역으로 이동. 동작 시에 Survivor 두 영역 중 하나는 반드시 비어있는 상태이다. GC가 동작할 때에는 GC가 동작하는 스레드를 제외한 나머지 모든 스레드가 일시 정지된다. 이를 Stop the world라고 한다. 만약 스레드가 정지되지 않는다면 GC가 동작하는 동안에도 객체가 생성되어 GC가 제대로 동작하지 않을 수 있는 등 여러 문제가 발생할 수 있다. Unreachable 상태가 되는 경우 할당된 객체가 연결된 변수가 없을 때 객체가 생성된 메서드가 종료될 때(Stack에서 pop) 객체와 연결된 변수가 사라짐. 변수에 null이 할당될 때 변수에 새로운 객체가 할당될 때 Unreachable은 아니나 회수가 되는 경우 객체의 참조 유형이 일반적인 유형이 아닌 경우 WeakReference, SoftReference의 참조 유형을 사용하는 경우 객체의 참조 유형 Strong Reference : 일반적인 참조 유형 흔히 객체를 생성할 때 사용되는 방식이다. val obj = Object() Weak Reference GC가 발생하면 무조건 회수되는 참조 유형이다. WeakReference를 사용하면 GC가 발생하면 무조건 회수되기 때문에 메모리 누수를 방지할 수 있다. val weakRef = WeakReference(Object()) // null 또는 not null, GC가 동작한 경우에는 null이 obj에 반환된다. val obj = weakRef.get() Soft Reference GC가 발생하면 회수되지만, 메모리가 부족할 때에만 회수되는 참조 유형이다. WeakReference와 다르게 무조건 회수되지 않는다. 메모리가 부족할 때에만 회수되기 때문에 메모리 누수를 방지할 수 있다. val softRef = SoftReference(Object()) // null 또는 not null, 메모리가 부족한 상황인 경우라면 null이 obj에 반환될 수 있다. val obj = softRef.get() Weak Reference로 할당된 객체와 연결된 하위 객체는 모두 Weak로 참조되기 떄문에, 상위 Weak Reference가 회수되면 모두 따라서 회수가 된다. Stop the world GC가 너무 자주 동작하는 것도, 적게 동작하는 것도 적합하지 않다. 적절한 빈도로 동작하는 것이 중요하다. GC가 동작할 때에는, 다른 모든 스레드가 멈추기 때문에, GC 동작이 잦다면, 그 만큼 프로그램이 멈추는 시간이 늘어나게 되므로 성능에 치명적인 영향을 미친다. GC의 종류(Jvm 기준) 현재 기본 GC는 JDK 8까지는 Parallel GC, JDK 9부터는 G1 GC가 사용된다. Serial GC GC가 동작할 때, GC를 담당하는 스레드가 하나이다. GC가 동작하는 동안에는 다른 모든 스레드가 멈춘다. Parallel GC 멀티 스레드로 Young generation GC를 처리, Old generation GC는 단일 Thread로 처리한다. Parallel Old GC Old generation GC도 멀티 스레드로 처리한다. G1(Garbage First) GC Heap을 Region이라는 영역으로 나눈다. Eden, Survivor, Old를 여러 개의 Region으로 나누고, 아래 2개의 새로운 영역이 추가되었다. Humongous : Region크기의 절반을 초과하는 큰 객체를 저장하는 영역 Available, Unused : 아직 사용되지 않은 영역 Mark and Sweep에 추가로 Compaction이라는 단계가 추가되었다. Compaction : Mark and Sweep 동작으로 인해 객체가 회수된 영역을 비워둔 채로 두지 않고, 다른 영역의 객체를 이동시켜서 메모리 조각모음을 하여 메모리를 효율적으로 사용할 수 있도록 한다. 이외에도 Epsilon, ZGC, Shenandoah GC 등 수 많은 GC알고리즘이 존재한다. 그러나 Stop the world를 완전히 피할 수 있는 GC는 아직 존재하지 않는다. GC설정 튜닝 JVM을 사용하는 프로그램에 대해서 GC설정을 직접 수정할 수 있다. 간단하게 Heap의 크기를 설정하는 방법이 있다. Android studio의 경우, Android/Android Studio/bin 디렉토리 내에 studio64.vmoptions 파일을 수정하면 된다. 다른 IDE도 마찬가지로 이러한 파일을 수정하면 된다. -Xms7g -Xmx7g vmoptions파일을 열면 위와 같은 설정이 있다. Xms는 JVM 시작 시 Heap의 크기, Xmx는 Heap의 최대 크기를 의미한다. 본인 PC의 메모리 용량에 맞게 적절히 값을 수정하면 되고, 크게 할 수록 GC의 동작 빈도가 줄어들기 때문에 어느 정도 성능 향상을 기대할 수 있다. 보통 Xms와 Xmx의 크기를 같게 설정한다. 왜냐하면 Heap의 크기가 동적으로 변하는 것을 방지하기 위해서이다. 만약 Xms와 Xmx의 크기가 다르다면, Heap의 크기가 동적으로 변하게 되는데, 이는 GC의 동작 빈도가 높아져 성능이 저하될 수 있다. 아래와 같이 추가적인 설정이 가능하다. 적절한 값을 찾는 과정은 많은 테스트를 통해 찾아야 한다. -XX:NewRatio : Young, Old generation의 비율 -XX:SurvivorRatio : Eden, Survivor의 비율 -XX:MaxTenuringThreshold : Age bit의 임계값, 이 값을 넘어서면 Old generation으로 이동, 기본 값은 15(Jvm), Do Not Set -XX:MaxTenuringThreshold to a Value Greater Than 15 -XX:ParallelGCThreads : Parallel GC의 스레드 개수",
    "tags": "GarbageCollector",
    "url": "/jekyll-theme-yat/garbagecollector/2023/09/17/Garbage-collector%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C.html"
  },{
    "title": "Android Compose와 View컴포넌트 비교",
    "text": "Android Compose와 View컴포넌트 비교 XML만으로 개발하다가, Compose를 처음 접하게 되면 처음 보는 수 많은 컴포넌트들을 만나게 된다. 기존 View에 있던 것들과는 다른 이름을 가지고 있어서 어떤 컴포넌트가 어떤 역할을 하는지 학습에 시간이 다소 걸린다. 이번 글에서는 기존 View와 비교하여 Compose의 컴포넌트들을 살펴보고자 한다. Compose의 컴포넌트 목록 Box Column Row LazyColumn LazyRow Text Image TextField Card Scaffold 등등 View의 컴포넌트 목록 FrameLayout LinearLayout RelativeLayout ConstraintLayout RecyclerView TextView ImageView EditText CardView ScrollView CoordinatorLayout 등등 Column, Box, Row, Scaffold는 특히 View에는 같은 이름을 가진 클래스가 없기 때문에 처음에는 어떤 역할을 하는지 파악하기 어려울 수도 있다. Compose와 View의 컴포넌트들을 같은 역할을 하는 것끼리 모으면 다음과 같다. Box: FrameLayout Column, Row: LinearLayout LazyColumn, LazyRow: RecyclerView Text: TextView Image: ImageView TextField: EditText Card: CardView Scaffold: CoordinatorLayout ConstraintLayout은 같은 이름으로 Compose에서도 사용이 가능하다. androidx.constraintlayout:constraintlayout-compose 라이브러리를 추가하면 된다. 다른 Composable들 간의 상대적인 관계를 이용해 레이아웃을 구성하는 방식 역시 그대로 동일하다. View를 Compose에서는 Composable이라고 부른다. Box와 FrameLayout Box와 FrameLayout은 같은 기능을 한다. FrameLayout에 layout_width, layout_height가 MATCH_PARENT인 TextView를 배치한 것과 같은 코드이다. Box( modifier = Modifier .fillMaxSize() ) { Text(\"Box\") } Text와 TextView Text는 TextView와 같은 기능을 한다. 간단하게 “text”를 출력하는 코드이다. Text(\"Text\") Image와 ImageView Image는 ImageView와 같은 기능을 한다. ic_launcher_background Drawable을 그리는 코드이다. Image( painter = painterResource(id = R.drawable.ic_launcher_background), contentDescription = \"Image\" ) TextField와 EditText TextField는 EditText와 같은 기능을 한다. onValueChange를 사용하여 입력된 값을 저장하며, 기본값은 “text”로 설정한다. TextField( value = \"text\", onValueChange = { text = it }, label = { Text(\"TextField\") } ) ScrollView와 Modifier ScrollView는 Compose에서 사용하려면 좀 다른 방법인 Modifier를 사용하여 구현한다. 먼저 Modifier를 간단히 알아보자. View에서는 다음과 같이 레이아웃 속성을 정의한다. &lt;ScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;/ScrollView&gt; Compose에서는 다음과 같이 Modifier를 사용하여 레이아웃 속성을 정의한다. Box( modifier = Modifier .fillMaxSize() .scrollable( state = rememberScrollState(), orientation = Orientation.Vertical ) ) { } LayoutParams, Padding, Width, Height 등의 속성은 Modifier를 사용하여 정의한다. 레이아웃 속성 뿐만 아니라 다양한 속성을 정의하는 데에 쓰인다. ScrollView를 Modifier.scrollable를 사용해서 구현할 수 있다. View의 OnClickListener와 Compose의 Modifier.clickable onClickListener의 경우는 Modifier.clickable을 사용하여 정의한다. Box( modifier = Modifier .fillMaxSize() .clickable { } ) { } RecyclerView와 LazyList RecyclerView와 같은 기능은 Compose에서 LazyList인 LazyColumn과 LazyRow를 사용하여 구현한다. LazyColumn은 세로 스크롤 리스트, LazyRow는 가로 스크롤 리스트를 구현할 때 사용한다. LazyList의 기본 동작 원리는 RecyclerView와 유사하게 화면에 보여지고 있는 영역에 대해서만 Item을 그리는 방식을 사용한다. Column, Row 뿐만 아니라 Grid도 제공한다. RecyclerView의 LayoutManager와 대응되는 Compose의 LazyList는 다음과 같다. LayoutManager Composable LinearLayoutManager LazyColumn, LazyRow GridLayoutManager LazyVerticalGrid, LazyHorizontalGrid StaggeredGridLayoutManager LazyVerticalStaggeredGrid , LazyHorizontalStaggeredGrid 아래는 Text를 100개 만들어서 세로 스크롤 리스트를 구현하는 코드이다. LazyColumn { items(100) { Text(\"Item #$it\") } } LazyColumn을 LazyRow로 바꾸면 가로 스크롤 리스트가 된다.",
    "tags": "Android",
    "url": "/jekyll-theme-yat/android/2023/09/10/Android-Compose%EC%99%80-View%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B9%84%EA%B5%90.html"
  },{
    "title": "Kotlin 1.9, 2.0 미리보기",
    "text": "Kotlin 1.9 변경점 until 연산자에 대한 특수 구문 도입 1.8 이하에서는 아래와 같이 until연산자를 사용하여, 0부터 9까지의 범위를 표현할 수 있습니다. for (i in 0 until 10) { ... } 1.9 부터는 ..&lt; 연산자로 동일한 기능을 수행할 수 있습니다. for (i in 0 ..&lt; 10) { ... } Jetbrains 설명에 따르면, Kotlin의 범위 구문이 구체적이지 않다는 의견을 받아왔고, 이를 해결하기 위해 ..&lt; 연산자를 도입하였다고 합니다. UX연구 결과에 따르면, ..&lt;가 until에 비해 20~30% 정도 개발자의 실수를 줄이는 효과가 있다고 합니다. data object 도입 class에 대하여 toString(). equals(), hashCode()를 자동으로 처리하여 주는 data class와 달리, object는 이러한 기능을 제공하지 않습니다. 하지만, 1.9 부터는 data object를 도입하여 data class와 처럼 3가지의 함수를 자동 처리하여 줍니다. sealed interface ReadResult data class Number(val number: Int) : ReadResult data class Text(val text: String) : ReadResult data object EndOfFile : ReadResult fun main() { println(Number(7)) // Number(number=7) println(EndOfFile) // EndOfFile } Enum.values()를 대체하기 위해 Enum.entries 도입 기존 Enum.values()의 문제점 values()를 사용하면 모든 enum 항목을 Array로 만들어 반환합니다. 이때 항상 새로운 Array의 instance를 할당하기 때문에 메모리 성능 문제가 일으킵니다. Array를 반환하기 때문에, 임의적으로 외부에서 Array의 값을 변경할 수 있는 문제도 있습니다. 참고 (https://mail.openjdk.org/pipermail/compiler-dev/2018-July/012242.html) (https://dzone.com/articles/memory-hogging-enumvalues-method) 위의 문제점을 개선한 entries가 도입되었습니다. Array가 아닌 List&lt;E&gt;를 상속한 타입인 EnumEntries를 반환합니다. 함수가 아닌 속성으로, 미리 할당되어 있기 때문에 메모리 문제가 개선됩니다. enum class Color(val colorName: String, val rgb: String) { RED(\"Red\", \"#FF0000\"), ORANGE(\"Orange\", \"#FF7F00\"), YELLOW(\"Yellow\", \"#FFFF00\") } fun findByRgb(rgb: String): Color? = Color.entries.find { it.rgb == rgb } value class에서 보조 생성자 선언 가능 1.8 까지는 value class에서 보조 생성자를 선언할 수 없었으나, 1.9 부터는 가능해졌습니다. @JvmInline value class Person(private val fullName: String) { // 1.4.30 부터 도입 init { check(fullName.isNotBlank()) { \"Full name shouldn't be empty\" } } // 1.9 부터 도입 constructor(name: String, lastName: String) : this(\"$name $lastName\") { check(lastName.isNotBlank()) { \"Last name shouldn't be empty\" } } } fun main() { val name1 = Person(\"Kotlin\", \"Mascot\") val name2 = Person(\"Kodee\") name1.greet() // Hello, Kotlin Mascot println(name2.length) // 5 } 버전 2 미리보기 버전이 1.9 이후 바로 2.0으로 넘어갑니다. K2 컴파일러 안정화 2022년 6월에 1.7 버전에서 알파 버전으로 공개되었던 새로운 Kotlin 컴파일러(K2)가 2.0 버전에서 안정화됩니다. 1.5 KLOC/s : 1초당 1,500줄의 코드를 처리함을 의미 특징 약 2배 이상의 빠른 컴파일 속도 신 기능 Static extensions Colletion literals Name-based destructuring Context receivers Explicit fields 새로운 기능은 아직 정확히 어떠한 버전에서 도입될지 정해지지 않은 상태입니다. Static extensions (https://github.com/Kotlin/KEEP/blob/statics/proposals/statics.md#kotlin-statics-and-static-extensions) static 키워드가 도입됩니다. static members/extensions/objects 개념이 새롭게 등장하게 됩니다. static interface, overrides 등장 static interface Parseable&lt;T&gt; { fun parse(s: String): T // static interface with `parse` function } class Color(val rgb: Int) : Parseable&lt;Color&gt; { static { override fun parse(s: String): Color { /* impl */ } } } fun main() { val parser: Parseable&lt;Color&gt; = Color.static val color = parser.parse(\"red\") println(color is Parseable&lt;Color&gt;) // false } static objects static object Namespace { val property = 42 // static property fun doSomething() { // static function property // OK: Can refer to static property in the same scope this // ERROR: Static objects have no instance } } fun main() { Namespace.doSomething() // OK val x = Namespace // ERROR: Cannot reference static object as value val y: Namespace? = null // ERROR: Cannot reference static object as type } static extensions 예를 들어, CsvFile 이라는 클래스에 대하여 open(fileName: String) 정적 확장 함수를 만들고자 한다면, CsvFile클래스에 Companion object가 선언된 경우에만 fun CsvFile.Companion.open(fileName: String) 으로 확장 함수를 선언할 수 있습니다. 2.X 버전 부터는 static도 확장이 가능해져, fun CsvFile.static.open(fileName: String)로 Companion object가 없더라도 확장 함수 선언이 가능해집니다. 최종 사용 구문은 section vs modifier 두 가지 중에서 현재 논의 중입니다. 각각 장단점을 가지고 있는데, 현재 Section이 더 많은 찬성을 받고 있습니다. Section 장점 : Companion object에서 마이그레이션 하기에 용이합니다. 단점 : 다른 언어들에서 주로 사용되는 구문과 달라 Kotlin 첫 사용자에게 학습장벽이 될 수 있습니다. Modifier 장점 : 다른 언어들에서 주로 사용되는 구문과 유사하여 Kotlin 첫 사용자에게 학습장벽이 낮습니다. 단점 : 모든 코드 줄을 바꿔야 하기 때문에 Companion object에서 마이그레이션 하기에 어려움이 있습니다. class C { // Static section syntax static { val property = println(\"initialized\") } // Static modifier syntax static val property = println(\"initialized\") } Collection literals [1, 2, 3]과 같은 방식으로 Collection을 선언할 수 있게 됩니다. 다른 주요 언어 에서는 이미 가능한 방식이죠. 찾아보니 5년 전에 제안된 개선안 인데 좀 늦게 적용되는 경향이 있습니다. val arr: Array&lt;String&gt; = [\"a\", \"b\", \"c\"] val set: Set&lt;Boolean&gt; = [true, false, true] val list: List&lt;Int&gt; = [1, 2, 3] val map: Map&lt;String, Int&gt; = [\"one\": 1, \"two\": 2, \"three\": 3] Name-based destructuring 아래의 경우 처럼, firstName과 lastName의 배치 순서가 바뀌어도 현재는 그대로 컴파일 되는데 이는 로직에 문제를 일으키게 됩니다. 이 문제를 해결한다고 하는데, 아직 추가 내용은 없습니다. data class Person( val firstName: String, val lastName: String ) fun main() { val person = Person(\"Kotlin\", \"Mascot\") val (firstName, lastName) = person val (lastName, firstName) = person } Context receivers Context Receivers라는 기능이 추가됩니다. 특정 context을 통해서만 사용 가능한 함수나 속성을 선언할 수 있게 해줍니다. 이를 통해 코드의 모듈성과 구조화가 향상시킬 수 있을 것 같습니다. 사용 방법 context(...)를 붙여주면 됩니다. Context receivers를 사용할 때의 차이점을 같은 동작을 하는 코드를 통해 비교하면 아래와 같습니다. fun doSomething(scope: CoroutineScope) { scope.launch { // CoroutineScope 내에서 작동하는 코드 } } val scope = CoroutineScope(Dispatchers.Default) doSomething(scope) context(CoroutineScope) fun doSomething() { launch { // CoroutineScope 내에서 작동하는 코드 } } val scope = CoroutineScope(Dispatchers.Default) scope.doSomething() 특징 코드 간결성: context를 사용하면, context를 명시적으로 전달할 필요가 없어 코드가 더 간결해집니다. 다중 context 지원: 하나의 함수가 여러 context에서 동작할 수 있으므로, 더 다양한 사용 사례를 지원할 수 있습니다. Explicit fields private val _applicationState = MutableStateFlow(State()) val applicationState: StateFlow&lt;State&gt; get() = _applicationState 현재 변수를 클래스 내부에서 사용하기 위해서 private으로 선언한 후, 외부에서 읽기 전용으로 쓰도록 하기 위해 추가로 public 변수를 선언하는 것이 일반적입니다. 어쩔 수 없는 선언 방식이지만 코드 길이가 2배가 되는 문제가 있습니다. 차후에는 아래와 같이 간편하게 사용할 수 있게 됩니다. 코드가 간결해지고, 가독성이 향상될 것으로 기대됩니다. val applicationState: StateFlow&lt;State&gt; field = MutableStateFlow(State())",
    "tags": "Kotlin",
    "url": "/jekyll-theme-yat/kotlin/2023/09/02/Kotlin-1.9,-2.0-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B0.html"
  },{
    "title": "그래프 그리는 View만들기",
    "text": "그래프 그리는 View만들기 아래의 사진 처럼 그래프를 그려주는 View를 만드는 방법을 이번 글에서 다루어 보겠습니다. 사용하는 주요 클래스 View를 상속하여 CustomView를 만듭니다. Canvas 화면에 실제로 보여줄 View를 그리는 클래스입니다. 그림을 그리는 종이라고 생각하면 이해하기 쉬울 것 같습니다. 참고 : Android의 Canvas에 그려보자 : 선, 도형 그리고 그림까지!? Paint Canvas에 그릴 객체(선, 도형, 글자 등)의 속성(색상, 스타일 등)을 정의하는 클래스입니다. Path 그래프를 그릴 때 사용되는 핵심 클래스입니다. 그릴 선의 정보를 담고 있습니다. 그래프를 그릴 View 클래스 정의 View를 상속하여 CustomView를 만듭니다. 예제에서는 GraphView라는 이름으로 클래스를 정의합니다. class GraphView(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : View(context, attrs, defStyleAttr) { constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0) constructor(context: Context) : this(context, null, 0) } 그래프에 그릴 객체의 속성을 정의하기 // 그릴 선, 도형의 속성 목록 private val _mPaints: MutableList&lt;Paints&gt; = mutableListOf() private val mPaints: List&lt;Paints&gt; get() = _mPaints // 그래프 상단/하단의 여백 크기, 12dp private val mVerticalSpace = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12f, Resources.getSystem().displayMetrics) // 그래프 x축 값의 간격, 48dp private val mXAxisValueIntervalSpace: Float = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 48f, Resources.getSystem().displayMetrics) // 그릴 선, 도형의 Paint객체를 담을 클래스 // 여러 개의 선을 그릴 때 각각의 선의 속성을 다르게 설정 하기 위해 사용합니다. private data class Paints( val linePaint: Paint, val pointPaint: Paint, ) 표시할 데이터 관련 로직 정의하기 그래프로 표시할 값을 처리하기 위한 로직을 만들어야 합니다. // 각각의 선으로 그리기 위한 값 목록 private val _mDataList: MutableList&lt;List&lt;Float&gt;&gt; = mutableListOf() private val mDataList: List&lt;List&lt;Float&gt;&gt; = _mDataList fun setDataList(dataList: List&lt;List&lt;Float&gt;&gt;) { _mDataList.clear() _mDataList.addAll(dataList) } 그래프를 그리는 로직 정의하기 그래프를 그리기 위한 사전 정보를 정의하는 코드입니다. 그래프의 그리기 정보를 담고 있는 DrawInfo 클래스를 정의합니다. Fragment, Activity에서 GraphView에 그릴 객체의 정보를 설정하기 위해서 setDrawInfo()를 사용합니다. data class DrawInfo( @Dimension(Dimension.DP) val lineThickness: Int = 1, @ColorInt val lineColor: Int = Color.WHITE, @ColorRes val lineColorResId: Int = NONE_ID, @Dimension(Dimension.DP) val pointRadius: Int = 2, @ColorInt val pointColor: Int = Color.WHITE, @ColorRes val pointColorResId: Int = NONE_ID, ) { companion object { const val NONE_ID = -1 } } fun setDrawInfo(drawInfoList: List&lt;DrawInfo&gt;) { _mPaints.clear() // 그릴 객체의 크기를 dp로 설정하기 위해서 기기 화면의 크기 정보를 가져옵니다. val displayMetrics = Resources.getSystem().displayMetrics for (drawInfo in drawInfoList) { val line = Paints( // 선의 속성 linePaint = Paint().apply { isAntiAlias = true style = Paint.Style.STROKE strokeWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, drawInfo.lineThickness.toFloat(), displayMetrics) color = if (drawInfo.lineColorResId == NONE_ID) drawInfo.lineColor else context.getColor(drawInfo.lineColorResId) }, // 선 위에 그릴 도형(점)의 속성 pointPaint = Paint().apply { isAntiAlias = true style = Paint.Style.FILL strokeWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, drawInfo.pointRadius.toFloat(), displayMetrics) color = if (drawInfo.pointColorResId == NONE_ID) drawInfo.pointColor else context.getColor(drawInfo.pointColorResId) }, ) _mPaints.add(line) } } GraphView의 너비를 계산하여 지정하는 코드입니다. 데이터가 있으면 데이터의 개수만큼 x축의 간격을 계산하여 너비를 지정합니다. 데이터의 개수만큼 너비가 설정됩니다. 데이터가 없다면 View정의 시 지정한 너비를 그대로 사용합니다. override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { val width: Int = if (mDataList.isEmpty()) widthMeasureSpec else mDataList.first().size * mXAxisValueIntervalSpace.toInt() setMeasuredDimension(width, heightMeasureSpec) } 그래프를 실제로 그리는 코드입니다. View의 레이아웃이 계산된 후 invalidate()가 호출될 때 onDraw()가 호출됩니다. override fun onDraw(canvas: Canvas) { super.onDraw(canvas) drawLinePaths(canvas) } private fun drawLinePaths(canvas: Canvas) { // 모든 데이터에서 최소값, 최대값을 구합니다. val (minValue, maxValue) = calculateMinMaxValue() // 그래프 y축이 그려질 최상단 y좌표값 val graphYAxisTop = mVerticalSpace // 그래프 y축의 길이, View의 높이 - 위아래 여백 val graphYAxisHeight = height - 2 * mVerticalSpace // 데이터 값의 범위 // 최소값: -10, 최대값: 200 -&gt; 210 val valueLength = maxValue.toFloat() - minValue.toFloat() // 그릴 선의 정보 val linePathList = mutableListOf&lt;Path&gt;() // 첫 값이 그려질 x좌표 val startPointX = mXAxisValueIntervalSpace / 2f // 각 선이 그려질 점의 좌표 목록 val linePoints = mutableListOf&lt;List&lt;PointF&gt;&gt;() mDataList.forEach { dataList -&gt; val path = Path() linePathList.add(path) // 첫 값의 좌표이자 이전 값의 좌표 var lastPoint = PointF(startPointX, graphYAxisTop + calculateYPosition(dataList.first().toFloat(), minValue.toFloat (), valueLength) * graphYAxisHeight) // 선의 시작 좌표를 첫 값의 좌표로 지정합니다. path.moveTo(lastPoint.x, lastPoint.y) val points = mutableListOf&lt;PointF&gt;() linePoints.add(points) dataList.forEachIndexed { i, value -&gt; if (i &gt; 0) { val newPoint = PointF(lastPoint.x + xAxisValueInterval, graphYAxisTop + calculateYPosition(value.toFloat(), minValue.toFloat (), valueLength) * graphYAxisHeight) val point1 = PointF(lastPoint.x + xAxisValueInterval / 2, lastPoint.y) val point2 = PointF(point1.x, newPoint.y) // 곡선을 그리기 위해서 좌표값을 설정합니다. path.cubicTo(point1.x, point1.y, point2.x, point2.y, newPoint.x, newPoint.y) lastPoint = newPoint } points.add(lastPoint) } } // 선과 점을 그립니다. mPaints.zip(linePathList).forEachIndexed { i, pair -&gt; canvas.drawPath(pair.second, mPaints[i].linePaint) drawPoints(linePoints[i], canvas, pair.first.pointPaint) } } // 선 위의 점을 그립니다. private fun drawPoints(points: List&lt;PointF&gt;, canvas: Canvas, paint: Paint) { points.forEach { pointF -&gt; canvas.drawCircle(pointF.x, pointF.y, paint.strokeWidth, paint) } } // 데이터 값에 따라서 그래프에서 그려질 선의 y좌표 위치를 계산합니다. // 최소값: 5, 최대값: 10, 값: 7 -&gt; 0.5 // y축에서 중간에 위치하게 됩니다. private fun calculateYPosition(value: Float, minValue: Float, valueLength: Float) = (1f - ((value - minValue) / valueLength)) // 모든 데이터에서 최소값, 최대값을 구합니다. private fun calculateMinMaxValue(): Pair&lt;Number, Number&gt; { val min: Number = mDataList.minBy { numbers -&gt; numbers.minOf { it } }.minOf { it } val max: Number = mDataList.maxBy { numbers -&gt; numbers.maxOf { it } }.maxOf { it } return min to max } cubicTo() fun cubicTo(x1: Float, y1: Float, x2: Float, y2: Float, x3: Float, y3: Float): Unit bezier 곡선을 그립니다. x1 : 첫 번째 제어점의 x좌표 y1 : 첫 번째 제어점의 y좌표 x2 : 두 번째 제어점의 x좌표 y2 : 두 번째 제어점의 y좌표 x3 : 끝 점의 x좌표 y3 : 끝 점의 y좌표 그림에서 2, 3, 4 점이 (x1, y1), (x2, y2), (x3, y3) 에 해당합니다. calculateYPosition() 1f - (value - minValue) / (maxValue - minValue)의 계산식을 통해서 데이터 값에 따라서 선의 y좌표 위치를 계산합니다. 사용 ScrollView로 감싸서 사용하도록 합니다. GraphView의 높이는 200dp로 고정하였습니다. &lt;HorizontalScrollView android:layout_width=\"match_parent\" android:nestedScrollingEnabled=\"true\" android:layout_height=\"wrap_content\"&gt; &lt;FrameLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;toss.next.naversovc.ui.common.view.GraphView android:id=\"@+id/graphView\" android:layout_width=\"wrap_content\" android:layout_height=\"200dp\" android:background=\"#B8B8B8\" /&gt; &lt;/FrameLayout&gt; &lt;/HorizontalScrollView&gt; binding.run { // 그릴 객체 정보 graphView.setDrawInfo(listOf( DrawInfo( lineThickness = 4, lineColor = Color.WHITE, pointRadius = 8, pointColor = Color.WHITE, ), DrawInfo( lineThickness = 4, lineColor = Color.YELLOW, pointRadius = 8, pointColor = Color.YELLOW, ), DrawInfo( lineThickness = 4, lineColor = Color.RED, pointRadius = 8, pointColor = Color.RED, ), )) // 데이터 값 graphView.setDataList( listOf( (-50..50 step 10).toList(), (50 downTo -50 step 10).toList(), listOf(10, 20, 30, 20, 10, 20, 30, 20, 10, 20, 30) ) ) } 활용 시간 별 날씨예보의 기온 그래프와 같은 화면을 그리는 경우 등에 사용할 수 있습니다. 그 외에도 수학적인 그래프나, 값들 간에 비교를 위한 경우에도 사용할 수 있습니다.",
    "tags": "Android",
    "url": "/jekyll-theme-yat/android/2023/08/24/Android-%EA%B7%B8%EB%9E%98%ED%94%84-%EA%B7%B8%EB%A6%AC%EB%8A%94-View%EB%A7%8C%EB%93%A4%EA%B8%B0.html"
  },{
    "title": "ArrayMap, SparseArray, LruCache에 대해서 알아보기",
    "text": "ArrayMap, SparseArray, LruCache란 기본 자료 구조보다 더 메모리 효율적으로 구현한 자료 구조로, android.util 패키지에 포함되어 있습니다. ArrayMap HashMap을 개선한 버전입니다. HashMap보다 좀 더 메모리 효율적입니다. HashMap ArrayMap 특징 구조 HashMap 배열 1개를 사용합니다. 키와 값을 저장하는 배열 키에 대해 Hash값을 구함 -&gt; Hash값을 배열의 Index로 사용 -&gt; 해당 Index에 값을 가져온다. ArrayMap 배열 2개를 사용합니다. 키와 Hash값을 저장하는 배열, 키와 값의 쌍을 저장하는 배열 키에 대해 Hash값을 구함 -&gt; Hash값으로 Key Index를 구함 -&gt; 키와 값 쌍 배열에서 Key Index에 해당하는 값을 가져온다. 키 값 배열 크기 관리 데이터가 추가(제거)되면 배열을 사용되는 만큼 확장(축소)합니다.’ 장점 낭비되는 메모리가 없습니다. HashMap Map이 비어있더라도 기본적인 크기만큼 메모리가 할당되어 메모리가 낭비됩니다. ArrayMap Map이 비어있으면, 아무것도 가지고 있지 않아 메모리가 할당되어 있지 않아 낭비되는 부분이 없습니다. 데이터 처리 시 메모리 효율직입니다. 키를 가지고 값을 찾을때 HashMap은 Iterator를 통해서 값을 찾지만, ArrayMap은 배열의 Index로 값을 찾기 때문에 메모리를 좀더 효율적으로 사용하게 됩니다. 단점 데이터 조회 성능이 HashMap보다 떨어집니다. ArrayMap은 대량의 데이터를 처리하기에는 적합하지 않습니다. Hash계산으로 바로 값을 가져올 수 있는 HashMap와 달리 ArrayMap은 Hash계산 후 키와 값 스레드 동기화에 취약합니다. 인스턴스에 대해 동기화가 필요 없는 단일 스레드 환경에서 사용하기 적합합니다. 예제 코드 val arrayMap = ArrayMap&lt;Long, String&gt;() arrayMap.put(1, \"Dave\") // id가 1인 Dave를 저장 val value = arrayMap.get(\"Name\") // get name by id 1 SparseArray 기본 HashMap보다 더 메모리 효율적인 Map구조를 제공합니다. ArrayMap과 매우 유사합니다. 특징 구조 Hashing없이 Primitive Int type인 키를 이진 검색으로 찾고, 값을 관리합니다. 장점 메모리 효율적입니다. AutoBoxing이 없습니다. 일반적으로 Map은 키를 기본(Prmitive) Type(int)이 아닌 Wrapper Type(Integer)을 사용하기 때문에 추가적인 메모리 할당을 하고, 메모리 사용량이 늘어납니다. (Integer : 16 bytes, int : 4 bytes) 그러나 SparseArray는 Primitive Type(int)을 사용하기 때문에 추가적인 메모리 할당이 없기 때문에 메모리 사용량이 더 적습니다. 단점 데이터 조회 성능이 HashMap보다 떨어집니다. SparseArray는 대량의 데이터를 처리하기에는 적합하지 않습니다. Hash계산으로 바로 값을 가져올 수 있는 HashMap와 달리 SparseArray는 이진 검색으로 값을 찾기 때문에 처리 시간이 조금더 소요됩니다. val sparseArray = SparseArray&lt;String&gt;() sparseArray.put(1, \"Dave\") // id가 1인 Dave를 저장 val value = sparseArray.get(1) // get name by id 1 ArrayMap, SparseArray를 사용하기에 적합한 경우 처리할 데이터의 개수가 1,000개 미만 Map의 값에 Map이 사용되는 경우 HashMap, ArrayMap, SparseArray 성능 비교 메모리 사용량 비교(낮을수록 우위) SparseArray -&gt; ArrayMap, HashMap(ArrayMap, HashMap은 비슷한 메모리 사용량을 보입니다.) 데이터 조회 성능 비교(낮을수록 우위) SparseArray -&gt; HashMap -&gt; ArrayMap 처리해야할 데이터의 개수가 5,000개 이상이 되면서부터 격차가 크게 벌어집니다. 데이터 삽입 처리 시간 비교(낮을수록 우위) SparseArray -&gt; HashMap -&gt; ArrayMap 처리해야할 데이터의 개수가 5,000개 이상이 되면서부터 격차가 크게 벌어집니다. LruCache(Least Recently Used Cache) Queue를 기반으로, 데이터 사용빈도에 따라 데이터가 삭제 및 관리되는 Caching 자료구조 입니다. 특징 구조 내부적으로 LinkedListHashMap으로 구현되어 있으며 Queue를 기반으로 동작합니다. Cache크기를 개발자가 정할 수 있습니다. 동작 데이터를 삽입할 때 Queue의 맨 앞에 데이터를 삽입합니다. Cache크기가 가득 차있으면, 가장 오래된 데이터를 삭제하고 새로운 데이터를 삽입합니다. Cache크기가 가득 차있지 않으면, 새로운 데이터를 삽입합니다. 데이터를 조회할 때 데이터가 존재하면, 해당 데이터를 반환하고, Queue의 맨 앞으로 이동시킵니다. 데이터가 존재하지 않으면, null을 반환합니다. Android 개발 시 주로 쓰이는 Glide 라이브러리가 기본적으로 사진 캐싱을 처리할 때 LruCache를 사용합니다. 잘 안쓰이는 데이터는 자동으로 제거되기 때문에 불필요한 메모리 할당을 막을 수 있어, 상당히 효율적인 자료구조라고 생각됩니다. val nameCache = LruCache&lt;Long, String&gt;(10) // id to name nameCache.put(1, \"Dave\") // id가 1인 Dave를 저장 val name = lruCache.get(1) // get name by id 1",
    "tags": "Android",
    "url": "/jekyll-theme-yat/android/2023/08/13/androidx.collection-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0(SparseArray,-ArrayMap,-LruCache-/).html"
  },{
    "title": "Kotlin sealed class/interface 사용 시 하위 클래스에 대응되는 함수를 자동으로 만드는 방법",
    "text": "sealed interface/class 를 사용하는 경우 sealed class를 사용하여 각 상태에 따른 동작을 수행하도록 할 수 있습니다. sealed interface UiState&lt;out T&gt; { data class Success&lt;out T&gt;(val data: T) : UiState&lt;T&gt; data class Error(val exception: Throwable) : UiState&lt;Nothing&gt; object Loading : UiState&lt;Nothing&gt; } 이러한 경우, if 또는 when 문을 사용해서 각 상태에 따른 동작을 수행하게 됩니다. when (uiState) { is UiState.Success -&gt; { // 성공 시 } is UiState.Error -&gt; { // 오류 발생 시 } is UiState.Loading -&gt; { // 로딩 중 } } when 분기를 처리하는 대신에 각 클래스에 따른 함수를 만들어서 동작을 수행하도록 하는 방법도 있습니다. inline fun &lt;T&gt; UiState&lt;T&gt;.onError(block: (Throwable) -&gt; Unit): UiState&lt;T&gt; { if (this is UiState.Error) block(exception) return this } inline fun &lt;T&gt; UiState&lt;T&gt;.onLoading(block: () -&gt; Unit): UiState&lt;T&gt; { if (this is UiState.Loading) block() return this } inline fun &lt;T&gt; UiState&lt;T&gt;.onSuccess(block: (T) -&gt; Unit): UiState&lt;T&gt; { if (this is UiState.Success) block(data) return this } 이렇게 하면, when 분기를 처리하는 대신에, 상태에 따라 함수가 호출되면서 동작이 수행됩니다. uiState .onSuccess { data -&gt; } .onError { exception -&gt; } .onLoading { } 하지만, UiState 클래스 내용이 변경되면, 각 함수를 변경해야 합니다. 이런 불편함을 없애기 위해 KSP(Kotlin Symbol Processing)을 사용해서, sealed class에 대응되는 함수를 컴파일 할 때 자동을 생성시켜서 편하게 쓸 수 있습니다. 먼저 KSP에 대해 알아보겠습니다. KSP(Kotlin Symbol Processing) 란? Kotlin Compiler의 확장 기능으로, 컴파일 시에 코드를 분석하고 생성하는 기능을 제공합니다. 이를 통해, 코드 생성을 자동화하고, 코드의 반복 작성을 줄일 수 있습니다. KSP가 아닌 KAPT(Kotlin Annotation Processing Tool)도 있습니다. 이것도 같은 역할을 수행하지만 다음과 같은 차이점이 있습니다. KAPT Kotlin코드를 Java Bytecode로 변환한 후, Java Annotation Processing Tool을 사용해서, 코드를 처리합니다. KSP Kotlin 코드를 Java로 변환하지 않고 바로 처리하기 때문에, KAPT보다 성능이 더 좋습니다. Kotlin에 최적화 되어 있습니다. KSP를 사용하기 위한 사전설정 Project build.gradle version은 현재 사용중인 Kotlin version에 맞게 설정합니다. plugins { id(\"com.google.devtools.ksp\") version \"1.8.22-1.0.11\" apply false id(\"org.jetbrains.kotlin.jvm\") version \"1.8.22\" apply false } sealed interface/class에 대한 함수 자동 생성하는 과정 1. Annotation, Compiler Module 생성 Annotation, Compiler 두 개의 모듈을 만들어야 합니다. Annotation Module, build.gradle plugins { id(\"org.jetbrains.kotlin.jvm\") id(\"com.google.devtools.ksp\") } Compiler Module, build.gradle plugins { id(\"com.google.devtools.ksp\") } dependencies { implementation(\"com.google.devtools.ksp:symbol-processing-api:1.8.22-1.0.11\") } src/main에 파일 생성하기 resources/META-INF/services com.google.devtools.ksp.processing.SymbolProcessorProvider 파일 생성 컴파일 시에 동작시킬 Processor를 등록하는 과정입니다. com.google.devtools.ksp.processing.SymbolProcessorProvider 파일 내에 다음과 같이 작성합니다. io.github.pknujsp.core.compiler.BindFuncProcessorProvider 2. Annotation Module에 Annotation.kt 생성 Annotation Module에 Annotation.kt를 생성하고, 아래의 내용을 작성합니다. @Target(AnnotationTarget.CLASS) @Inherited annotation class KBindFunc @KBindFunc로 사용할 수 있게 되며, sealed interface/class에 붙여서 사용합니다. 3. Compiler Module에 Processor 생성 Compiler Module에 두 개의 파일을 만들어야 합니다. BindFuncProcessorProvider.kt BindFuncKspProcessor.kt BindFuncProcessorProvider.kt SymbolProcessorProvider는 KSP에서 Annotation 처리를 위한 사용자 정의 SymbolProcessor를 생성하는 방법을 정의하는 인터페이스입니다. BindFuncProcessorProvider의 create 메서드는 이 인터페이스의 구현부로서, 이 메서드를 호출할 때마다 새로운 BindFuncKspProcessor 인스턴스를 생성합니다. environment.codeGenerator, environment.logger, environment.options는 각각 코드 생성, 로깅, 옵션 처리를 담당하는 객체입니다. class BindFuncProcessorProvider : SymbolProcessorProvider { override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor = BindFuncKspProcessor( codeGenerator = environment.codeGenerator, logger = environment.logger, options = environment.options, ) } BindFuncKspProcessor.kt class BindFuncKspProcessor( private val codeGenerator: CodeGenerator, private val logger: KSPLogger, private val options: Map&lt;String, String&gt;, ) : SymbolProcessor { private companion object { // Annotation의 이름 val ANNOTATION_TYPE: String = KBindFunc::class.java.canonicalName // 생성할 바인딩 파일의 앞에 붙일 이름, ex) KBindFuncUiState.kt val PREFIX_OUTPUT_FILE_NAME = ANNOTATION_TYPE } // KSP에서 핵심 함수 override fun process(resolver: Resolver): List&lt;KSAnnotated&gt; { // KBindFunc Annotation이 붙은 모든 클래스를 가져옵니다. val declarations = resolver.getSymbolsWithAnnotation(ANNOTATION_TYPE).filterIsInstance&lt;KSClassDeclaration&gt;().toList() // 각 클래스에 대한 바인딩 파일을 생성합니다. declarations.forEach { createBindingFile(it) } return declarations.toList() } // 바인딩 파일을 생성하는 함수 private fun createBindingFile(declaration: KSClassDeclaration) { // Generic인 import T와 같은 불필요한 import를 제거하기 위한 Set val removeImports = mutableSetOf&lt;String&gt;() // 함수 정보를 가지는 List val funcSpecs = declaration.getSealedSubclasses().map { createMethods(declaration, it, removeImports) } // 바인딩 파일 정보 val newFileSpec = FileSpec.builder(declaration.packageName.asString(), \"${PREFIX_OUTPUT_FILE_NAME}${declaration.simpleName.asString()}\").apply { funcSpecs.forEach { addFunction(it) } }.build() try { // 바인딩 파일 생성 codeGenerator.createNewFile( dependencies = Dependencies(false, declaration.containingFile!!), packageName = declaration.packageName.asString(), fileName = \"${PREFIX_OUTPUT_FILE_NAME}_${declaration.simpleName.asString()}\", ).bufferedWriter().use { it.write( newFileSpec.toString().run { // import T와 같은 불필요한 import문을 제거합니다. removeUnnecessaryImports(this, removeImports) }, ) } } catch (e: Exception) { } } // import T와 같이 불필요한 import문을 제거하는 함수 private fun removeUnnecessaryImports(content: String, imports: MutableSet&lt;String&gt;): String { var content = content imports.forEach { content = content.replace(\"import $it\\n\", \"\") } return content } // sealed interface/class에 대하여 바인딩 함수를 생성하는 함수 private fun createMethods(parent: KSClassDeclaration, sub: KSClassDeclaration, removes: MutableSet&lt;String&gt;): FunSpec { // Generic인지 여부 val isGeneric = parent.typeParameters.isNotEmpty() // Generic인 경우, Generic 타입을 가져옵니다. val typeParameters = if (isGeneric) parent.typeParameters else emptyList() // sealed interface/class에 선언된 모든 속성을 가져옵니다. val properties = sub.getDeclaredProperties().toList() // 바인딩 함수의 이름을 생성합니다. // ex) onXXX 형식 return FunSpec.builder(\"on${sub.simpleName.asString()}\").run { // public, inline 함수로 설정합니다. // ex) public inline fun addModifiers(KModifier.PUBLIC) addModifiers(KModifier.INLINE) // 함수의 수신 객체 정보를 설정합니다. // ex) public inline fun &lt;T&gt; UiState&lt;T&gt;.onXXX() &lt;- UiState&lt;T&gt;가 수신 객체 receiver( ClassName.bestGuess(parent.qualifiedName!!.asString()).run { if (isGeneric) parameterizedBy(typeParameters.map { TypeVariableName(it.name.asString()) }.toList()) else this }, ) // 타입 변수를 추가합니다. // Generic이 아닌 경우, 타입 변수를 추가하지 않습니다. // ex) public inline fun &lt;T&gt; UiState&lt;T&gt;.onXXX() &lt;- T가 타입 변수 addTypeVariables( typeParameters.map { ksTypeParameter -&gt; TypeVariableName( ksTypeParameter.name.asString(), variance = KModifier.values().find { it.name == ksTypeParameter.variance.name.lowercase() }, ).let { typeVariableName -&gt; if (ksTypeParameter.bounds.toList().isNotEmpty() &amp;&amp; ksTypeParameter.bounds.any { it.element != null }) { typeVariableName.copy( bounds = ksTypeParameter.bounds.toList().map { TypeVariableName(it.toString()) }, ) } else { typeVariableName } } }.toList(), ) // 함수의 Parameter를 추가합니다. // ex) public inline fun &lt;T&gt; UiState&lt;T&gt;.onXXX(block: (T) -&gt; Unit) &lt;- block이 Parameter addParameter( ParameterSpec.builder( \"block\", LambdaTypeName.get( parameters = properties.map { ParameterSpec.unnamed( if (it.type.resolve().declaration.typeParameters.isNotEmpty()) { TypeVariableName(it.type.resolve().declaration.typeParameters.first().name.asString()) } else { ClassName.bestGuess( it.type.resolve().declaration.qualifiedName!!.asString().run { if (contains(sub.simpleName.getShortName())) { it.type.resolve().declaration.simpleName.getShortName().apply { removes.add(this) } } else this }, ) }, ) }.toList(), returnType = UNIT, ), ).build(), ) // 함수의 반환 타입을 설정합니다. // ex) public inline fun &lt;T&gt; UiState&lt;T&gt;.onXXX(block: (T) -&gt; Unit): UiState&lt;T&gt; &lt;- UiState&lt;T&gt;가 반환 타입 returns( ClassName.bestGuess(parent.qualifiedName!!.asString()).run { if (isGeneric) parameterizedBy(typeParameters.map { TypeVariableName(it.name.asString()) }.toList()) else this }, ) // 함수의 구현 코드를 추가합니다. addStatement(\"if (this is ${parent.simpleName.asString()}.${sub.simpleName.asString()})\") val block = if (properties.isNotEmpty()) { properties.mapIndexed { i, v -&gt; if (i &lt; properties.size - 1) \"${v.simpleName.asString()},\" else v.simpleName.asString() }.joinToString(\"\").run { \"block(${this})\" } } else { \"block()\" } addStatement( \"\"\" | $block \"\"\".trimMargin(), ) addStatement(\"return this\") build() } } } 4. Annotation 사용법 sealed class에 @KBindFunc를 붙여주고 컴파일하면 즉시 바인딩 함수 사용이 가능합니다. @KBindFunc sealed interface UiState&lt;out T&gt; { data class Success&lt;out T&gt;(val data: T) : UiState&lt;T&gt; data class Error(val exception: Throwable) : UiState&lt;Nothing&gt; object Loading : UiState&lt;Nothing&gt; } 컴파일 결과 아래와 같은 함수를 가진 바인딩 파일이 생성됩니다. public inline fun &lt;T&gt; UiState&lt;T&gt;.onError(block: (Throwable) -&gt; Unit): UiState&lt;T&gt; { if (this is UiState.Error) block(exception) return this } public inline fun &lt;T&gt; UiState&lt;T&gt;.onLoading(block: () -&gt; Unit): UiState&lt;T&gt; { if (this is UiState.Loading) block() return this } public inline fun &lt;T&gt; UiState&lt;T&gt;.onSuccess(block: (T) -&gt; Unit): UiState&lt;T&gt; { if (this is UiState.Success) block(data) return this } 함수를 이어서 사용하면 됩니다. uiState.onSuccess { }.onError { }.onLoading { } 라이브러리로 배포 사용하기 쉽도록 라이브러리로 배포하였습니다. 아래 처럼 build.gradle에 추가하고 @KBindFunc를 붙인 후 컴파일 한 다음 사용하면 됩니다. plugins { id(\"com.google.devtools.ksp\") } dependencies { ksp(\"io.github.pknujsp:ksealedbinding-compiler:1.0.0\") implementation(\"io.github.pknujsp:ksealedbinding-annotation:1.0.0\") }",
    "tags": "Kotlin",
    "url": "/jekyll-theme-yat/kotlin/2023/08/03/Kotlin-sealed-class-%EC%83%81%ED%83%9C%EB%B3%84-%ED%95%A8%EC%88%98-%EC%9E%90%EB%8F%99-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0.html"
  },{
    "title": "Android 시스템 바(상태바, 네비게이션바) 색상 자동 변경 처리하기",
    "text": "Android 시스템 바(상태바, 네비게이션바) 색상 자동 변경 처리하기 아래의 내용을 통하여 시스템 바의 색상/레이아웃을 변경하는 방법을 확인할 수 있습니다. Android 시스템 바 레이아웃 변경하기 시스템 바 색상 변경시 생기는 문제점 아래와 같이 배경 색상이 다른 화면이 표시되는 경우, 화면의 배경색과 시스템 바의 색상이 겹쳐서 보이지 않는 문제가 발생합니다.     &lt;img src=\"https://github.com/pknu-wap/2023_1_WAP_APP_TEAM_MEDI/assets/48265129/c34fbf7e-9425-45d4-8f92-445c7c7e629b\"&gt; &lt;img src=\"https://github.com/pknu-wap/2023_1_WAP_APP_TEAM_MEDI/assets/48265129/d5b8cff1-51ac-42e0-9c77-62af784ec02c\"&gt; Activity, Fragment, Compose 화면 구성 요소가 변경될 때 이와 같은 상황이 발생하게 됩니다. 본 글에서는 Fragment가 변경될 때의 경우에 대처하는 방법을 설명하겠습니다. 화면이 변경될 떄 마다 대처하는 방법 Activity 가 변경되는 경우 onCreate()에서 색상 변경 코드를 작성 XML에서 미리 지정해놓은 테마(스타일)적용 Fragment 가 변경되는 경우 시스템 바의 색상이 변경되어야 하는 Fragment 마다 각각 색상 변경 코드를 작성하여야 함 위와 같은 방법은 코드의 중복이 발생하고, 상당히 번거로운 작업이 됩니다. 특히 수 많은 Fragment가 변경되는 경우라면 굉장한 반복 작업이 될 것입니다. 이러한 고된 작업을 하지 않기 위해서 우선 FragmentLifecycleCallbacks 사용을 고려할 수 있습니다. FragmentLifecycleCallbacks으로 Fragment의 상태를 감지하기 FragmentLifecycleCallbacks를 FragmentManager 에 등록하여 Fragment의 상태(생명주기)를 감지할 수 있습니다. supportFragmentManager.registerFragmentLifecycleCallbacks( object : FragmentManager.FragmentLifecycleCallbacks() { override fun onFragmentResumed(fm: FragmentManager, f: Fragment) { super.onFragmentResumed(fm, f) // 이 함수는 아래에서 설명하겠습니다. systemBarColorAnalyzer.convert() } }, true, ) Callback을 등록할 FragmentManager는 Activity에서 FragmentManager를 사용하는 것을 권장합니다. registerFragmentLifecycleCallbacks()를 사용할 때 Argument로 true를 전달하면 View에 표시되는 모든 Fragment의 상태를 감지를 할 수 있습니다. 이제 Fragment의 상태를 한 곳에서 감지할 수 있게 되었습니다. 본격적으로 시스템 바의 색상을 자동으로 변경하는 방법을 알아봅시다. 시스템 바의 색상을 자동으로 변경하는 방법 Fragment의 개수가 2 ~ 3개 정도로 아주 적으면, 경우에 따라 각각의 Fragment에서 시스템 바의 색상을 변경하는 코드를 작성하거나 위 Callback의 onFragmentResumed()에서 Fragment 별로 분기문을 만들어 색상을 변경하는 방법이 더 효율적일 수 있습니다. 그러나, Fragment의 개수는 수십 개, 많으면 수백 개가 될 수 있습니다. 이러한 경우에는 분기문으로 처리하는 것은 당연히 매우 부적절한 방법입니다. 따라서, Fragment가 Resumed 상태가 되었을 때, 시스템 바 위치에 있는 View의 배경색을 분석하여 색상을 변경하는 방법을 사용하도록 하겠습니다. 로직을 간단히 설명하면 아래와 같습니다. Fragment onResumed 응답을 받고 색상변경 요청을 합니다. 시스템 바 색상을 분석합니다. 색상을 흑백으로 변환합니다. 변환된 흑백 값에 따라 시스템 바의 색상을 변경합니다. 상세 로직 1. 색상변경 작업을 구현하는 클래스 초기화 색상 변경을 담당하는 SystemBarColorProcessor 클래스를 만들었습니다. SystemBarColorProcessor 클래스를 초기화합니다. override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // SystemBarColorProcessor를 초기화합니다. SystemBarColorProcessor.init(window, lifecycle) // FragmentLifecycleCallbacks를 등록합니다. supportFragmentManager.registerFragmentLifecycleCallbacks( object : FragmentManager.FragmentLifecycleCallbacks() { override fun onFragmentResumed(fm: FragmentManager, f: Fragment) { super.onFragmentResumed(fm, f) systemBarColorProcessor.convert() } }, true, ) } private var _window: Window? = null private val window: Window get() = _window!! private var _windowInsetsController: WindowInsetsControllerCompat? = null private val windowInsetsController: WindowInsetsControllerCompat get() = _windowInsetsController!! fun init(window: Window, lifecycle: Lifecycle) { _window = window _windowInsetsController = WindowCompat.getInsetsController(window, window.decorView) lifecycle.addObserver( object : DefaultLifecycleObserver { override fun onStart(owner: LifecycleOwner) { super.onStart(owner) // Activity가 Start될 때, 색상변경 처리를 합니다. convert() } override fun onDestroy(owner: LifecycleOwner) { super.onDestroy(owner) // Activity가 Destroy될 때, 메모리 누수를 방지하기 위한 작업을 해줍니다. coroutineScope.cancel() _window = null _windowInsetsController = null } }, ) } 2. Fragment onResumed 응답을 받고, 색상변경 요청 override fun onFragmentResumed(fm: FragmentManager, f: Fragment) { super.onFragmentResumed(fm, f) SystemBarColorProcessor.convert() } private val waitLock = Mutex() private var waiting: Job? = null private val coroutineScope = MainScope() + CoroutineName(\"SystemBarColorProcessor\") private val onChangedFragmentFlow = MutableSharedFlow&lt;Unit&gt;(onBufferOverflow = BufferOverflow.SUSPEND, replay = 0, extraBufferCapacity = 2) private val delayTime = 80L fun convert() { coroutineScope.launch { waitLock.withLock { if (waiting?.isActive == true) waiting?.cancel() waiting = launch(Dispatchers.Default) { delay(delayTime) onChangedFragmentFlow.emit(Unit) } } } } onResumed 응답 수신 convert(), 시스템 바 색상변경 요청 convert() 함수가 호출되면, 비동기로 처리합니다. waiting Job이 존재하면, 취소합니다. 새로운 waiting Job을 생성하고, delayTime : 80ms 시간동안 대기합니다. 만약 delayTime이내에 추가 요청이 발생하면, 2번 작업을 다시 수행합니다. delayTime이내에 추가 요청이 없으면, onChangedFragmentFlow에 새로운 요청이 발생했음을 알립니다. 3. 시스템 바 색상 분석, 픽셀 값 변환, 색상 변경 private enum class ColorType { BLACK, WHITE } private data class ConvertedColor(val statusBarColor: ColorType, val navBarColor: ColorType) init { coroutineScope.launch(Dispatchers.Default) { onChangedFragmentFlow.collect { val convertJob = launch(start = CoroutineStart.LAZY) { val convertedColor = startConvert() withContext(Dispatchers.Main) { setStyle(convertedColor) } } window.decorView.doOnPreDraw { convertJob.start() } convertJob.join() } } } private fun setStyle(convertedColor: ConvertedColor) { windowInsetsController.apply { // 상태바 색상 변경 isAppearanceLightStatusBars = (statusBarColor == ColorType.BLACK) isAppearanceLightNavigationBars = (navBarColor == ColorType.BLACK) } } private suspend fun startConvert(): ConvertedColor { // 비트맵 생성 val statusBarBitmap = WeakReference(Bitmap.createBitmap(decorView.width, statusBarHeight, Bitmap.Config.ARGB_8888)).get()!! val navBarBitmap = WeakReference(Bitmap.createBitmap(decorView.width, navBarHeight, Bitmap.Config.ARGB_8888)).get()!! // View에서 시스템 바 위치의 픽셀 값을 비트맵에 복사 window.decorView.run { pixelCopy(Rect(0, 0, width, statusBarHeight), statusBarBitmap) pixelCopy(Rect(0, height - navBarHeight, width, height), navBarBitmap) } // 비트맵 좌표 (10, 10)의 픽셀 값을 최종 시스템 바 색상으로 변환 val statusBarColor = statusBarBitmap[10, 10].toColor() val navBarColor = navBarBitmap[10, 10].toColor() // 비트맵 메모리 회수 statusBarBitmap.recycle() navBarBitmap.recycle() return ConvertedColor(statusBarColor, navigationBarColor) } private suspend fun pixelCopy(rect: Rect, bitmap: Bitmap) = suspendCancellableCoroutine { cancellableContinuation -&gt; // Window에서 사각형 영역의 픽셀 값을 비트맵에 복사 PixelCopy.request( window, rect, bitmap, { cancellableContinuation.resume(it == PixelCopy.SUCCESS) }, Handler(Looper.getMainLooper()), ) } private val criteriaColor = 140 private fun Int.toColor() : ColorType { val r = Color.red(this) val g = Color.green(this) val b = Color.blue(this) val a = Color.alpha(this) val gray = if (a == 0) -1 else (0.2989 * r + 0.5870 * g + 0.1140 * b).toInt() // -1 : 투명 // 0 : 검은색 // 255 : 흰색 // 기준 값에 따라 검은색, 흰색으로 분류 return if (gray == 0 || gray == -1) WHITE else if (gray &lt;= criteriaColor) WHITE else BLACK } Window의 DecorView에 일회성 OnPreDrawListener를 등록합니다. KTX 라이브러리를 사용한다면 doOnPreDraw로 간편하게 등록할 수 있습니다. OnPreDrawListener는 View가 그려지기 전에 호출되는 리스너입니다. OnDrawListener도 있으나, OnDrawListener는 View가 그려진 후에 호출되기 때문에, 조금이라도 더 빠르게 색상변경을 하기위해 OnPreDrawListener를 사용합니다. startConvert(), 색상 분석 및 변환을 시작합니다. 변환된 시스템 바 색상을 적용시킵니다. MainThread에서 실행되어야 하기 때문에, withContext(Dispatchers.Main)을 사용합니다. 요청 순서대로 작업을 수행하기 위해 지연시작으로 코루틴을 동작시키도록 하였습니다. 결과 위와 같은 작업을 실시간으로 수행하면서 색상이 변경됨을 확인할 수 있습니다.",
    "tags": "Android",
    "url": "/jekyll-theme-yat/android/2023/07/30/Android-%EC%83%81%ED%83%9C%EB%B0%94%EC%99%80-%EB%84%A4%EB%B9%84%EA%B2%8C%EC%9D%B4%EC%85%98%EB%B0%94-%EC%83%89%EC%83%81-%EC%9E%90%EB%8F%99-%EB%B3%80%EA%B2%BD-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0.html"
  },{
    "title": "Android 시스템 바 레이아웃 변경하기",
    "text": "Android 시스템바 색상 설정 변경하는 방법 컨텐츠 레이아웃이 화면 전체를 차지하도록 설정 WindowCompat.setDecorFitsSystemWindows(window, true or false) true false 컨텐츠 레이아웃의 범위가 상태 바와 네비게이션 바 영역을 제외한 영역만 차지합니다. 컨텐츠 레이아웃의 범위가 상태 바와 네비게이션 바 영역까지 확장됩니다. ![image](https://github.com/pknu-wap/2023_1_WAP_APP_TEAM_MEDI/assets/48265129/73403f93-a4e4-496c-8bd2-5bce72621e81) ![image](https://github.com/pknu-wap/2023_1_WAP_APP_TEAM_MEDI/assets/48265129/3810f34d-3a0e-4034-aaa6-f088414a0505) true false true와 달리, 레이아웃 계층에서 navigationBarBackground와 statusBarBackground가 최상위로 올라오게 됩니다. 상태 바와 네비게이션 바 색상 변경 window.apply { WindowCompat.setDecorFitsSystemWindows(window, false) navigationBarColor = Color.TRANSPARENT statusBarColor = Color.TRANSPARENT } 배경색이 변경되게 됩니다. 상태 바 : GREEN, 네비게이션 바 : GREEN 상태 바 : TRANSPARENT, 네비게이션 바 : TRANSPARENT &lt;img src=\"https://github.com/pknu-wap/2023_1_WAP_APP_TEAM_MEDI/assets/48265129/169def82-ba2a-4b0f-9ee5-ae39f8254cdf\" height=\"100%\" width=\"auto\"&gt; &lt;img src=\"https://github.com/pknu-wap/2023_1_WAP_APP_TEAM_MEDI/assets/48265129/27caf758-5022-4081-a980-42461128b728\" height=\"100%\" width=\"auto\"&gt; 상태 바 투명으로 설정하면 DecorView에서 그려지지 않습니다. 네비게이션 바 투명으로 설정하더라도 DecorView에서 그려지게 됩니다. 투명으로 설정하면 배경색이 검은색으로 설정됩니다. 상태 바와 네비게이션 바를 투명하게 하기 window.addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS) 아래의 코드와 같은 상태에서 네비게이션 바가 DecorView에서 사라지고 배경색이 투명하게 되는 것과 같습니다. window.apply { WindowCompat.setDecorFitsSystemWindows(window, false) navigationBarColor = Color.TRANSPARENT statusBarColor = Color.TRANSPARENT } 뷰의 위치를 시스템 바와 겹치지 않도록 설정하기 window.addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS) 위와 같은 상태에서는, 뷰가 시스템 바와 겹치게 됩니다. 겹치는 뷰에 대하여 Margin 또는 Padding을 설정하여 시스템 바와 겹치지 않도록 설정해야 합니다. 1 시스템 바의 높이를 가져옵니다. // 안드로이드 프레임워크에서 기본적으로 설정되어 있는 값을 통해서 가져올 수 있습니다. val resources = Resources.getSystem() val statusBarHeight1 = resources.getDimensionPixelSize(resources.getIdentifier(\"status_bar_height\", \"dimen\", \"android\")) val navigationBarHeight1 = resources.getDimensionPixelSize(resources.getIdentifier(\"navigation_bar_height\", \"dimen\", \"android\")) } 2 뷰에 대하여 Margin 또는 Padding값을 갱신합니다. 이미 지정된 값이 있을 수 있으므로, 기존 값에 시스템 바의 높이를 더해줍니다. top, bottom에 대해서 적용할지 여부는 상황에 따라 선택합니다. // Margin val resources = Resources.getSystem() val statusBarHeight = resources.getDimensionPixelSize(resources.getIdentifier(\"status_bar_height\", \"dimen\", \"android\")) val navigationBarHeight = resources.getDimensionPixelSize(resources.getIdentifier(\"navigation_bar_height\", \"dimen\", \"android\")) root.updatePadding(top = root.paddingTop + statusBarHeight, bottom = root.paddingBottom + navigationBarHeight) 3 결과 다음 주제 OneActivity 구조에서 Fragment가 변경될 때 마다 시스템 바 설정을 자동으로 변경시키는 방법에 대해 알아보겠습니다.",
    "tags": "Android",
    "url": "/jekyll-theme-yat/android/2023/07/22/Android-%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B0%94-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0.html"
  },{
    "title": "Kotlin 동시성 문제 해결방법",
    "text": "동시성을 고려하여 동기화가 필요한 경우 var count = 0 const val repeatCount = 1000000 fun main() = runBlocking { launch(Dispatchers.Default) { repeat(repeatCount) { count++ } println(count) } launch(Dispatchers.Default) { repeat(repeatCount) { count++ } println(count) } println(\"기대값 : ${repeatCount * 2}\") } 기대값 : 2000000 981272 1862564 2000000이라는 기대값과는 다르게 981272, 1862564이 결과로 출력되었습니다. 이는 두 개의 코루틴이 동기화를 하지 않고 count 변수에 대해 연산을 수행하기 때문에 발생하는 문제입니다. Thread 2에서 count++를 수행한 결과 값이 반영되기 전에 Thread 3에서 read count로 count 1을 읽게 되면서 꼬이기 시작합니다. Race Condition(경쟁 상태)이라고 합니다. 스레드 순서에 따라 결과가 달라지는 상황을 의미합니다. 해결책 여러 스레드 간에 공유되며 동시에 접근이 가능한 객체에 대해 어떠한 코드를 수행할 때 동기화를 해주는 것이 필요합니다. 1. AtomicInteger 원자적으로 연산을 수행합니다. 원자적 연산이란, 연산이 수행되는 동안 다른 스레드가 접근하지 못하도록 하는 것을 의미합니다. 하나의 기계어로만 연산을 수행하며, 해당 연산을 하고 있는 도중에는 같은 연산을 할 수 없어 값의 동기화를 성공적으로 수행할 수 있습니다. 멀티 스레드 환경에서도 동기화되어 안전하게 사용할 수 있습니다. val atomicCount = AtomicInteger(0) atomicCount.incrementAndGet() 위와 같이 사용할 수 있습니다. 2. Mutex, Synchronized 하나의 스레드 혹은 코루틴만 공유 데이터에 접근할 수 있도록 lock을 걸어주는 방식입니다. 상호 배제(Mutual Exclusion) 방식입니다. 동작할 코드가 임계 구역에 있으면, 해당 구역에 대해서 하나의 스레드만 접근할 수 있게 합니다. lock이 걸린 경우, 다른 스레드는 unlock이 될 때 까지 대기하거나, 해당 작업을 무시하고 다른 작업을 수행하도록 할 수 있습니다. Mutex와 Synchronized는 상호 배제 방식이라는 것에서 비슷합니다. 차이점 Mutex 코루틴을 일시 중지시킵니다. 스레드를 중지 시키지 않습니다. 코루틴 사용에 최적화 되어 있습니다. Synchronized 스레드를 일시 중지시킵니다. Atomic과의 차이점 Atomic 스레드와 메인 메모리에 있는 값을 비교하여 서로 일치하지 않으면 동기화 시키고 연산을 수행한다. lock을 하지 않는다. 상호 배제 임계 구역 진입 전에 스레드와 메인 메모리의 값을 동기화 시킨다. val mutex = Mutex() var mutexCount = 0 launch(Dispatchers.Default) { repeat(repeatCount) { mutex.withLock { mutexCount++ } // OR mutex.lock() try { mutexCount++ } finally { mutex.unlock() } } } 위와 같이 mutex.withLock()을 사용하여 간단하게 사용이 가능합니다. withLock() 이미 lock이 걸린 경우, 대기합니다. lock이 걸리지 않은 경우, lock을 걸고 작업을 수행합니다. 작업이 끝나면 unlock 합니다. 3. 단일 스레드를 사용 동기화가 필요한 연산에 대해서 하나의 스레드로만 동작하도록 하는 방식입니다. var singleThreadCount = 0 val singleThread = newSingleThreadContext(\"Concurrency\") launch(Dispatchers.Default) { repeat(repeatCount) { withContext(singleThread) { singleThreadCount++ } } } newSingleThreadContext()를 사용하여 단일 스레드를 생성합니다. withContext()를 사용하여 해당 스레드에서 작업을 수행합니다. Default context &lt;-&gt; singleThread context 간에 지속적으로 전환이 발생하기 때문에 성능이 저하될 수 있습니다. 4. Actor 메시지를 전달받아 순차적으로 처리하는 방식으로 작동합니다. actor에게 메시지를 전달하면, 해당 메시지를 순차적으로 처리합니다. 연산하는 데이터는 actor에서만 접근이 가능합니다. actor는 단일 스레드에서 동작하기 때문에 동기화 문제가 해결됩니다. sealed interface Message data object Increment : Message class Result(val response: CompletableDeferred&lt;Int&gt;) : Message @ObsoleteCoroutinesApi fun CoroutineScope.counterActor() = actor&lt;Message&gt; { var counter = 0 for (message in channel) { when (message) { is Increment -&gt; counter++ is Result -&gt; message.response.complete(counter) } } } val actorCounter = counterActor() launch(Dispatchers.Default) { repeat(repeatCount) { actorCounter.send(Increment) } } val response = CompletableDeferred&lt;Int&gt;() actorCounter.send(Result(response)) actor()를 사용하여 actor를 생성합니다. 해야하는 작업에 대해 메시지를 전달합니다. actor에서 요청을 처리하는 것은 단일 스레드에서 동작하기 때문에 동기화 문제가 해결됩니다. 처리 방법 별 성능 비교 import kotlinx.coroutines.* import kotlinx.coroutines.channels.actor import kotlinx.coroutines.sync.Mutex import kotlinx.coroutines.sync.withLock import java.util.concurrent.atomic.AtomicInteger import kotlin.system.measureNanoTime val mutex = Mutex() var mutexCount = 0 var singleThreadCount = 0 var synchronizedCount = 0 var atomicCount = AtomicInteger(0) @OptIn(DelicateCoroutinesApi::class) val singleThread = newSingleThreadContext(\"Concurrency\") val syncLock = Any() sealed interface Message data object Increment : Message class Result(val response: CompletableDeferred&lt;Int&gt;) : Message val resultList = mutableListOf&lt;Pair&lt;String, Double&gt;&gt;() @ObsoleteCoroutinesApi fun CoroutineScope.counterActor() = actor&lt;Message&gt; { var counter = 0 for (message in channel) { when (message) { is Increment -&gt; counter++ is Result -&gt; message.response.complete(counter) } } } const val repeatCount = 1000000 @OptIn(ObsoleteCoroutinesApi::class) fun main() = runBlocking { measureNanoTime { launch(Dispatchers.Default) { repeat(repeatCount) { atomicCount.incrementAndGet() } } launch(Dispatchers.Default) { repeat(repeatCount) { atomicCount.incrementAndGet() } } }.also { resultList.add(\"Atomic\" to it / 1000000.0) } measureNanoTime { launch(Dispatchers.Default) { repeat(repeatCount) { mutex.withLock { mutexCount++ } } } launch(Dispatchers.Default) { repeat(repeatCount) { mutex.withLock { mutexCount++ } } } }.also { resultList.add(\"Mutex\" to it / 1000000.0) } measureNanoTime { launch(Dispatchers.Default) { repeat(repeatCount) { synchronized(syncLock) { synchronizedCount++ } } } launch(Dispatchers.Default) { repeat(repeatCount) { synchronized(syncLock) { synchronizedCount++ } } } }.also { resultList.add(\"Synchronized\" to it / 1000000.0) } measureNanoTime { launch(Dispatchers.Default) { repeat(repeatCount) { withContext(singleThread) { singleThreadCount++ } } } launch(Dispatchers.Default) { repeat(repeatCount) { withContext(singleThread) { singleThreadCount++ } } } }.also { resultList.add(\"Single Thread\" to it / 1000000.0) } val actorCounter = counterActor() val response = CompletableDeferred&lt;Int&gt;() measureNanoTime { launch(Dispatchers.Default) { repeat(repeatCount) { actorCounter.send(Increment) } actorCounter.send(Result(response)) } launch(Dispatchers.Default) { repeat(repeatCount) { actorCounter.send(Increment) } actorCounter.send(Result(response)) } }.also { resultList.add(\"Actor\" to it / 1000000.0) } resultList.sortBy { it.second } resultList.forEach { println(\"${it.first} : ${it.second}ms\") } } 처리 방법 속도 Mutex 1.3443MS Actor 1.4192MS Synchronized 2.7625MS Single Thread 5.9151MS Atomic 13.4533MS",
    "tags": "Kotlin",
    "url": "/jekyll-theme-yat/kotlin/2023/07/14/Kotlin-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95.html"
  },{
    "title": "RecyclerView의 동작 로직에 대해 자세히 알아보기",
    "text": "RecyclerView의 기본적인 사용법을 알고 있다는 가정하에, RecyclerView의 동작 원리에 대해서 알아보겠습니다. RecyclerView의 핵심 클래스 RecyclerView 가장 중요한 클래스 ViewGroup을 상속받는다. 총 감독 역할을 한다. LayoutManager 레이아웃과 관련된 작업을 처리 Adapter 데이터를 관리하고 ViewHolder를 생성하고 Bind를 처리 CachedViews RecyclerView를 스크롤 할 때 가장 먼저 탐색하는 곳 onBindViewHolder() , onCreateViewHolder()를 사용할 필요없이 바로 보여줄 수 있는 View를 저장 Array로 관리되고, 크기를 개발자가 지정할 수 있다. RecycledViewPool Cache에 View가 없으면 그 다음에 탐색하는 곳 ViewHolder를 저장하고 있다. Scrap ItemView 레이아웃이 화면에 그려지는 동안 저장되는 목록 LayoutManager 보여줄 ItemView의 위치, 배치, 레이아웃과 관련된 작업을 처리합니다. 이미 구현된 클래스로 LinearLayoutManager, GridLayoutManager, StaggeredGridLayoutManager가 있습니다. List를 스크롤 할 때, RecyclerView에서 스크롤을 감지하고, LayoutManager에게 스크롤을 처리하라고 요청합니다. 처리 요청을 받으면, 새로운 ItemView의 표시 위치를 계산하고, RecyclerView에게 ItemView를 달라고 요청합니다. RecyclerView로 부터 ItemView를 받으면, 해당 ItemView를 표시합니다. ChildHelper 클래스를 사용하여 RecyclerView자체에 addView() , removeView()등의 작업을 처리합니다. Adapter ViewHolder, ItemView를 생성/관리, 이와 관련된 작업을 처리합니다. ViewHolder에 ItemView를 붙입니다. RecyclerView에 보여줄 데이터를 관리합니다. 사용자가 클릭하는 등의 이벤트를 처리합니다. CachedViews 재활용을 시도할때, 가장 먼저 탐색하는 곳입니다. ItemView가 저장되고, 이 곳의 View를 사용하면 onBindViewHolder() , onCreateViewHolder()를 사용할 필요없이 바로 보여줄 수 있습니다. Array로 관리되고, 크기를 개발자가 지정할 수 있습니다. RecycledViewPool CachedViews에 View가 없으면 그 다음에 탐색하는 곳입니다. ViewHolder가 저장되고, 이후 onBindViewHolder()를 사용하여 View를 생성합니다. Scrap ItemView 레이아웃이 화면에 그려지는 동안 저장되는 목록입니다. Dirty View RecycledViewPool에 존재하는 View를 Dirty View라고 합니다. View정보가 초기화되기 때문에, onBindViewHolder()를 사용하여 View를 생성해야 합니다. 기본 흐름",
    "tags": "Android",
    "url": "/jekyll-theme-yat/android/2023/07/09/RecyclerViewPool%EC%97%90-%EB%8C%80%ED%95%B4.html"
  },{
    "title": "Android Dialog Window 흐림 효과 적용하기",
    "text": "Window 흐림 효과 적용 전에, 흐림 효과 적용 가능 대상 종류를 알아봅시다. 두 가지 대상에 대하여 흐림 효과 적용이 가능합니다. Background blur 배경을 흐리게 합니다. Behind blur(Window blur) Window를 흐리게 합니다. Window(PhoneWindow) 화면에 출력되고 있는 View가 보여지는 영역입니다. Window는 DecorView를 가지고 있고, DecorView에 실제로 View가 그려지게 됩니다. Activity는 Window를 관리, Window는 DecorView를 관리, DecorView는 그려질 View(Statusbar, content,Navigationbar)를 관리합니다. 이 글에서는 Window 흐림 효과에 대해서 집중적으로 다룹니다. 한계점이 있기 때문입니다. Background blur Behind blur 모두 적용 &lt;img src=\"https://source.android.com/static/docs/core/display/images/background-blur-only.png\" width=\"auto\" height=\"auto\"&gt; &lt;img src=\"https://source.android.com/static/docs/core/display/images/blur-behind-only.png\" width=\"auto\" height=\"auto\"&gt; &lt;img src=\"https://source.android.com/static/docs/core/display/images/blur-behind-and-background-blur.png\" width=\"auto\" height=\"auto\"&gt; 흐림 효과 적용 방법 &lt;style name=\"BlurDialog\" parent=\"Theme.AppCompat.Dialog\"&gt; // behind blur &lt;item name=\"windowBlurBehindEnabled\"&gt;true&lt;/item&gt; // dp, px 등 단위를 사용하고, 흐림 강도를 설정합니다. 값이 클수록 흐림이 강해집니다. // 강도 조절은 Android 12 이상에서만 사용할 수 있습니다. &lt;item name=\"windowBlurBehindRadius\"&gt;10dp&lt;/item&gt; // background blur // dp, px 등 단위를 사용하고, 흐림 강도를 설정합니다. 값이 클수록 흐림이 강해집니다. &lt;item name=\"windowBackgroundBlurRadius\"&gt;10dp&lt;/item&gt; // 흐림 효과를 화면에서 보려면 true로 설정해야 합니다. &lt;item name=\"windowIsTranslucent\"&gt;true&lt;/item&gt; &lt;/style&gt; OR window.apply{ if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) { // behind blur // &lt;item name=\"windowBlurBehindEnabled\"&gt;true&lt;/item&gt; // API30에서 Undeprecated 되었는데, 공식 문서에는 Deprecated in API15로 표기되어 있습니다. addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND) // 아래와 같이 10만 입력하면 10px로 인식합니다. //item name=\"windowBlurBehindRadius\"&gt;10dp&lt;/item&gt; attributes.blurBehindRadius = 10 // background blur // &lt;item name=\"windowBackgroundBlurRadius\"&gt;10dp&lt;/item&gt; window.setBackgroundBlurRadius(10) // &lt;item name=\"windowIsTranslucent\"&gt;true&lt;/item&gt; XML파일에 적용해야 합니다. } } Window Blur 한계점 Window Blur의 강도 조절은 Android 12 이상에서만 사용할 수 있습니다. Android 11이하에서는 강도 조절 적용이 현재 API(Compat API도 없음)로는 불가능합니다. 기기에서 이 기능 사용이 내부적으로 비활성화 되어있으면, Window blur 적용 자체가 불가능합니다. 이러한 한계점을 극복하기 위한 방법을 연구중입니다 먼저 Window Blur가 적용되는 로직을 알아봅시다. Dialog에 Window blur가 적용 되는 로직 1. Dialog 객체의 create()호출 Dialog생성시 전달받은 context를 기반으로 PhoneWindow 인스턴스를 생성합니다. 인스턴스를 만들면서, DecorView가 생성됩니다. 2. Dialog의 show()호출 액티비티의 Window를 관리하는 WindowManager의 addView()를 호출합니다. 애플리케이션의 Window를 관리하는 WindowManagerGlobal의 addView() 호출하여, Window를 본격적으로 추가하고 그림을 그립니다. 3. Dimmer class 로 블러 효과 적용 액티비티 스레드에서 Window를 그려라는 명령을 받게 되면, WindowContainer객체에서 WindowLayoutParams의 값을 바탕으로 Window를 그립니다. Dimmer 클래스를 사용해서 Blurring 작업을 시작합니다. 안드로이드 native에서 OpenGL을 사용해서 Blurring 작업을 수행합니다. 완료되면 WindowContainer의 Surface에 그립니다. 안드로이드 12미만에서는 말했듯이 Window Blur를 적용할 수 없습니다. 그렇다면 Window Blur를 적용할 수 있는 방법은 없을까요? ViewRootImpl의 Surface를 받아서, Surface에 Blur를 적용하면 될 것 같습니다. 그러나 ViewRootImpl과 Surface를 직접받아서 로직을 제작하는 것은 불가능 한 것 같습니다. 구현 방법 Blur처리를 할 View의 ViewTreeObserver에 OnPreDrawListener를 등록합니다. 해당 View가 그려지기 전에 위 Listener가 호출됩니다. View가 다시 그려질 때 마다 호출됩니다. Blur처리된 Bitmap을 그려줄 View를 Dialog가 그려지는 Window에 추가합니다. GLSurfaceView를 사용합니다. OnPreDrawListener가 호출될 때 마다, 해당 View를 Bitmap으로 변환합니다. View.drawToBitmap()을 사용합니다. Bitmap을 Blur처리 합니다. RenderScript, Intrinsic Blur를 사용합니다. Blur처리된 Bitmap을 GLSurfaceView에서 그려주도록 합니다. GLSurfaceView의 Renderer를 구현합니다. onDrawFrame()에서 Blur처리된 Bitmap을 그려줍니다. 2~5번 과정이 계속 반복됩니다. RenderScript가 Android 12부터 Deprecated되었고, 대체하기 위해 Google에서 Toolkit을 제공합니다. 해당 Toolkit을 적용해보았으나, RenderScript보다 Blur를 처리하는데에 약 1.5배의 시간이 더 소요 되는 것을 확인하였습니다. 다른 StackBlur라는 알고리즘을 적용하는 등, 여러 방법을 시도해보았지만, RenderScript를 대체할만한 Blur처리 방법을 찾지 못하였습니다. Continue…",
    "tags": "Android",
    "url": "/jekyll-theme-yat/android/2023/07/01/Android-Dialog-%EB%B0%B0%EA%B2%BD-%ED%9D%90%EB%A6%BC-%ED%9A%A8%EA%B3%BC-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0.html"
  },{
    "title": "관계형 데이터베이스 설계",
    "text": "관계형 데이터베이스(RDB, Relational Database)란? 데이터를 테이블 형태로 저장하고 관리하는 데이터베이스이다. SQL != Database SQL과 Database는 다르다. SQL은 Database를 구현하는 언어이다. 설계 과정 요구사항 분석 시스템이 어떤 데이터를 관리하고, 어떤 연산을 수행해야 하는지 정의한다. 개념적 설계 개체-관계 모델을 이용해서 데이터와 데이터간의 관계를 설계한다. 개체-관계(Entity-Relation) 모델 : 데이터와 데이터 간의 관계를 개체와 관계로 설계한 것 논리적 설계 개념적 설계를 관계형 데이터베이스 스키마(Schema)를 만든다. 정규화를 통해 데이터의 중복을 최소화하는 등 설계를 최적화한다. 스키마 : 데이터베이스의 구조를 정의한 것 테이블, 속성, 키, 제약 조건 등 물리적 설계 스키마를 바탕으로 실제 데이터베이스를 구현한다. 정규화를 하기 전에 알아야 할 개념 함수적 종속성 정규화는 함수적 종속성을 제거하는 것이다. 슈퍼키(Super key) 테이블 내의 레코드(행, 튜플)을 유일하도록 식별할 수 있는 속성 또는 속성들의 집합 학번, 이름은 학생을 유일하게 식별할 수 있으므로 슈퍼키가 될 수 있다. 후보키(Candidate key) 슈퍼키에서 최소성(Minimality) 속성을 추가한 것 테이블에서 레코드를 유일하도록 식별할 수 있는 최소한의 속성 집합 학번, 이름에서 학번만으로도 학생을 유일하게 식별할 수 있으므로 후보키가 될 수 있다. 후보키 중에서 기본키를 선정한다. 후보키 ⊂ 슈퍼키 모든 후보키는 슈퍼키이다. 함수적 종속성(Functional Dependency) 한 속성의 값이 다른 속성의 값을 결정하는 관계, 즉 한 속성이 다른 속성에 종속되어 있음을 의미한다. Example, 학생 테이블 학번 이름 전공 학년 20190001 김이름 컴퓨터공학 2 20190002 름이김 컴퓨터공학 3 학번이 다른 속성인 이름, 전공, 학년을 고유한 값으로 결정한다. 이름, 전공, 학년은 학번에 종속된다. Trivial-FD(자명한 함수적 종속) A,B가 속성 집합 일때, A가 B에 종속적이고, B가 A에 포함되어 있거나 A와 B가 서로 같다면 Trivial-FD 라고 한다. 이러한 종속성은 모든 테이블에서 항상 성립한다. 학생 테이블에서, 학번, 이름 -&gt; 이름의 경우, 이름이 학번, 이름에 포함되어 있으므로 Trivial-FD이다. A set of FDs(SFD) 함수적 종속성의 집합 Example 학생 테이블에 대한 SFD 학번이 다른 속성을 결정하므로, 아래와 같이 나타낼 수 있다. 학번 -&gt; 이름 학번 -&gt; 전공 학번 -&gt; 학년 규범적 덮개(Canonical Cover, SFDc) SFD를 나타내는 최소한의 집합 SFD에 대한 규범적 덮개는 여러 개 일수 있다.(유일하지 않음) 조건 SFD+ = (SFDc)+ SFDc에 있는 함수적 종속에는 군더더기(잉여, Extraneous)속성이 없다. 잉여 속성 : 함수적 종속의 왼쪽 또는 오른쪽의 집합에서 없애도 SFD+가 변하지 않는 속성 학번 -&gt; 이름, 전공, 학년에서 학번이 잉여 속성이다. SFDc에 있는 함수적 종속의 왼쪽은 고유하다. a-&gt;b, c-&gt;d 와 같이 두 종속성이 존재하여, a=c가 되는 경우는 없다. 생성 과정 기본 키와 나머지 속성 집합으로 이루어지는 함수적 종속을 만든다. 반복 a-&gt;b, a-&gt;d와 같은 형태의 종속성을 a-&gt;bd로 바꾼다. 함수적 종속성에서 잉여 속성을 없앤다. 규범적 덮개가 변경되지 않을 때까지 2번 과정을 반복한다. 함수적 종속을 찾는 예제 수강 신청 DB 속성 학번(PK), 이름, 과목번호(PK), 과목이름, 연락처, 성적등급 함수적 종속 분석 FD1 : 학번, 과목번호 -&gt; 이름, 과목이름, 연락처, 성적등급 FD2 : 학번 -&gt; 이름, 연락처 FD1’ : 학번, 과목번호 -&gt; 과목이름, 성적등급 FD3 : 과목번호 -&gt; 과목이름 FD1’’ : 학번, 과목번호 -&gt; 성적등급 규범적 덮개로 정리 잉여 속성이 함수적 종속에 없으므로 FD1'', FD2, FD3 가 규범적 덮개이다. 온라인 쇼핑몰 DB 속성 주문번호(PK), 회원번호, 회원이름, 회원주소, 회원연락처, 상품번호, 상품이름, 주문개수, 배송연락처, 배송주소 함수적 종속 분석 FD1 : 주문번호 -&gt; 회원번호, 회원이름, 회원주소, 회원연락처, 상품번호, 상품이름, 주문개수, 배송연락처, 배송주소 FD2 : 회원번호 -&gt; 회원이름, 회원주소, 회원연락처 FD1’ : 주문번호 -&gt; 회원번호, 상품번호, 상품이름, 주문개수, 배송연락처, 배송주소 FD3 : 상품번호 -&gt; 상품이름 FD1’’ : 주문번호 -&gt; 회원번호, 상품번호, 주문개수, 배송연락처, 배송주소 규범적 덮개로 정리 잉여 속성이 함수적 종속에 없으므로 FD1'', FD2, FD3 가 규범적 덮개이다. 복수 전공 신청 DB 속성 학번, 학생이름, 학생연락처, 학생주소, 학과번호, 학과이름, 학과전화번호, 교수번호, 교수이름, 교수연락처 기본키 분석 학번, 학과번호, 교수번호 함수적 종속 FD1 : 학번 -&gt; 학과번호, 교수번호, 학생이름, 학생연락처, 학생주소, 학과이름, 학과전화번호, 교수이름, 교수연락처 FD2 : 학과번호 -&gt; 학과이름, 학과전화번호 FD1’ : 학번 -&gt; 학과번호, 교수번호, 학생이름, 학생연락처, 학생주소, 교수이름, 교수연락처 FD3 : 교수번호 -&gt; 교수이름, 교수연락처 FD1’’ : 학번 -&gt; 학과번호, 교수번호, 학생이름, 학생연락처, 학생주소 규범적 덮개로 정리 잉여 속성이 함수적 종속에 없으므로 FD1'', FD2, FD3 가 규범적 덮개이다. 정규화(Normalization) 데이터베이스의 데이터 중복을 최소화 하여, insert, update, delete 등의 연산을 할 때에 발생 가능한 문제를 줄인다. 종류 제 1정규형 (1NF) 제 2정규형 (2NF) : 1형 만족 제 3정규형 (3NF) : 1, 2형 만족 Boyce-codd 정규형 (BCNF) : 1, 2, 3형 만족 제 4정규형 (4NF) : 1형 만족 제 5정규형 (5NF) : 1, 4형 만족 학습에 사용할 Example, 주문목록 제품번호 제품명 재고수량 주문번호 고객번호 주소 주문수량 1001 모니터 2000 A345, D347 100, 200 서울, 부산 150, 300 1007 마우스 9000 A210, A345, B230 300, 100, 200 광주, 서울, 부산 600, 400, 700 1201 키보드 2100 D347 200 부산 300 제 1정규형(1NF) 테이블의 모든 속성이 원자 값(더 이상 분해할 수 없는 단일 값)을 갖도록 하는 정규형이다. 즉, 각 테이블의 각 열이 단일 값을 가져야 하며, 또한 각각의 행이 고유한 키로 식별될 수 있어야 한다. 위의 주문목록 테이블은 1NF를 만족하지 않는다. 속성에 대한 값이 2개 이상인 레코드(행, 튜플)가 존재하기 때문이다. 1NF를 만족하도록 테이블을 분리 2개의 기본키에 대한 테이블로 분리한다. 제품 제품번호 제품명 재고수량 1001 모니터 2000 1007 마우스 9000 1201 키보드 2100 제품 주문 주문번호 제품번호 고객번호 주소 주문수량 A345 1001 100 서울 150 D347 1001 100 부산 300 A210 1007 300 광주 600 A345 1007 100 서울 400 B230 1007 200 부산 700 D347 1201 200 부산 300 제 2정규형(2NF) 제1정규형을 만족하면서, 기본키가 아닌 모든 열이 기본키에 완전 함수적으로 종속되는 정규형이다. 즉, 테이블의 기본키를 제외한 나머지 속성이 각각의 행에 대해 유일한 값을 갖는 기본키에 대해 완전하게 종속되어야 한다. 부분 함수적 종속성이 없어야 한다. 위의 제품 테이블은 2NF를 만족한다. 제품번호가 다른 속성들을 결정하므로, 부분 함수적 종속이 없기 때문이다. 위의 제품 주문 테이블은 2NF를 만족하지 않는다. FD1 : 주문번호, 제품번호 -&gt; 고객번호, 주소, 주문수량 FD1의 부분 함수적 종속인, 주문번호 -&gt; 고객번호, 주소 가 존재하기 때문이다. 2NF를 만족하도록 테이블을 분리 부분 함수적 종속을 없앤다. 주문 목록 주문번호 제품번호 주문수량 A345 1001 150 D347 1001 300 A210 1007 600 A345 1007 400 B230 1007 700 D347 1201 300 주문 주문번호 고객번호 주소 A345 100 서울 D347 100 부산 A210 300 광주 A345 100 서울 제 3정규형(3NF) 제2정규형을 만족하면서, 기본키가 아닌 모든 칼럼이 기본키에 대해 이행적 함수 종속을 갖지 않는 정규형이다. 이는 비 Key속성 사이에 서로 종속적인 관계가 없음을 의미한다. 즉, 속성이 A -&gt; B, B -&gt; C 일 때, A -&gt; C 가 성립하는 속성이 없어야 한다. 위의 제품, 주문 목록 테이블은 3NF를 만족한다. 기본키가 다른 속성들을 결정하고, 이행적 함수 종속이 없기 때문이다. 주문 테이블은 3NF를 만족하지 않는다. FD1 : 주문번호 -&gt; 고객번호, 주소 FD2 : 고객번호 -&gt; 주소 FD2에 의하여, 주문번호 -&gt; 주소와 같은 이행적 함수 종속이 존재하기 때문이다. 3NF를 만족하도록 테이블을 분리 이행적 함수 종속을 없앤다. 모든 함수적 종속에서 불필요한 속성을 제거한다. FD1 : 주문번호 -&gt; 고객번호 FD2 : 고객번호 -&gt; 주소 주문 주문번호 고객번호 A345 100 D347 100 A210 300 A345 100 고객 고객번호 주소 100 서울 200 부산 300 광주 Boyce-Codd 정규형(BCNF) 제3정규형을 만족하면서, 각 결정자가 후보키의 부분집합이 되는 정규형이다. 3NF보다 더 엄격한 조건을 설정하여, 데이터 중복을 더욱 줄이는 데에 초점을 맞춘다. 즉, 테이블에서 모든 결정자가 후보키이다. 결정자 함수적 종속성을 가지는 속성 or 속성 집합 후보키 테이블 내의 각 행을 고유하게 식별하는 속성 or 속성 집합 BCNF를 만족하려면, 함수적 종속성에서 왼쪽에 있는 모든 결정자가 후보키를 구성해야 한다. Example, 수강 교수 학번 과목명 담당교수 981746 데이터베이스 김교수 981747 네트워크 박교수 981748 인공지능 이교수 981749 데이터베이스 김교수 981747 데이터베이스 서교수 981749 네트워크 박교수 부분/이행적 함수적 종속이 없으므로, 3NF를 만족한다. FD1 : 학번, 과목명 -&gt; 담당교수 FD2 : 담당교수 -&gt; 과목명 BCNF는 만족하지 않는다. FD2에서, 담당교수는 후보키가 아니기 때문이다. BCNF를 만족하도록 테이블을 분리 모든 결정자가 후보키가 되도록 테이블을 분리한다. FD2 : 담당교수 -&gt; 과목명 을 만족시키기 위해, 담당교수를 기본키로 하는 테이블을 생성한다. 수강 학번 담당교수 981746 김교수 981747 박교수 981748 이교수 981749 김교수 981747 서교수 981749 박교수 교수 담당교수 과목명 김교수 데이터베이스 박교수 네트워크 이교수 인공지능 서교수 데이터베이스 제 4정규형(4NF) 1NF를 만족하면서, 테이블에 다중값 상속(Multi Valued Dependency)으로 A -&gt; B가 존재할 경우, 테이블의 모든 속성이 A에 함수적 종속성을 가진다. 제 5정규형(5NF) 테이블의 모든 조인 종속이 테이블의 후보키를 통해서만 성립되는 정규형이다. 거의 사용되지 않는다. 역 정규화(Denormalization) 과도한 정규화로 인해 성능이 떨어지는 경우, 분리한 테이블을 다시 합치는 방법이다. 정규화 예제 수강, 학생 속성 학번(PK), 과목번호(PK), 과목이름, 학과번호, 이름, 집전화 SFD FD1 : 학번, 과목번호 -&gt; 과목이름, 학과번호, 이름, 집전화 FD2 : 학번 -&gt; 학과번호, 이름, 집전화 FD1’ : 학번, 과목번호 -&gt; 과목이름, 학과번호 FD3 : 과목번호 -&gt; 과목이름 FD1’’ : 학번, 과목번호 -&gt; 학과번호 1NF 만족 모든 속성은 원자값을 가진다. 2NF 만족 부분 함수적 종속이 없다. 3NF 만족 이행적 함수적 종속이 없다. BCNF 만족 모든 결정자가 후보키이다. 쇼핑몰 회원 속성 회원번호(PK), 회원이름, 생년월일, 주소, 전화번호, 주민등록번호(CK), 가입일, 회원구분 SFD FD1 : 회원번호 -&gt; 회원이름, 생년월일, 주소, 전화번호, 주민등록번호, 가입일, 회원구분 FD2 : 주민등록번호 -&gt; 회원번호 BCNF 만족 쇼핑몰 주문 속성 주문번호, 주문상세번호(PK), 회원번호(FK), 상품번호(FK), 주문일, 배송주소, 배송연락처, 개수 SFD FD1 : 주문상세번호 -&gt; 주문번호, 회원번호, 상품번호, 주문일, 배송주소, 배송연락처, 개수 FD2 : 주문번호 -&gt; 회원번호, 주문일, 배송주소, 배송연락처 FD1’ : 주문상세번호 -&gt; 주문번호, 상품번호, 개수 설계 예제 아래의 조건대로 설계를 해봅시다. 주제 : 회사 내부 직원 정보 관리 요구 사항 직원 구분을 위해 직원번호를 고유하게 부여한다. 직원 정보 : 이름, 주소, 연락처, 입사연도 직원은 하나의 부서에 소속된다. 부서 구분을 위해 부서번호를 고유하게 부여한다. 부서 정보 : 부서명, 대표전화번호, 사무실번호, 직무내역 1. 개념적 설계 두 개의 개체(Entity)가 있다 직원과 부서 이 두 개체는 아래와 같은 속성을 가진다. 직원 이름(PK), 주소, 연락처, 입사연도, 부서번호(FK) 부서 부서번호(PK), 부서명, 대표전화번호, 사무실번호, 직무내역 직원과 부서 사이에는 N:1 관계가 존재한다. 여러 직원이 한 부서에 소속이 된다는 의미이다. 2. 논리적 설계 스키마 직원 이름(PK), 주소, 연락처, 입사연도, 부서번호(FK) 부서 부서번호(PK), 부서명, 대표전화번호, 사무실번호, 직무내역 위 스키마는 BCNF를 만족한다. 이제 다음 단계는 SQL로 실제 데이터베이스 구축을 하는 것이다.",
    "tags": "Database",
    "url": "/jekyll-theme-yat/database/2023/06/20/%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B8%B0.html"
  },{
    "title": "순열, 조합 by Kotlin",
    "text": "순열, 조합 순열(Permutation) 순서가 중요한 경우 nPr = n! / (n-r)! (n : 전체 개수, r : 뽑을 개수) 조합(Combination) 순서가 중요하지 않은 경우 nCr = n! / r! * (n-r)! 비교 5명 중에서 3명을 뽑는 경우 순열 3명을 1,2,3 등 순서대로 뽑는 경우 5P3 = 5! / (5-3)! = 60 조합 3명을 순서 상관없이 뽑는 경우 5C3 = 5! / 3! * (5-3)! = 10 순열 구현 // Collection&lt;T&gt;에 순열 함수 P를 추가 internal inline infix fun &lt;reified T : Any&gt; Collection&lt;T&gt;.P(r: Int): List&lt;List&lt;T&gt;&gt; = toMutableList().permutations(0, r) // 원소 리스트를 순열 함수에 넘김 // 실제 순열을 구하는 함수 private fun &lt;T : Any&gt; MutableList&lt;T&gt;.permutations(depth: Int, r: Int): List&lt;List&lt;T&gt;&gt; = if (depth == r) { listOf(subList(0, r).toList()) // 원하는 길이 r만큼의 부분 리스트 생성 } else { val permutations = mutableListOf&lt;List&lt;T&gt;&gt;() // 결과를 저장할 리스트 for (i in depth until size) { swap(i, depth) // i와 depth 위치의 원소를 바꿈 permutations.addAll(permutations(depth + 1, r)) // 재귀 호출로 순열 계산 swap(i, depth) // 원래의 상태로 복귀 } permutations // 순열 결과 반환 } // 리스트 내의 두 원소의 위치를 바꾸는 함수 private fun &lt;T : Any&gt; MutableList&lt;T&gt;.swap(i: Int, j: Int) { val temp = this[i] // 임시 변수에 i 위치의 원소를 저장 this[i] = this[j] // j 위치의 원소를 i 위치로 이동 this[j] = temp // 임시 변수에 저장한 원소를 j 위치로 이동 } 조합 구현 // Collection&lt;T&gt;에 조합 함수 C를 추가 internal inline infix fun &lt;reified T : Any&gt; Collection&lt;T&gt;.C(r: Int): List&lt;List&lt;T&gt;&gt; = toMutableList().combinations(BooleanArray(size), 0, r) // 원소 리스트를 조합 함수에 넘김 // 실제 조합을 구하는 함수 private fun &lt;T : Any&gt; MutableList&lt;T&gt;.combinations(visited: BooleanArray, start: Int, r: Int): List&lt;List&lt;T&gt;&gt; = if (r == 0) { listOf(filterIndexed { index, _ -&gt; visited[index] }) // 선택된 원소만을 가진 리스트 생성 } else { val combinations = mutableListOf&lt;List&lt;T&gt;&gt;() // 결과를 저장할 리스트 for (i in start until size) { visited[i] = true // 원소를 선택함을 표시 combinations.addAll(combinations(visited, i + 1, r - 1)) // 재귀 호출로 조합 계산 visited[i] = false // 원소 선택 해제 } combinations // 조합 결과 반환 } 결과 fun main() { val list = listOf(\"A\", \"B\", \"C\") // 원소 리스트 생성 val permutations = list P 2 // 순열 계산 val combinations = list C 2 // 조합 계산 println(permutations) // 순열 출력 // [[A, B], [A, C], [B, A], [B, C], [C, B], [C, A]] println(combinations) // 조합 출력 // [[A, B], [A, C], [B, C]] }",
    "tags": "Kotlin",
    "url": "/jekyll-theme-yat/kotlin/2023/06/18/%EC%88%9C%EC%97%B4,%EC%A1%B0%ED%95%A9%EC%9D%84-Kotlin%EC%9C%BC%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0.html"
  },{
    "title": "Compiler backend",
    "text": "컴파일러 프론트엔드와 백엔드의 명백한 차이 프론트엔드 프로그래밍 언어에 의존적 목표 기계에 비 의존적 백엔드 언어에 다소 비 의존적 IR은 언어에 의존적 목표 기계에 의존적 백엔드의 구성 Instruction selection IR을 어셈블리 코드로 변환 고정된 스토리지 매핑 및 코드 모양을 추정 주소 지정 모드를 사용하여 작업을 결합 Instruction scheduling 연산을 정렬하여 지연 시간을 줄임 고정된 프로그램을 추정 레지스터에 대한 요구를 변경 Register allocation 레지스터에 상주할 값을 결정 스토리지 매핑을 변경 데이터 및 메모리 작업 배치에 대한 우려 백엔드의 처리 로직은 NP-Complete 문제로, 최적의 로직이 아닐 수도 있다. Code shape 성능에 영향을 미치는 코드의 모든 모호한 속성 알고리즘 선택과 결과에 영향을 준다. 같은 결과를 만드는 것에 대해서는 다양한 구현이 가능하고, 최적의 형태는 코드의 문맥에 의존한다. Example case 문에 대한 처리를 하는 경우 if-then-else 성능은 case의 개수에 의존적 O(number of cases) jump table 상수 시간에 처리 binary search O(log n) case 에 따른 분기 처리는 다양한 방법이 있고, 컴파일러는 최적의 방법을 선택해야 한다. Code shape에 신경을 써야하는 이유 최적화 및 코드 생성을 돕기 위해 컴파일러의 개별 패스가 빠르게 실행되어야 하므로 유용한 정보를 IR에 인코딩하기 위해 표현식 또는 제어 구조의 모양 메모리가 아닌 레지스터에 보관되는 값 가능한 경우 이러한 정보를 도출하는 데 비용이 많이 들 수 있음 IR에 명시적으로 기록하는 것이 더 쉽고 저렴할 때가 많음 Code shape를 IR에 기록하는 방법 Instruction selection 수행 이전에 High-level IR을 Low-level IR로 변환한다. Low-level Representation Instrinsic operations AST String 끝에 null을 추가하여 구분 길이를 명시하여 구분 Structures 속성의 선언 순으로 구분 속성의 자료형 순서로 구분 A : [ (1,1),(1,2),(1,3),(1,4), (2,1),(2,2),(2,3),(2,4) ] Arrays Row major 대부분의 언어에서 채택 연속 행의 시퀀스로 배치 가장 오른쪽 아래 첨자가 가장 빠르게 변함 A : [ (1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4) ] Column major Fortran에서 채택 열 시퀀스로 배치 가장 왼쪽 위 첨자가 가장 빠르게 변함 Cache miss가 많이 발생 A : [ (1,1),(2,1),(1,2),(2,2),(1,3),(2,3),(1,4),(2,4) ] Loops Loop는 IR에서 명시적으로 표현되지 않는다. it-then-else 구조로 표현됨 Switches Linear search 등의 방법으로 재 구성됨 Instruction selection 기본 접근법 각 IR 튜플/하위 트리를 기계 명령어로 매크로 확장 때때로 매핑은 N:1임 maximal munch RISC와 합리적으로 잘 작동 다른 접근법 IR이 확장될 때 대상 머신 상태를 모델링 한다. 해석 코드를 생성하는 것 Tuple을 읽는다 해석기 상태를 갱신한다 대상 코드를 만든다 Tree patterns 각 기계의 명령어를 IR tree의 조각으로 표현하는 것 Instruction selection은 tree patterns의 최소한의 집합을 가지는 Tiling IR tree를 의미한다. Tiling Target machine이 지원하는 명령어, tree를 생성하므로 해당 기계에 의존적이다. 목표 tiles 오버래핑이 없도록 IR tree를 보호하는 것 Optimal tiling Greedy Tree의 루트에서 시작 가장 큰 tile을 찾는다 서브 트리를 모두 순회한다 Dynamic programming 모든 트리 노드에 비용을 할당한다 각 노드에 가장 적합한 tiling의 명령어 비용 집합을 계산한다 Code generation 컨셉 Topological sort 모든 피연산자가 수행 전에 준비되도록 한다. tree IRs 에 대해 코드를 생성하는 방법 Sethi-Ullman Numbering 레지스터가 최소한으로 사용되도록 한다. Code generation for DAGs Register and temporary management 임시적으로 현재 수행과 연관된 데이터를 저장한다. (레지스터, 스택 등) Register allocation Hard registers(Physical registers) 일부는 스토리지에 할당되어야 한다. 각 임시 레지스터에 대하여 Pseudo-register(Virtual registers)를 추정한다. Register를 사용하는 것 자체가 최적화를 하는 것이다. Sethi-Ullman Numbering Numbering 레지스터를 최소한으로 사용하기 위한 과정 Spiling 없는 서브 트리를 평가하기 위해 필요한 레지스터들을 계산한다. 번호로 각 내부 노드에 레이블을 지정한다. Code generation 트리를 순회하고 코드를 생성한다. 라벨에 따라 순서를 평가함 특징 간단한 기계 모델에 최적화 되어 있다. 레지스터와 명령어를 줄인다. 실제 기계 모델 최적화를 위해서는 동작이 지연되는 아키텍처는 매우 복잡하며 아래의 문제를 고려해야 한다. Issue LOAD, 결과가 나중에 지연 주기로 나타난다. 결과가 참조되지 않는 한 계속 실행된다. 너무 이른 참조로 인해 HW정지가 발생하거나 컴파일러가 지연 슬롯을 NOPs로 채울 수 있다. Code generation for DAGs Tree보다 더 복잡하다. 사용할 모든 코드가 생성되기 전 까지 공유 값을 가지고 있는다. 레지스터 사용을 최소화하기 어렵게 만든다. 좌측 피연산자는 보통 제거되고, 공유는 사용하기 전에 왼쪽 피연산자를 강제로 복사한다. 최적화 코드 생성기는 복사를 최소화하기 위해 DAG 평가를 정렬해야 한다. 피연산자가 마지막으로 사용될 때 왼쪽 피연산자로 사용되도록 DAG 평가를 정렬한다. 과정 Schedule Allocate virtual registers Map virtual registers to hard registers Local optimization Data-flow 분석없이, 해석을 기본 블럭으로 제한한다. 어떻게 컴파일러가 기본 블록에 대해서 최적화를 하는 가? 불필요한 수행을 참조로 교체한다. 일반 목적 코드를 구체화한다. 사용되지 않는 코드를 제거한다. 다른 기회를 노출시킴. Peephole optimization A small window (2-3 tuples/instruction) 특징 코드에 대한 peephole을 분석한다. 특별한 패턴을 찾아서 최적화를 한다. Examples Constant folding Strength reduction Null sequence Combine operations Data-flow analysis 정적 코드만 검사하여 프로그램의 동적 동작에 대한 정보를 도출한다. 불필요한 계산을 제거하거나, 코드의 실행 로직을 단순화하는 등 최적화 수행에 필요한 정보를 분석한다. Liveness analysis 컴파일러는 임시 레지스터에 대해 Liveness analysis 를 수행해야 한다. 어떤 변수가 프로그램에서 사용되지 않는다면, 메모리를 회수하여 최적화 한다. 나중에 사용되는 레지스터가 값을 가지고 있으면, Live 상태이다. 특징 Register allocation Virtual to Physical Problem IR는 무제한으로 임시 레지스터를 가진다. 기계는 제한적인 수의 레지스터를 가진다 Approach 분리된 live 범위가 있는 임시는 동일한 레지스터에 매핑될 수 있다. 충분한 레지스터가 없으면, 임시로 저장된다. 컴파일러는 이 프로세스를 자동화해야 한다. Example int func(int b, int c) { int a = 0; do { b = a + 1; c = c + b; a = b * 2; } while(a &lt; 9); return c; } a = 0 L1 : b = a + 1 c = c + b a = b * 2 if a &lt; 9 goto L1 return c Live range of a 1 -&gt; 2 again 4 -&gt; 5 -&gt; 2 dead 2 -&gt; 3 -&gt; 4 Live range of b 2 -&gt; 3 -&gt; 4 Control flow analysis Liveness analysis 수행 전에, CFG를 만드는 Control flow를 이해해야 한다. 노드는 독립적인 프로그램 문장이나 기본 블록이다. 에지는 잠재적인 Control flow이다. Example of CFG a = 0 L1 : b = a + 1 c = c + b a = b * 2 if a &lt; 9 goto L1 return c 노드 n으로 부터 나오는 에지는 후속 노드인 succ[n]로 이어진다. 노드 n에 대한 in 에지는 이전 노드인 pred[n]에서 나온다. Out-edges of node 5 5 -&gt; 2 5 -&gt; 6 succ[5] {2, 6} pred[5] {4} pred[2] {1, 5} Dominance CFG의 형태와 구조를 추론하는 핵심 도구는 지배자(Dominanace) 개념이다. 노드 b0이 있는 흐름 그래프에서, 노드 bi는 b0에서 bj까지의 모든 경로에 있는 경우 노드 bj를 지배한다. Liveness analysis Liveness information을 모으는 것은 CFG에 대한 data flow analysis를 수행하는 것과 같다. def def(v) v를 정의하는 노드 def(n) n으로 정의되는 변수 use use(v) v를 사용하는 노드 use(n) n에서 사용하는 변수 Performance consideration Basic blocks single predecessor/successor를 가지는 노드를 합쳐서 Basic block으로 만들어 CFG의 크기를 줄인다. One variables at a time 모든 변수에 대해서 data flow analysis를 수행하는 것보다, 하나의 변수에 대해서 단순화한 분석을 하는 것이 더 낫다. Representation of sets For dense sets 정수형 배열에서 1인 비트를 원소로 간주하는 경우에 사용한다. 쓰이지 않는 0이 저장되므로 메모리 사용에서 비효율적이다. For sparse sets 원소가 존재하는 메모리 위치를 저장하므로, 메모리 사용량이 적다. Basic blocks 입구와 출구 외에는 분기가 없는 코드 시퀀스이다. Basic blocks를 나누는 과정 코드에서 핵심이 되는 리드 요소를 파악한다. 첫번째 명령어 분기의 대상 분기를 즉시 따르는 명령어 다음 리드 요소를 제외하고 현재 리드를 따르는 모든 명령어를 포함하는 block을 분리한다. Example a = 0 L1 : b = a + 1 c = c + b a = b * 2 if a &lt; 9 goto L1 return c leader(case) 1, 2, 6 Splitted result(Basic blocks) a = 0 L1 : b = a + 1, c = c + b, a = b * 2, if a &lt; 9 goto L1 return c Register allocation N개의 레지스터에 대한 정확한 코드를 생성한다. live 레지스터의 재사용을 최대화한다. load, store 를 최소화한다. Spill 을 최소화한다, save a stack space Register allocation 과정 N register code -&gt; Register allocation -&gt; K register code liveness analysis로 부터 interference graph(간섭 그래프, IG)를 생성한다. IG 에 대한 k-coloring을 분석한다. 또는 코드를 k-color가 될수 있는 문제에 근접하도록 바꾼다. 각 k-colored 변수(임시 레지스터)를 k registers로 매핑한다. Graph coloring problem 그래프는 동일한 에지를 공유하는 두 노드가 동일한 색상을 갖지 않는 색상으로 그래프의 노드에 레이블을 지정하는 경우에만 k-colorable이 가능하다.(한 에지에 연결된 노드는 서로 다른 색상을 가져야 한다) 각 색상은 고유한 논리 레지스터에 매핑된다. IG 노드는 변수를 나타낸다. 에지는 변수가 동일한 레지스터에 할당될 수 없음을 나타낸다. IG의 k-coloring은 k 레지스터 할당으로 매핑될 수 있다. 이웃이 k개 미만인 정점 v는 항상 색상이 지정될 수 있다. 레지스터 할당 문제를 해결하는 방법 Chaitin’s algorithm Chaitin-Briggs algorithm Chaitin’s algorithm IG 생성 노드 제거 이웃이 k개 미만인 노드를 제거하고, 스택에 추가한다. IG에서 이러한 노드가 완전히 사라질때 까지 작업을 반복한다. 스킬링 k보다 많은 이웃을 가진 노드를 제거한다. 레지스터 할당 스택에서 노드를 꺼내면서 레지스터를 할당(색을 입힘)한다. 색은 다른 노드에 할당되지 않은 색이어야 한다. Improvement of Color scheme 모든 정점이 최소 k개의 이웃을 가질 때 멈추는 것 보다, 우선 순위에 따라 스택에 추가하는 것이 더 낫다. 간단한 레지스터 할당 방식 Build Simplify Spill Select Finish Instruction selection 고려 사항 실행 시간을 줄이기 위해 명령어 순서 재조정 정확성을 유지하면서 성능 향상 최적화 스케줄링 방식 동적 정적 Hazard in pipeline Structural hazard 하드웨어 자원이 충분하지 않은 경우 Data hazard 피연산자는 이전 명령어에 의존함 Control hazard 조건 분기 프로세서 수행 과정 Fetch Decode Fetch Execute Store Next Multi-cycle design 장단점 장점 사이클 시간을 줄인다 프로세스가 파이프라이닝하는 것이 가능함 단점 단계 사이에서 데이터를 저장할 때 추가적인 레지스터가 필요하다 HW 설계가 복잡해진다 Pipelining 수행 시 여러 명령어가 동시에 실행되도록 해주는 기술 장점 기능 단위의 사용을 더욱 향상시킨다. 단점 HW 성능 요구가 더 높다. hazard를 발생시킨다. Hazards Structural hazard HW자원의 충돌 두 명령어가 동시에 같은 자원을 사용하려고 할 때 발생 Data hazard 데이터 의존성 한 명령어가 다른 명령어의 결과에 의존하는 경우 Control hazard 분기 명령어와 같은 제어 명령어로 인해 파이프라인의 흐름이 변경되는 경우에 발생 분기 명령어가 실행되어야 다음에 어떤 명령어가 실행될 지 결정되기 때문이다. Instruction scheduling slow code -&gt; Scheduler -&gt; fast code 특징 올바른 코드를 만든다. 불필요한 사이클을 줄인다. Avoid spill registers Spill register : 변수의 값을 메모리로 옮기는 작업이 일어나는 레지스터, 레지스터 공간이 부족한 경우에 Spilling이 발생한다. 작동 효율성 향상 To capture properties of the code, build a precedence graph G. instruction -&gt; node dependency -&gt; edge Data dependencies 의존성은 아래의 두 조건을 만족할 때에 나타난다. 두 메모리 참조가 같은 위치에 접근할 때 최소한 하나의 메모리 참조가 쓰기를 수행할 때 종류 RAW : read after write True dependence 지울수 없다 WAR : write after read Anti dependence 변수명 변경으로 제거 가능 WAW : write after write Output dependence 변수명 변경으로 제거 가능 RAR : read after read Input dependence 의존성이 없다 이러한 위험 중 일부를 제거하기 위해 컴파일러를 제한할 수 있지만 이러한 위험은 자주 발생하며 하드웨어에서 문제를 해결하는 것이 좋다. NOP : 목적지에 의존성이 없는 것을 load delay slot에 채운다. 여전히 미세한 최적화를 위해서는 컴파일러가 지연 동작을 고려해야 한다. 파이프라인 스케줄링 또는 명령어 스케줄링은 컴파일러가 stall을 피하기 위해 명령어를 재 배치하는 방법이다. Instruction scheduling(Scope) Basic blocks List scheduling trace로 바꾼다 Branches Trace scheduling control hazard를 줄이기 위해, superblock인 trace scheduling을 이용한다. Loops Unrolling Software pipelining List scheduling RAW/WAW를 없애기 위해 이름을 바꾼다. 우선 Graph를 만든다. 명령어에 우선순위를 부여한다. select와 명령어 스케줄링을 반복한다. Candidates : Roots of graph, 실행 가능한 명령어들 Candidates가 남아있을때 최고 우선순위 후보를 선택한다. 명령어를 스케줄링 한다. 노출된 명령어를 후보에 추가한다. Two flavors of list scheduling Forward Backward 스케줄링 휴리스틱 고려사항 준비된 명령어들 중 얼마나 선택해야 하는가? NP-hard for straight-line code 후보의 우선 순위를 설정하는 방법 pipeline stall을 발생시키지 않는다. 루트까지의 가장 큰 가중치인 경로(critical path) 가장 긴 지연시간(more overlap) Most immediate successors(후보를 만듦) Most descendants(후보를 더 만듦) Trace scheduling Parallelism across if branches trace selection trace compaction Optimization 잠재적으로 컴파일 시 최적화 가능한 영역 Source language(AST) Constant bounds in loops and arrays Loop unrolling Suppressing runtime check Enable later optimizations IR : Local and Global CSE Liveness analysis Code hoisting Enable later optimizations Code generation(machine code) Register allocation Instruction scheduling Peephole optimization Classical Distinction 머신 ‘비의존적’ 변환 광범위한 머신에 적용 가능 중복 계산 제거 쓸모없는 코드 찾아 제거 실행 빈도가 낮은 곳으로 더 많은 평가 수행 일부 범용 코드 전문화 다른 최적화를 위한 기회 노출 머신 ‘의존적’ 변환 머신별 속성 활용 IR에서 머신으로의 매핑 개선 비용이 많이 드는 작업을 더 저렴한 작업으로 대체 명령어 시퀀스를 더 강력한 것으로 대체 Scope of Optimization Local Intraprocedural(global) Interprocedural(whole program) 최적화 시 핵심 목표 Safety Profitability Opportunity Safety 최적화 시에 발생한 변화가 프로그램의 실행 결과를 바꾸지 않는다는 것을 보장하는 것이 중요 컴파일 시 분석 Loop unrolling 대부분의 경우에 안전함 DAGs and CSEs 간단한 분석이다 Dataflow analysis 복잡한 추론이 필요할 수 있다 Profitability 최적화를 통해 프로그램의 실행 속도가 빨라지는 것을 보장하는 것이 중요 컴파일 시 추정 Always profitable Heuristic rules Compute benefit Opportunity 최적화를 해야 하는 적절한 지점을 찾는 것이 중요 Issues 변환을 적용하는 프레임워크를 제공 체계적으로 모든 지점을 찾기 이전 변경 사항을 반영하도록 안전 정보를 업데이트 하기 Loop unrolling Safety Always safe Loop interchange/unrolling/fusion?? Profitability Reduce overhead Machine-dependent Opportunity Loops Find memory-bound loop nests Hoisting loop-invariant Loop invariant Expressions constant with loop body Relevant variables Those used to compute an expression Opportunity Identity variables defined in body of loop Loop invariants have no relevant variables in LoopDef Assign each loop-invariant to temporary in loop header Use temporary in loop body Safety Faults in loop-invariant expression may be triggered earlier Profitability Loop may execute 0 times Loop-invariant may not be needed on every path through loop body",
    "tags": "Compiler",
    "url": "/jekyll-theme-yat/compiler/2023/06/16/Code-shape-&-Instruction-selection.html"
  },{
    "title": "데이터 통신 정리",
    "text": "11장 - DataLinkControl HDLC Frame Flag 앞/뒤에 위치 Address Control Information 서로 간의 프로토콜을 정의하기 위해 사용 user information, management information Fcs CRC Frame 종류 Information 실제 데이터를 전송 Supervisory 데이터 전송 중에 오류가 발생했을 때, 재전송을 요청하는 프레임 Unnumbered 다양한 제어, 관리 기능 수행 Bit oriented 방식 Bit stuffing 방식 사용 Support Connection PPP Frame Flag Address Control Protocol Payload(Information) Fcs HDLC의 파생 프로토콜이다. 제공되지 않는 기능 Flow Control 아주 간단한 수준의 Error Control만 가능 Byte oriented 방식 Byte stuffing 방식 사용 인증 기능 제공 PAP, CHAP IPCP, LCP, NCP 등의 프로토콜은 Payload영역에 위치시킨다. 12장 - Media Access Control Multiple Access Protocols Random Access ALOHA Pure, Slotted CSMA CSMA/CD Controlled Access Reservation Polling Token Passing Channelization FDMA TDMA CDMA ALOHA 프레임이 충돌하는 경우가 발생한다. Persistence Methods 1-persistent 채널이 사용 가능할 때까지 계속해서 전송을 시도한다. Non-persistent 랜덤하게 감시한다. 가장 좋은 성능 P-persistent 확률적으로 감시한다. CSMA/CD 반송파 감지를 하면서 충돌을 감지하는 기법 여러 Persistence 방법을 사용한다. 아래와 같은 문제점 때문에 무선랜으로 사용이 불가능하다. Hidden station 두 노드가 같은 전파 범위내에 있지 않은 경우, 서로 감지를 할 수 없는 문제가 발생한다. 두 노드가 서로 데이터를 전송하는 경우, 충돌이 발생한다. Collision detection 노드가 데이터를 송신하는 동안 수신과 충돌을 동시에 처리할 수 없다. Signal attenuation CSMA/CA로 해결한다. CSMA/CA 아래의 개념들을 사용하여 충돌 문제를 해결한다. IFS 노드 또는 프레임의 우선 순위를 결정한다. RTS(Request To Send) 수신 노드에게 데이터 전송 준비가 되었음을 알린다. CTS(Clear To Send) RTS를 받은 노드가 데이터를 전송하라고 알린다. NAV(Network Allocation Vector) 노드가 다음 데이터를 전송하기 까지 대기하는 시간 DIFS(Distributed Interframe Space) 노드가 채널 사용이 가능한지 확인하기 위해 대기하는 시간 SIFS(Short Interframe Space) 두 프레임 사이의 최소 대기 시간 Reservation 노드는 데이터를 보내기 전에 슬롯을 예약하여야 한다. Polling HDLC에서 사용한다. 중앙 제어 장치에 의존적이다. 이 장치에 문제가 생기면 전체 네트워크가 중단된다. Token Passing 네트워크 상의 노드들은 Token을 통해 서로 통신을 한다. FDMA 각 노드는 서로 다른 주파수 대역을 할당받는다. 충돌 문제 없다. TDMA 각 노드는 서로 다른 시간 슬롯을 할당받는다. 동기화가 필요하다. CDMA 각 노드는 고유의 코드를 할당받는다. 이 코드를 통해 모든 노드가 같은 주파수 대역을 공유할 수 있다. 복잡한 동기화가 필요하다. 13장 - Wired LANs : Ethernet Ethernet A LAN standard Token Ring Token Bus FDDI ATM LAN Ethernet Frame Preamble 7 bytes Sfd(Start Frame Delimiter) 1 byte Destination address 6 bytes Source address 6 bytes Length or Type 2 bytes Data and Padding 46 ~ 1500 bytes CRC-32 4 bytes 1500 bytes 이하의 데이터를 전송한다. 고속 이더넷 100 Mbps, 1 Gbps 동일한 프레임 포맷과 주소 길이 사용 Auto negotiation 속도, 전이중/반이중, 흐름 제어 등을 자동으로 설정 14장 - Other Wired Networks ADSL 비대칭 디지털 가입자 회선 전화선으로 이더넷을 사용한다. 다운로드의 대역폭이 훨씬 크다. Splitter에서 음성과 데이터 신호를 분리한다. 15장 - Wireless LANs 무선랜의 특징 감쇠 간섭 다중 경로 전파 전파 반사로 인해 다양한 경로가 생성된다. 오류",
    "tags": "Data communication Data communication",
    "url": "/jekyll-theme-yat/data/communication/2023/06/14/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%86%B5%EC%8B%A0-%EC%A0%95%EB%A6%AC.html"
  },{
    "title": "15. Wireless LANs",
    "text": "Wireless LANs Wireless Ethernet CSMA/CA Personal area network(PAN) Bluetooth Architecture Comparison Medium Hosts Isolated LANs Connection to Other Networks 특징 감쇠 간섭 다중 경로 전파 전파 반사로 인해 매우 다양한 경로가 만들어 진다. 오류 Access Control CSMA/CD는 무선랜으로 동작하지 않는다. 충돌 탐지 문제 노드가 데이터를 송신하는 동안 다른 노드의 데이터 전송과 충돌을 탐지하는 것이 어렵다. Hidden station 문제 두 노드가 같은 전파 범위 내에 있지 않는 경우, 노드 간에 감지를 할 수 없는 문제가 발생한다. 두 노드가 동시에 데이터를 보내게 되어, 충돌이 발생한다. 신호 약화 문제 이러한 문제를 극복하기 위해, CSMA/CA를 사용한다. 충돌을 피하기 위해 3-way handshake방식을 채택 802.11 MAC Layers 802.11 standard MAC Sublayer 분산 조정 기능(DCF) CSMA/CA 포인트 조정 기능(PCF) in an infrastructure network not in an ad hoc network CSMA/CA and NAV hidden station이 있는 경우, 충돌 감지가 불가능하다. Point Coordination Function Frame format Hidden station problem 802.11 Series Bluetooth Piconet 또는 Small net이라고 불린다. Scatternet 하나의 Piconet 내의 보조 스테이션이 다른 Piconet의 주요 스테이션이 될 수 있다. Bluetooth layers Baseband Layer Baseband layer는 LAN의 MAC sublayer와 유사하다. 접근 메서드는 TDMA이다. 625us의 슬롯으로 나누어진다. 스테이션들은 서로 타임 슬롯을 통해서 통신한다.",
    "tags": "Data communication Data communication",
    "url": "/jekyll-theme-yat/data/communication/2023/06/13/Wireless-LANs.html"
  },{
    "title": "13. Wired LANs Ethernet",
    "text": "Ethernet Wired LAN Token Bus Token Ring FDDI ATM LAN Standard Ethernet Connectionless and Unreliable Service Frame format preamble 7 bytes 0101… start frame delimiter(sfd) 1 byte 10101011 destination address 6 bytes source address 6 bytes type upper layer protocol data 46 ~ 1500 bytes crc-32 46~1500 bytes 전송 가능하다. 1 bytes만 전송하려면, 45 bytes의 fake data를 포함해야 한다. Addressing Network interface card(NIC) address Unicast, Multicast, Broadcast addresses Broadcast : 48 1s unicast이면 0을, multicast이면 1을 사용한다. Categories of Standard Ethernet 뒤에가 숫자이면, 동축 케이블이다. Changes in the Standard Bridged Ethernet Switched Ethernet Full-duplex Ethernet Bridged Ethernet Separating collision domains Bridge로 인해 Collision domain이 2개로 나눠진다. Switched Ethernet Separating collision domains completely Full-duplex Ethernet No need for CSMA/CD Fast Ethernet 100 Mbps 이더넷 48비트 주소 같은 프레임 포맷 Autonegotiation 서로 동작 속도가 다른 연결이 있을 경우 맞춰서 하향 조정한다. Gigabit Ethernet 1 Gbps 이더넷 48비트 주소 같은 프레임 포맷 최소/최대 프레임 길이 유지 Autonegotiation",
    "tags": "Data communication Data communication",
    "url": "/jekyll-theme-yat/data/communication/2023/06/13/Wired-LANs-Ethernet.html"
  },{
    "title": "16. Other Wireless Networks",
    "text": "Cellular Telephone Networks Cellular Telephony는 두 움직이는 객체 간에 통신을 지원하기 위해 설계되었다. Mobile stations 이라고 한다. 주파수 재사용 원칙 전송 수신 Handoff 로밍 Generation 1G 2G 3G 4G 이동 수단에 100Mbps, 정지 수단에 1Gbps의 속도를 제공한다. 자연스러운 Handoff 5G 일반적인 인터넷 서비스에 대해 10Gbps의 속도를 제공한다. Satellite Networks",
    "tags": "Data communication Data communication",
    "url": "/jekyll-theme-yat/data/communication/2023/06/13/Other-Wireless-Networks.html"
  },{
    "title": "14. Other Wired Networks",
    "text": "Telephone Networks Major components Local loops Trunks Switching offices Local-access transport areas (LATAs) ADSL(Asummetrc Digital Subscriber Line) Cable networks Hybrid Fiber Coaxial (HFC) Cable TV for Data Transfer CM and CMTS",
    "tags": "Data communication Data communication",
    "url": "/jekyll-theme-yat/data/communication/2023/06/13/Other-Wired-Networks.html"
  },{
    "title": "12. Media Access Control",
    "text": "MAC Data link layer Data link control Multiple-access resolution Multiple Access Protocols Multiple Access Protocols Channelization(Partitioning) TDMA FDMA CDMA Random access ALOHA CSMA CSMA/CD CSMA/CA Controlled-access Reservation Polling Token passing Random-access 다른 스테이션보다 앞서는 스테이션이 없고, 모든 스테이션이 같다. ALOHA 라디오에 적합하게 설계되었다. ALOHA Pure ALOHA Slotted ALOHA Pure ALOHA 프레임이 충돌하는 시점이 발생한다. Slotted ALOHA CSMA(Carrier Sense Multiple Access) 지연이 발생한다. 통신하는 선의 길이가 제한적이다. vulnerable time이 발생한다. Persistence Methods 1-persistent method 지속적으로 감시 이더넷에서 사용 non-persistent method 랜덤하게 감시 감지하고 대기 가장 뛰어난 성능 p-persistent method 확률적으로 감시 CSMA/CD(Carrier Sense Multiple Access with Collision Detection) 최소/최대 길이가 제한적이다. 충돌 시 고전압을 발생시켜서 알린다. 에너지 레벨 변화 1-persistent 50% non-persistent up to 90% CSMA/CA(Carrier Sense Multiple Access with Collision Avoidance) 무선에서 사용한다. IFS 스테이션 또는 프레임의 우선순위를 결정 RTS(Request to Send) 수신 노드에게 데이터 전송 준비 완료를 알리는 신호 CTS(Clear to Send) 수신 노드가 RTS를 받고 데이터 전송을 수락하는 신호 송신 노드에게 전달 NAV(Network Allocation Vector) 노드가 다음 프레임을 전송하기 까지 기다려야 하는 시간 RTS CTS에 포함되어 있다 DIFS(Distributed Interframe Space) 노드가 채널이 사용 가능한지 확인하기 위해 기다려야 하는 시간 SIFS(Short Interframe Space) 두 프레임 사이의 최소 대기 시간 특정 프레임을 수신한 후 다음 프레임을 전송하기 전에 기다려야 하는 시간 위와 같은 개념들을 사용하여, 충돌을 방지한다. RTS가 성공해야 CTS가 성공한다. SIFS, DIFS의 간격은 우선순위를 나타낸다. Controlled-access Reservation 데이터를 보내기 전에 노드는 먼저 슬롯을 예약한다. 각 간격에서 예약 프레임은 해당 간격에서 전송된 데이터 프레임보다 우선시 된다. 충돌 없음 Polling HDLC에서 사용 중앙 제어 장치에 의존적, 이 장치에 문제가 생기면 전체 네트워크가 중단된다. 충돌 없음 Token passing 네트워크 상의 노드들은 논리적인 Ring을 형성한다. Token을 돌리면서 통신을 한다. Token이 손실되면, 네트워크가 중단될 수 있다. 충돌 없음 Channelization 여러 노드가 동시에 채널을 공유할 수 있다. FDMA(Frequency Division Multiple Access) 전체 주파수 대역을 노드 별로 나눠서 사용한다. 간단, 각 노드가 독립적으로 통신 가능 주파수 대역을 효율적으로 사용하기가 어렵다 TDMA(Time Division Multiple Access) 각 노드에게 시간 슬롯을 할당한다. 할당받은 시간 슬롯만큼만 통신이 가능하다. 주파수 대역을 효율적으로 사용할 수 있다. 동기화가 필요하다. CDMA(Code Division Multiple Access) 각 노드에게 고유한 코드를 할당한다. 이 코드를 사용하여 모든 노드가 동시에 같은 주파수 대역을 공유할 수 있다. 주파수 대역을 효율적으로 사용할 수 있다. 복잡한 동기화가 필요",
    "tags": "Data communication Data communication",
    "url": "/jekyll-theme-yat/data/communication/2023/06/13/Media-Access-Control.html"
  },{
    "title": "11. Data Link Control",
    "text": "DLC Services Framing Flow Control Error Control Framing Character-Oriented Framing 데이터를 구별하기 위해 flag를 앞 뒤에 추가한다. 데이터 안에 flag패턴이 포함되어 있으면, 혼동이 생기므로, 데이터 내에 추가적인 패턴을 삽입하여 구분하게 된다. 이를 byte stuffing이라고 한다. Header에 검증을 위한 데이터를 추가한다. 아스키 코드 전달이 목적 최근에는 잘 사용되지 않는다. Bit-Oriented Framing 비트 단위로 데이터를 구별하기 위해 flag를 사용한다. Character 방식과 마찬가지로 flag와 같은 패턴이 데이터에 나타날 수 있으므로, Bit stuffing/unstuffing 기법을 사용한다. Flow Control Buffers Flow와 Error Control을 같이 진행하면 더 효율적이다. 프레임을 전송하기 위해 메모리 버퍼에 저장한다. 수신 측에서도 버퍼에 저장한다. 송수신 간의 통신 속도 차이 때문에 흐름 제어가 필요하다. 송신 측은 수신 측의 상태를 고려하여 데이터를 전송한다. 헤더에 ACK를 추가하여 흐름 제어를 한다. 헤더의 내용이 중요하다. Error Control Error Detection 프레임이 손상된 경우, 그 프레임을 버린다. 손상되지 않은 경우, ACK를 보낸다. Connectionless &amp; Connection-Oriented protocol Connectionless 데이터를 전송하기 전에, 연결을 설정하지 않는다. 신속한 데이터 처리에 목적 데이터 순서 유지 보장이 없다. UDP Connection-Oriented(연결 지향적) 장거리 통신시 사용 데이터 전송의 신뢰성을 보장. TCP Data Link Layer Protocols 표현 방법 Finite state machine Flow Diagram 종류(For Noisy Channel) Stop-and-Wait Slide Window Go-Back-N Selective Repeat Stop-and-Wait 송신 측 네트워크 계층에서 패킷을 수신 프레임 생성 복사하고 저장 프레임 전송 타이머 시작하고 Blocking 모드로 전환 ACK를 기다린다. 정상적인 ACK를 받으면 타이머를 멈추고, 저장한 프레임을 제거한 뒤 다음 프레임을 보낸다. 오류있는 ACK를 받으면 버린다. 타임 아웃될 때 까지 ACK를 받지 못하면 프레임을 재 전송한다. 수신 측 프레임을 받으면 ACK를 보낸다. 이미 받은 프레임이 중복되어 오면 그 프레임은 버린다. 이 경우에도 ACK는 보낸다. 단점 처리 속도가 느리다 한 프레임씩 전송하기 때문에 효율이 떨어진다. 전송의 성공 여부를 타이머에 의존한다. 개선 방법 : Pipelining Pipelining 보낼 프레임이 있으면 계속 보내는 방법. 송신 중에 오류가 발생하면 대처가 어렵다. 개선 방법 : Slide Window Slide Window Go-Back-N Window Size &lt;= 2^m - 1 Sequence number bits = 2 pipelining을 하고 오류 처리를 개선한다. 송신 측 Window Size만큼 데이터를 전송한다. ACK를 받으면 Window를 이동시킨다. ACK를 받지 못하면 Window의 시작부터 다시 전송한다. ACK를 받지 못하면 타이머가 만료되면 Window의 시작부터 다시 전송한다. Selective Repeat Window Size &lt;= 2^m - 1 NAK를 사용한다. NAK 1 : 1번 프레임을 재전송하라 HDLC(High-Level Data Link Control) Support Connection 데이터를 전송하기 전에 전처리 과정을 거친다. NRM 일반적인 전송 모드 데이터 순서가 유지된다. 하나의 주요 스테이션과 여러 개의 보조 스테이션으로 구성된다. ABM 비동기 전송 모드 데이터를 동시에 전송 가능 데이터 순서가 보장되지 않음. P2P HDLC파생 프로토콜 SDLC PPP HDLC Frame flag 01111110 address byte or multi-byte control information 서로 간에 프로토콜의 정하기 위해 사용 User information Management information FCS(Frame Check Sequence) CRC bit stuffing 방식을 사용한다. Frame 종류 I : 정보 프레임 실제 데이터를 전송 데이터 순서를 유지하기 위해 관리 S : 감독 프레임 흐름 제어, 오류 복구 I-Frame에 대한 응답으로 사용 정보 전송은 하지 않음 U : 비정보 프레임 다양한 제어, 관리 기능 각 프레임 별 Control field I S ready, reject, etc… U 세션 관리, 제어 정보 Unnumbered frames PPP(Point-to-Point Protocol) 다중 네트워크 계층 프로토콜이다. Internet, OSI, Xerox, AppleTalk, DECnet, IPX/SPX 등을 지원한다. Service Format of the frame 링크를 수립하고 데이터를 교환한다 몇몇 네트워크 계층으로 부터의 데이터를 허용 인증 Multilink PPP 제공 되지 않음 Flow control Error control에 대한 아주 간단한 방법만 제공 PPP frame format flag protocol payload 데이터가 포함된다 fcs byte stuffing을 사용한다. escape byte는 01111101 이다. address, control field는 실제로 사용되지 않는다. address의 값이 1이면, 브로드 캐스트 전송을 한다. Multiplexing in PPP PPP는 여러 개의 네트워크 계층 프로토콜을 지원한다. LCP 패킷은 프레임의 payload에 포함된다. 프로토콜 값은 0xC021이다. IPCP역시 마찬가지이다. IPCP는 NCP에 종속되므로 프로토콜 값이 0x8021이다. 인증 프로토콜 PAP(Password Authentication Protocol) ID, Password를 전송한다. 보안에 취약하다. CHAP(Challenge Handshake Authentication Protocol) Three way handshake Challenge &amp; Response 정리 DataLink Layers Protocols   Stop-And-Wait Go-Back-N Selective Repeat 통신 속도 느림 빠름 빠름 재전송 프레임 개수 1 N 1, 손상된 프레임만 재전송 동작 방식 프레임 하나씩 처리, ACK를 받아야 다음 프레임 전송 Window Size만큼 프레임을 보내고, 특정 프레임이 손상되어 ACK를 받지 못하면, 그 프레임부터 다시 재전송 Window Size만큼 프레임을 보내고, 손상된 프레임에 대해서만 재전송, ACK를 받지 못한 프레임만 재전송 한다 HDLC, PPP 프레임 비교   HDLC PPP 프레임 종류 I, S, U  ",
    "tags": "Data communication Data communication",
    "url": "/jekyll-theme-yat/data/communication/2023/06/13/Data-Link-Control.html"
  },{
    "title": "17. Connecting Devices and Virtual LANs",
    "text": "Connecting Devices 5 Categories of Connecting Devices Repeater LAN의 연장선 역할을 한다. 데이터를 받아 증폭하여 다시 전송한다. Link Layer Switches(Switch, Bridge) Filtering 스위치는 필터링 테이블을 가짐. Transparent Switches 프레임은 스테이션 간에 전송된다. 포워딩 테이블은 프레임의 움직임을 파악하여 자동적으로 네트워크 상에서 생성된다. 시스템에서 반복은 발생하지 말아야 한다. A learning bridge and the process of learning Loop problem in a learning bridge Backbone networks Virtual LANs A switch connecting three LANs",
    "tags": "Data communication Data communication",
    "url": "/jekyll-theme-yat/data/communication/2023/06/13/Connecting-Devices-and-Virtual-LANs.html"
  },{
    "title": "Android 커스텀 레이아웃으로 앱 위젯 만들기",
    "text": "App Widgets 이란? 아래 사진과 같이 런처 앱에서 설치된 앱의 기능을 사용할 수 있도록 해줍니다. Widget을 만드는 방법 아래의 안드로이드 공식 문서를 통해 기본적인 제작 방법을 학습할 수 있습니다. Create app widget - Android developers App widget processing flow 앱 위젯을 처리하는 흐름 핵심 BroadcastReceiver로 위젯 업데이트 처리 RemoteViews로 위젯 UI를 처리 위젯 제작 과정 아래는 예시 입니다. 전체 예제 코드 res 디렉토리 내에 위젯 관련 파일을 담을 적절한 디렉토리를 만듭니다. res/layout 디렉토리 내에 위젯 레이아웃 파일view_widget을 만들고 레이아웃을 제작합니다. 만든 디렉토리 내에 nine-widget-info.xml라는 이름의 리소스 파일을 만들고 아래와 같이 작성합니다. &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\" android:configure=\"com.lifedawn.bestweather.widget.ConfigureWidgetActivity\" // 위젯을 런처에 생성하고자 할때 사용하는 위젯 설정 화면, 생성이 필수는 아님 android:initialLayout=\"@layout/view_widget\" // 위젯 레이아웃 android:minWidth=\"@dimen/ninthWidgetWidth\" android:minHeight=\"@dimen/ninthWidgetHeight\" android:minResizeWidth=\"@dimen/ninthWidgetWidth\" android:minResizeHeight=\"@dimen/ninthWidgetHeight\" android:previewImage=\"@drawable/widget_preview_9\" // 런처 앱에서 위젯 추가 시 나오는 이미지 android:resizeMode=\"vertical|horizontal\" // 위젯 크기 조정 가능한 모드, 수평/수직 모두 조정 할 수 있도록 하겠다는 의미 android:updatePeriodMillis=\"0\" // 위젯 업데이트 주기, 0이면 자동 업데이트 하지 않고 수동 업데이트로만 가능 android:widgetCategory=\"home_screen\" // 홈 화면에 위젯을 보여준다는 의미, 안드로이드 5 부터는 이것만 가능 /&gt; 위젯 업데이트와 같은 처리는 BroadcastReceiver를 통해서 진행하기 때문에 관련 로직을 처리할 NinthWidgetProvider 클래스를 만들고 내용을 작성합니다. AndroidManifest.xml내 application태그 내에 앱 위젯 내용을 추가합니다. &lt;receiver android:name=\".widget.widgetprovider.NinthWidgetProvider\" android:exported=\"true\" android:label=\"@string/ninthWidgetLabel\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" /&gt; // 필수 &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; &lt;action android:name=\"android.intent.action.MY_PACKAGE_REPLACED\" /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=\"android.appwidget.provider\" // 필수 android:resource=\"@xml/ninth_widget_info\" /&gt; &lt;/receiver&gt; 완료 위젯을 런처 앱에 추가하는 경우에 사용자가 위젯에 대해 부가적인 설정이 가능하도록 하고자 하는 경우에는 위의 ConfigureWidgetActivity를 생성하면 됩니다. 런처 앱에서 위젯 추가 버튼을 클릭시 이 액티비티가 나오고 관련 설정이 가능해집니다. 위젯 레이아웃 제작의 한계점 앱 위젯은 해당 앱이 다른 프로세스인 런처 앱 상에서 RemoteViews라는 View로 원격으로 레이아웃을 보여주는 방식이기 때문에, 개발자가 원하는 대로 레이아웃을 제작하는 것이 어렵다는 한계점이 있습니다. 앱 위젯에 사용 가능한 레이아웃 및 위젯 AdapterViewFlipper FrameLayout GridLayout GridView LinearLayout ListView RelativeLayout StackView ViewFlipper AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextClock TextView 안드로이드 12 부터 가능 CheckBox RadioButton RadioGroup Switch 한계점을 벗어나, 원하는 레이아웃을 제작하는 방법 RemoteViews에서 사용가능한 위젯과 레이아웃으로는 아래의 위젯 제작이 매우 어렵습니다. Bitmap으로 만들어 ImageView에 지정하여 해결 작업 과정 동적으로 레이아웃 제작 RelativeLayout생성 최상위 view LinearLayout생성 RelativeLayout의 자식 View 시간, 날씨 아이콘(맑음, 비 등)의 정보 표시 nine-widget-info.xml에서 설정했던 위젯의 width, height정보를 pixel 값으로 변환 최상위 view의 width, height를 변환한 pixel 값으로 설정 Bitmap viewBmp = rootLayout.getDrawingCache() remoteViews.setImageViewBitmap(R.id.bitmapValuesView, viewBmp); 완료 결과 아래의 사진은 ImageView를 사용하여 만든 위젯과, RemoteViews에서 사용가능한 뷰와 레이아웃으로 만든 위젯의 레이아웃 계층도를 보여줍니다. Bitmap으로 처리한 위젯이 제대로 동작하고 있는 것을 확인할 수 있습니다.",
    "tags": "Android",
    "url": "/jekyll-theme-yat/android/2023/05/31/Android-%EC%BB%A4%EC%8A%A4%ED%85%80-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83%EC%9C%BC%EB%A1%9C-%EC%95%B1-%EC%9C%84%EC%A0%AF-%EB%A7%8C%EB%93%A4%EA%B8%B0.html"
  },{
    "title": "Navigation Component DeepLink로 이동시 Arguments 전달 편의성 개선하기",
    "text": "구현 목적 DeepLink 사용 시에도 Action으로 이동할 때 Arguments를 전달하는 것처럼 구현 하고자 합니다. 먼저 DeepLink와 Action으로 Arguments를 전달하는 방법을 알아봅시다. 각각의 Arguments 전달 방법 Action으로 Arguments 전달 XML 네비게이션 파일에 Argument를 선언하거나, 동적으로 Arguments를 선언하는 방법이 있습니다. // nav.xml 에서, 전달할 Arguments를 아래와 같이 정의해야 합니다. &lt;argument android:name=\"name\" android:defaultValue=\"이름\"/&gt; &lt;argument android:name=\"age\" android:defaultValue=\"나이\"/&gt; // 출발 Fragment에서 val name = \"이름\" val age = \"5\" val action = StartFragmentDirections.userInfoAction(name, age) v.findNavController().navigate(action) // 도착 Fragment에서 val args: userInfoFragmentArgs by navArgs() DeepLink로 Arguments 전달하는 방법 // nav.xml 에서, 전달할 Arguments를 아래와 같이 정의해야 합니다. &lt;argument android:name=\"name\" android:defaultValue=\"이름\"/&gt; &lt;argument android:name=\"age\" android:defaultValue=\"나이\"/&gt; &lt;deepLink app:uri=\"appname://app/user/userinfo?name={name}&amp;age={age}\" /&gt; // 출발 Fragment에서 val name = \"이름\" val age = \"5\" \"appname://app/user/userinfo?name=$name&amp;age=$age\".toUri() // 도착 Fragment에서 val args: userInfoFragmentArgs by navArgs() DeepLink로 이동할 때는 “appname://app/user/userinfo”.toUri() 를 사용해서 URI를 따라서 이동합니다. 이를 통해 도착 Fragment에 Arguments를 보내려면, “appname://app/user/userinfo?name=name_data&amp;age=age_data”.toUri() 과 같이 URI에 데이터를 직접 입력해서 전달해야 합니다.(UriBuilder를 통해서 Query를 입력해서 하는 방법도 있습니다) 구현한 기능으로 DeepLink Arguments 전달 시에는 URI에 위와 같이 작성할 필요 없음 “appname://app/user/userinfo” 만 작성하면 됩니다 nav.xml에 Argument를 선언할 필요없음 BaseNavArgs를 상속받는 data class를 만들기만 하면됩니다. data class를 만들면 동적으로 nav.xml에 Argument를 추가합니다. 구현 과정 1. androidx.navigation.safeargs 동작 분석 safeargs의 내부 로직을 살펴보던 중, 도착 프래그먼트에서 by navArgs로 Arguments를 처리할 때 fromBundle() static 메서드를 호출하여 Argument 객체에 담아 반환하는 로직을 발견하였다. fromBundle()을 내부적으로 사용할때 이 메서드는 NavArgs 인터페이스를 구현하는 클래스의 static 메서드 여야 하는 것을 파악하였고, 이 두 조건을 만족하는 추상 클래스를 생성하였다. abstract class BaseNavArgs( val className: String ) : NavArgs { @Suppress(\"CAST_NEVER_SUCCEEDS\") fun toBundle(): Bundle { val result = Bundle() toMap().forEach { (key, value) -&gt; result.putString(key, value) } return result } companion object { @JvmStatic fun fromBundle(bundle: Bundle): BaseNavArgs { // BaseNavArgs를 구현한 class를 className 문자열을 바탕으로 만든다. val kClass: KClass&lt;BaseNavArgs&gt; = Class.forName(bundle.getString(\"className\")!!).kotlin as KClass&lt;BaseNavArgs&gt; bundle.classLoader = kClass.java.classLoader // 생성한 class의 생성자를 가져온다. val constructor = kClass.primaryConstructor!! // bundle의 value를 읽는다. val args = constructor.parameters.map { parameter -&gt; bundle.getString(parameter.name, \"\") } // 읽은 value를 생성자에 담아서 class instance를 만든다. return constructor.call(*args.toTypedArray()) } } fun toMap(): Map&lt;String, String&gt; = this::class.memberProperties.let { properties -&gt; properties.associate { property -&gt; property.name to property.getter.call(this).toString() }.toMap() } } toMap() 메서드는 BaseNavArgs를 구현하는 객체의 속성 값(Arguments)을 Map으로 반환하는 메서드이다. 2. 동적으로 Argument 생성하고, URI를 생성 위 BaseNavArgs를 구현하는 data class를 바탕으로 동적으로 Argument를 생성한다. navigateByDeepLink(deepLinkUrl: String, parameter: BaseNavArgs) DeepLink룰 사용할 때, 해당 URI가 선언된 NavGraph에 동적으로 Arguments를 추가 @param deepLinkUrl DeepLink Url @param parameter DeepLink에 들어갈 파라미터, BaseNavArgs를 구현한 클래스 객체 fun NavController.navigateByDeepLink(deepLinkUrl: String, parameter: BaseNavArgs) { val parameterMap = parameter.toMap() toDeepUrl(deepLinkUrl, parameterMap).also { finalUri -&gt; graph.matchDeepLink(NavDeepLinkRequest(finalUri, null, null))?.also { deepLinkMatch -&gt; parameterMap.takeIf { it.isNotEmpty() }?.forEach { (key, value) -&gt; deepLinkMatch.destination.addArgument( key, NavArgument.Builder().setType(NavType.StringType).setIsNullable(false).setDefaultValue(value).build() ) } } } this.navigate(deepLinkUrl.toUri()) } 아래의 toDeepUri()를 사용하여 URI를 생성한다. 동적으로 생성된 Arguments를 appname://app/user/userinfo?name=name_data&amp;age=age_data과 같이 GET URI로 만든다. Map을 메서드의 매개변수로 받아서 Map의 key, value를 URI에 추가한다. /** * Uri Builder * * Uri를 생성하는 함수입니다. * * @param parameter Uri에 들어갈 파라미터 * @return Uri */ private fun toDeepUrl(deepLinkUrl: String, parameter: Map&lt;String, String&gt;): Uri = StringBuilder(deepLinkUrl).let { uri -&gt; parameter.takeIf { it.isNotEmpty() }?.also { map -&gt; uri.append(\"?\") map.onEachIndexed { index, entry -&gt; uri.append(\"${entry.key}=${entry.value}\") if (index != map.size - 1) uri.append(\"&amp;\") } } uri.toString().toUri() } 사용 방법 1. 전달할 Arguments data class 생성 /** * 유저 정보 프래그먼트로 전달할 인자 * * @property name 이름 * @property age 나이 */ data class UserInfoFragmentArgs( val name: String, val age: String ) : BaseNavArgs(UserInfoFragmentArgs::class.java.name) 주의사항 상속받는 data class를 만들었을때 BaseNavArgs 의 생성자에 UserInfoFragmentArgs::class.java.name 과 같이 data class의 클래스 명을 전달해야 합니다. val 과 NonNull로 속성을 만들어야 합니다. 이 부분이 상당한 제약 사항인데 추후 로직을 더 개선해서 업데이트 할 예정입니다. 2. navigateByDeepLink() 사용 // 출발 Fragment에서 activity?.findNavController(com.android.appname.core.common.R.id.fragmentContainerView)? .navigateByDeepLink( \"appname://app/user/userinfo\", UserInfoFragmentArgs( name = userInfoDto.name, age = userInfoDto.age ) ) // 도착 Fragment에서 val args: userInfoFragmentArgs by navArgs()",
    "tags": "Android Navigation",
    "url": "/jekyll-theme-yat/navigation/2023/05/23/%EB%84%A4%EB%B9%84%EA%B2%8C%EC%9D%B4%EC%85%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%94%A5%EB%A7%81%ED%81%AC-%EC%82%AC%EC%9A%A9%EC%84%B1-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0.html"
  },{
    "title": "Android Compose 첫 도입 후기",
    "text": "먼저, 코드를 보면 전체적인 구조가 기존 View와는 상당히 다른 것을 알 수 있습니다. 대한민국 식약처가 제약사에 대해 회수/폐기와 행정 처분을 내린 목록을 표시하는 화면입니다. 예제 코드 클래스 구성 NewsFragment 뉴스 화면을 표시할 메인 Fragment NewsScreen 위 Fragment에 나타나는 Compose 기반 뉴스 화면 RecallSuspensionScreen 회수 폐기 목록 화면 RecallSuspensionViewModel 위 화면에서 쓰이는 ViewModel View위에서도 Compose를 사용할 수 있습니다! How to use Compose in XML layout in Android NewsScreen /** * 뉴스 타입 */ enum class ChipType { RECALLS_SUSPENSION, ADMIN_ACTION } /** * 뉴스 화면 */ @Preview @Composable fun NewsScreen() { var selectedChip by remember { mutableStateOf(ChipType.RECALLS_SUSPENSION) } Column { Text( text = stringResource(id = com.android.mediproject.core.ui.R.string.news), style = MaterialTheme.typography.headlineMedium, modifier = Modifier.padding(top = 16.dp, start = 24.dp, end = 24.dp) ) ChipGroup(selectedChip, onChipSelected = { chip -&gt; selectedChip = chip }) if (selectedChip == ChipType.RECALLS_SUSPENSION) RecallDisposalScreen() else Text(text = \"AdminAction\") } } /** * 뉴스 타입 선택 * * @param selectedChip 선택된 뉴스 타입 * @param onChipSelected 뉴스 타입 선택 시 호출되는 콜백 */ @Composable fun ChipGroup(selectedChip: ChipType, onChipSelected: (ChipType) -&gt; Unit) { Row( verticalAlignment = Alignment.CenterVertically, modifier = Modifier.padding(top = 16.dp, bottom = 8.dp, start = 24.dp, end = 24.dp) ) { CustomFilterChip( title = stringResource(id = R.string.recallSuspension), isSelected = selectedChip == ChipType.RECALLS_SUSPENSION, type = ChipType.RECALLS_SUSPENSION ) { onChipSelected(if (selectedChip == ChipType.RECALLS_SUSPENSION) ChipType.RECALLS_SUSPENSION else ChipType.ADMIN_ACTION) } Spacer(Modifier.width(8.dp)) CustomFilterChip( title = stringResource(id = R.string.adminAction), isSelected = selectedChip == ChipType.ADMIN_ACTION, type = ChipType.ADMIN_ACTION ) { onChipSelected(if (selectedChip == ChipType.RECALLS_SUSPENSION) ChipType.RECALLS_SUSPENSION else ChipType.ADMIN_ACTION) } } } /** * 뉴스 타입 Chip */ @OptIn(ExperimentalMaterial3Api::class) @Composable fun CustomFilterChip(type: ChipType, title: String, isSelected: Boolean, onClick: (ChipType) -&gt; Unit) { FilterChip( selected = isSelected, onClick = { onClick.invoke(type) }, label = { Text(title, fontSize = 13.sp) }, shape = RoundedCornerShape(36.dp), colors = FilterChipDefaults.filterChipColors( selectedContainerColor = Color.Blue, selectedLabelColor = Color.White, disabledContainerColor = Color.White, disabledLabelColor = Color.Blue ), ) } NewsFragment NewsFragment.kt @AndroidEntryPoint class NewsFragment : BaseFragment&lt;FragmentNewsBinding, NewsViewModel&gt;(FragmentNewsBinding::inflate) { override val fragmentViewModel: NewsViewModel by viewModels() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) binding.apply { lifecycleOwner = viewLifecycleOwner composeView.setContent { NewsScreen() } } } } RecallSuspensionScreen 회수 폐기 chip클릭 시 나오는 화면 RecallSuspensionScreen.kt /** * 회수 폐기 목록 표시 */ @Preview @Composable fun RecallDisposalScreen(viewModel: RecallSuspensionViewModel = hiltViewModel()) { val list = viewModel.recallDisposalList.collectAsLazyPagingItems() LazyColumn(modifier = Modifier.fillMaxWidth()) { items( count = list.itemCount, key = list.itemKey(), contentType = list.itemContentType( ) ) { index -&gt; list[index]?.let { ListItem(it) } if (index &lt; list.itemCount - 1) Divider(modifier = Modifier.padding(horizontal = 24.dp)) } when (list.loadState.append) { is LoadState.NotLoading -&gt; Unit is LoadState.Loading -&gt; { item { Column(horizontalAlignment = Alignment.CenterHorizontally) { CircularProgressIndicator() } } } is LoadState.Error -&gt; TODO() else -&gt; TODO() } } } /** * 회수 폐기 목록 아이템 * * @param recallSuspensionListItemDto 회수 폐기 목록 아이템 */ @OptIn(ExperimentalMaterial3Api::class) @Composable fun ListItem(recallSuspensionListItemDto: RecallSuspensionListItemDto) { Surface( modifier = Modifier .fillMaxWidth() .padding(horizontal = 24.dp, vertical = 9.dp), shape = RectangleShape, onClick = { recallSuspensionListItemDto.onClick?.invoke(recallSuspensionListItemDto) }, ) { Column( modifier = Modifier.fillMaxWidth() ) { Row( horizontalArrangement = Arrangement.spacedBy(8.dp), verticalAlignment = CenterVertically, ) { Text( text = recallSuspensionListItemDto.product, style = MaterialTheme.typography.titleMedium, fontSize = 14.sp, color = Color.Black, modifier = Modifier .align(Alignment.CenterVertically) .weight(1f), overflow = TextOverflow.Ellipsis, maxLines = 1 ) Text( text = recallSuspensionListItemDto.let { if (it.recallCommandDate != null) it.recallCommandDate else it.rtrlCommandDt }!!.toJavaLocalDate().format(dateFormat), fontSize = 12.sp, modifier = Modifier.align(Alignment.CenterVertically), color = Color.Gray, maxLines = 1, ) } Spacer(modifier = Modifier.height(8.dp)) Text( text = recallSuspensionListItemDto.rtrvlResn, fontSize = 12.sp, color = Color.Gray, maxLines = 1 ) } } } private val dateFormat = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\") 결과 화면 View, Compose 비교 ViewModel은 View, Compose 모두 같습니다. Compose를 사용하면서 알게된 View와 Compose의 차이점 및 장단점 입니다. View의 장점 안드로이드 개발의 기존 방식으로, 다양한 자료와 커뮤니티 지원이 있습니다. 현재까지의 모든 안드로이드 버전과 호환됩니다. View의 단점 상태 관리와 레이아웃 업데이트를 수동으로 처리해야 합니다. XML을 사용하기 때문에 코드와 레이아웃 파일 간에 이동이 필요합니다. 코드가 깁니다. Compose의 장점 선언적 UI로 인해 상태 관리가 쉽고, 코드 가독성이 높습니다. 코틀린 DSL을 사용하여 코드 작성과 동시에 UI를 프리뷰할 수 있습니다. 커스텀 뷰를 쉽게 만들 수 있으며, 재사용이 용이합니다. Compose를 사용하면 UI 작성 시 더 성능이 좋습니다. Compose의 단점 최소 API 레벨 21(Android 5.0 Lollipop) 이상만 지원합니다. 상대적으로 새로운 기술로서, 자료와 커뮤니티 지원이 View에 비해 상대적으로 적습니다. Compose의 주요 개념 State @Composable 함수로 화면 레이아웃을 구성 Modifier Row, Column State(상태) Compose는 상태에 따라 UI가 자동으로 갱신 됩니다. 상태를 관리하기 위해 remember와 mutableStateOf와 같은 함수를 사용하여 상태를 저장하고 변경할 수 있습니다. 상태가 변경되면, 관련된 Composable 함수가 자동으로 재구성되어 UI를 갱신 합니다. State 와 ViewModel State와 ViewModel은 서로 유사한 역할을 합니다. ViewModel에서 LiveData, Flow등으로 관련 화면의 생명주기 동안 필요한 데이터를 저장하고 유지하는 것이 가능한 것 처럼, Compose의 State도 이와 유사한 역할을 합니다. ViewModel에서 데이터를 저장 유지 하는 기능에 특화되었다고 생각하면 됩니다. var selectedChip by remember { mutableStateOf(ChipType.RECALLS_SUSPENSION) } 위 코드는 enum class 의 속성을 State로 관리하는 것을 의미합니다. 만약 selectedChip의 값이 바뀐다면 자동으로 selectedChip의 값을 사용하는 레이아웃을 갱신합니다. @Composable 함수로 화면 레이아웃을 구성 Compose에서 UI는 작은 조각으로 나누어진 Composable 함수로 구성됩니다. 이 함수를 통해 레이아웃을 구성합니다. Composable 함수는 다른 Composable 함수를 호출하여 계층적인 레이아웃을 구성하는 것이 가능합니다. ViewGroup내에 ViewGroup을 선언하는 것과 같은 역할입니다. @Composable fun RecallDisposalScreen(viewModel: RecallSuspensionViewModel = hiltViewModel()) { } 위와 같은 방식으로 코드를 작성합니다. Compose에서 ViewModel을 사용하려면 매개변수에 위와 같이 viewmodel()을 하면됩니다. Modifier Composable 함수의 레이아웃 디자인에 관한 설정을 할 때 사용합니다. 여러 가지 Modifier를 사용하여 레이아웃, 패딩, 배경색 등의 속성을 설정할 수 있습니다. modifier = Modifier.padding(top = 16.dp, start = 24.dp, end = 24.dp) 위 내용은, View에서 setPadding() 또는 XML내에서 android:padding 속성으로 지정하는 것을 의미합니다. Row, Column Row 수평 방향으로 레이아웃을 배치할 수 있습니다. LinearLayout 속성을 Horizontal로 설정한 것과 유사합니다. Column 수직 방향으로 레이아웃을 배치할 수 있습니다. LinearLayout 속성을 Vertical로 설정한 것과 유사합니다. 위 두 개를 이용해서 List화면을 구성하는 것이 가능합니다. 그러나 모든 List의 Item을 로드하여 화면에 표시하기 때문에 오버헤드가 큰 문제점이 있습니다. View에서 ListView를 사용하는 것과 같다고 생각하면 됩니다. 오버헤드를 줄이기 위해 LazyColumn, LazyRow를 사용하는 것이 좋습니다. LazyColumn와 LazyRow 는 View의 RecyclerView와 같은 역할을 합니다. 정리 써보니 생각보다 어렵지 않고, 코드가 확실히 줄어서 편합니다. 하루라도 빨리 Compose로 개발을 시작해야 하는게 좋을 듯합니다!",
    "tags": "Android Compose",
    "url": "/jekyll-theme-yat/compose/2023/05/09/Android-Compose-%EC%B2%AB-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0.html"
  },{
    "title": "Compiler IR",
    "text": "IR(중간 표현) IR의 핵심 속성 생성 용이성 조작 용이성과 비용 추상화 수준 표현의 자유 프로시저 크기 ###",
    "tags": "Compiler",
    "url": "/jekyll-theme-yat/compiler/2023/04/25/Compiler-IR.html"
  },{
    "title": "Compiler Context-sensitive analysis",
    "text": "Semantic analyzer(Context-sensitive analysis, 문법 분석기) 이전 두 개의 분석기(Lexical, Syntex analyzer) 보다 더 상세한 부분을 분석한다. 변수 선언, 자료형 등의 깊은 정보를 분석한다. 이 분석기에서는 types, scopes가 중요하다! Type systems 공통 타입은 integer, list, character를 포함한다. Type system의 구성 기본(Primitive) 타입 boolean, char, integer, real, etc.. 구조화된 타입 Arrays, Strings, Records and structures, Pointers Type systems의 목적 런타임 안전성을 보장 일부 언어에서 컴파일러는 모든 표현에 대한 타입을 추론하지 못한다. Strongly typed language Statically typed 컴파일 시간에 모든 표현의 자료형이 정해진다. C, C++ 등 Dynamically typed 런타임 시간에 일부 표현의 자료형이 정해질 수 있다. Python, Js 등 An untyped language 자료형 지원이 약한 언어 어셈블리 표현력 향상 잘 구성된 자료형은 언어 개발자가 Context-free 규칙으로 가능한 것 보다 더 정확하게 행위를 지정할 수 있게 한다. Context-free 문법으로 지정할 수 없는 기능을 만들 수 있다. 연산자 오버로딩 더 나은 코드 생성 컴파일 시간에 결정될 수 없는 자료형을 가지는 언어에서는, 런타임까지 자료형 확인 일부가 연기 될 수 있다. 자료형 확인 런타임 시 자료형 확인에 대한 오버헤드를 피하기 위해, 컴파일러는 프로그램을 분석하고 각 이름과 표현에 대해서 자료형을 할당해야 한다. 자료형 호환성 자료형 확인은 자료형이 동등한지 판별해야 한다. 두 가지 접근법이 있다. 이름 동등성 각 자료형의 이름이 고유하다. 예제 next, last는 같은 자료형이다. p, next는 다른 자료형이다. 구조적 동등성 서로 같은 구조를 가질 때, 두 자료형은 동등하다. 예제 구조적 동등성 예제 type link = cell; var next : link; last : link; p : cell; // last, p는 구조적 동등성으로 판단 가능하다. q, r : cell; // q, r은 이름 동등성으로 판단 가능하다 Scope Information Scope information은 식별자 선언과 허용된 각 식별자가 프로그램에서 사용되는 부분에 대해서 문자화한다. Lexical scope는 프로그램 내에서 텍스트 형식의 영역이다. Statement block Formal argument list Object body Function or method body Module body Whole program(Multiple modules) 식별자의 scope 식별자가 유효한 Lexical scope Symbol tables Semantic checks 는 프로그램 내 식별자의 속성을 따른다. 식별자의 Scope와 Type 식별자 정보를 저장할 환경이 필요하다. Symbol table을 사용한다. Hashmap을 사용한다. 구성 식별자 명 추가 정보 종류 : fun, var, parameter ~ 자료형 : int, bool ~ 상수 여부 Scope 정보를 나타내는 방법 프로그램 내 Scope의 계층이 있다. 유사한 계층 구조를 Symbol tables로 사용한다. Symbol table은 Scope마다 연결된다. 각 table은 Lexical scope에서 선언된 기호들을 포함한다. Table 내 데이터 처리 방법 Create 주어진 부모 테이블에 따라 빈 Symbol table을 만든다. Insert 새로운 식별자를 추가한다. Lookup 식별자를 조회한다. Lexical 분석 중에는 Symbol table을 만들 수 없다. Scope 계층이 구문 내에 인코딩되기 때문이다. 테이블을 만드는 시점 Semantic actions로 파싱을 하고 있을 때 AST가 구성된 이후에 Knuth’s attribute grammers 트리 속성을 기반으로 하는 문법이다. 값 할당은 production과 연관된다. 각 속성은 고유하고, 지역적으로 정의된다. 라벨 식별 용어도 고유하다. Syntethic attributes 자식들로 부터 수행된 값 val, neg Inherited attributes 형제와 부모로 부터 수행된 값 pos Attribute dependence graph 사이클이 없는 그래프여야 한다! 속성을 정렬하기 위해 그래프를 위상 정렬로 처리한다.",
    "tags": "Compiler",
    "url": "/jekyll-theme-yat/compiler/2023/04/24/Compiler-Context-sensitive-analysis.html"
  },{
    "title": "Compiler Context-free analysis",
    "text": "Syntax analyzer(Context-free analysis, 구문 분석기) Scanner에 의해 생성된 토큰을 기본적인 문법(Context-free)에 맞는지를 검사하고, Parse tree를 생성한다. 문법에 맞지 않으면 오류를 알린다. Context-free grammer(CGF) 모든 생성 규칙이 V → w 를 따르는 형식적인 문법이다. V : Non-terminal 기호, w : Non-terminal과 Terminal로 구성된 문자열 구성 G = (S, NT, T, P) S 시작 기호(심볼) L(G) 내의 문자열 집합 NT Non-terminal 기호의 집합 syntatic 변수 T Terminal 기호의 집합 words P 생성 규칙 P : NT →(NT∪T)+ Terminal/Non-terminal Symbol Terminal Symbol 언어의 최소 단위 더 이상 분리가 불가능하다. 키워드, 연산자, 숫자, 문자열, 변수명 등 Non-terminal Symbol 언어의 구조와 문법을 나타내는데 사용된다. 함수 정의, 분기문, 반복문 등 추상적인 개념을 의미한다. Context-free grammar의 중요성 프로그래밍 언어의 구문을 설명하기에 강력하다. 입력 문자열이 문법으로 만들어 질 수 있는지 여부와 방법을 결정하는 효율적인 파싱 알고리즘을 만들기에 충분히 간단하다. CGF를 이용한 예제, SheepNoise S = {SheepNoise} NT = {SheepNoise} P = {SheepNoise → SheepNoise baa , SheepNoise → baa} 규칙 표현식은 양의 울음 소리 baa를 추가하여 확장가능 하다. 표현식은 단일 양의 울음 소리로 구성가능 하다. T = {baa} 규칙 Sentential form - SheepNoise 1 SheepNoise *baa* 규칙 Sentential form - SheepNoise 2 *baa* 규칙 Sentential form - SheepNoise 1 SheepNoise *baa* 1 SheepNoise *baa* *baa* … SheepNoise *baa* *baa* … *baa* 2 *baa* *baa* *baa* *baa* … Sentential form(문장 형태) Terminal form으로 만 이루어져 있다. Derivation 과정에서 생성되는 문자열이다. CFG를 나타내기 위한 더 좋은 표기법, BNF(Backus-Naur form) 기호와 표현식의 조합을 사용해서 나타낸다. 0 &lt;expr&gt; → &lt;expr&gt;&lt;op&gt;&lt;expr&gt; 1 | number 2 | id 3 &lt;op&gt; → + 4 | - 5 | * 6 | / Derivation(유도), Parsing시 가장 중요한 것 문법 규칙을 바탕으로 구체적인 구문이나 구조를 만들어 내는 과정을 의미한다. Parser는 유도를 통해 올바른 문법으로 작성된 트리를 만드는데, 이 트리는 Semantic analysis와 Code generation 단계에서 사용된다. 유도 방법 각 단계에서 규칙에 따라 바꿀 비단말 심볼을 선택한다. 선택에 따라 다양한 결과(Parse tree)가 나올 수 있다. Leftmost derivation 맨 좌측의 비단말 심볼을 교체한다. Rightmost derivation 맨 우측의 비단말 심볼을 교체한다. LHS(Left hand side) 등호나 관계연산자 왼쪽에 위치한 표현식을 의미한다. x = y + z x가 LHS이다. RHS(Right hand side) 등호나 관계연산자 오른쪽에 위치한 표현식을 의미한다. x = y + z y + z가 RHS이다. 심볼은 매 단계마다 생성규칙에 따라 교체되고, 해당 과정을 문자열이 완성될 때까지(비단말을 포함하지 않을 때까지) 반복한다. 유도는 재 작성 단계로 구성된다. S → γ0→ γ1→ γ2→ … → γn-1 → γn → sentence γi는 문장 형태이다. γ가 단말 심볼만 가진다면, 그 γ는 L(G)의 문장이다. γ가 비단말 심볼을 가진다면, 그 γ는 문장 형태이다. γi‒1 에서 γi를 얻으려면 A → β 를 사용하여 일부 NT A ∈ γi-1 을 확장합니다. A ∈ γi‒1 발생을 β로 교체하여 γi를 얻습니다. Leftmost derivation에서 첫 번째 NT A ∈ γi‒1 왼쪽 문장 형태는 Leftmost derivation에서 생긴다. 오른쪽 문장 형태는 Rightmost derivation에서 생긴다. x-2*y 에 대한 두 가지 유도 두 경우 모두 Expr → * id - num * id 로 유도해낸다. 그러나 문장 형태가 다르다. Leftmost derivation 결과 Rightmost derivation 결과 Ambiguity, 모호성 만약 문법이 단일 문장 형태로 부터 여러 개의 유도를 만들어 낸다면, 그 유도 결과들은 애매모호 하다. 예제 &lt;stmt&gt; ::= if &lt;expr&gt; then &lt;stmt&gt; | if &lt;expr&gt; then &lt;stmt&gt; else &lt;stmt&gt; | other stmt if E1 then if E2 then S1 else S2 의 경우 if E1 then (if E2 then S1 else S2) if E1 then (if E2 then S1) else S2 모호성을 제거하기 위해서는 문법을 고쳐야 한다! 모호성을 제거한 예제 &lt;stmt&gt; ::= &lt;matched&gt; | &lt;unmatched&gt; &lt;matched&gt; ::= if &lt;expr&gt; then &lt;matched&gt; else &lt;matched&gt; | other stmt &lt;unmatched&gt; ::= if &lt;expr&gt; then &lt;stmt&gt; | if &lt;expr&gt; then &lt;matched&gt; else &lt;unmatched&gt; 위의 경우는 Context-free에서의 모호성에 대한 내용이다. Context-sensitive에서 모호성을 처리하려면 다음과 같은 부분이 필요하다. 선언, 자료형에 대한 지식 L(G)의 상위 집합을 허용하고 다른 방법으로 확인하는 것 언어 설계가 잘못되었는지 확인하는 것 Top-down parser 문장의 구조를 분석하기 위해 구문 요소를 높은 수준에서 낮은 수준으로 차례대로 분해하는 방법이다. 일련의 문자열을 의미있는 토큰으로 분해하고 이들로 이루어진 Parse tree를 만든다. 트리의 루트(최상단)에서 시작하면서 단말 노드를 만들어 간다. 시작 기호 S로 부터 문법 규칙을 바탕으로 좌단 유도에 의해 주어진 문장 W를 찾아간다. 좋지 않은 선택을 한 경우에 Backtracking(역추적)을 할 수도 있다. 일부 문법은 역추적이 안될 수도 있다. LL parser 일반적인 방법 문법의 규칙을 입력과 일치시키기 위해 왼쪽에서부터 파싱을 해서 좌측유도(Leftmost Derivation) 방식으로 동작한다. Backtracking Top-down parsing 기법 역추적, 다시 되돌아가는 방법이다. 가능한 모든 문법 규칙에 따라 유도를 시도하며, 매칭되는 규칙을 찾지 못할 때 이전 단계로 돌아가 다른 규칙을 시도하는 과정을 반복한다. 단점 한 기호만 확인하면서 진행하기 때문에 오버헤드가 크다. Predictive parsing Top-down parsing 기법 다음 입력 기호와 파싱 테이블을 기반으로 사용되는 문법 규칙을 예측한다. 이러한 예측을 하기 위해서, 파서는 입력 스트림에서 현재 토큰을 전방(look-ahead)으로 검토한다. 이 때 전방을 검토하는 기호는 일반적으로 한 개의 토큰까지만 미리보기가 가능한 LL(1) 파서가 사용된다. 왼쪽 재귀(Left recursion)가 없고, 각각의 입력 기호에 대해 단 하나의 파싱 규칙만 충족한다. Top-down parsing 과정 Parse tree의 생성된 문자열과 입력 문자열이 일치할 때까지 아래의 과정을 반복한다. 시작 기호에 대해서 생성 규칙을 적용한다. 생성 규칙이 여러 개인 경우, 첫번째 규칙부터 적용한다. 생성 규칙을 적용할 때마다 부분 Parse tree가 구성된다. 생성된 문장 형태의 문자열과 입력 기호를 차례로 비교한다. 비교 결과 같지 않으면, Backtracking을 한다. 비교 결과 같으면, 계속 비교한다. 결과가 서로 일치하지 않고, 파싱 중 적용가능한 생성 규칙이 없으면 오류를 알린다. 예제 : x-2*y로 파싱 규칙 기호   내용 0 Goal → Expr 1 Expr → Expr + Term 2   | Expr - Term 3   | Term 4 Term → Term * Factor 5   | Term / Factor 6   | Factor 7 Factor → (Expr) 8   | number 9   | id E → E - T T(2*y) T → T * F F(y) F → ( E ) id(y) 파싱 성공 Left recursion 문법 규칙에 따라 유도되는 과정에서, 자기 자신을 가리키는 규칙이 왼쪽에 있는 것을 말한다. Top-down parsing에서 무한 루프를 일으킬 수 있기 때문에 없애야 한다.       Expr → Expr + Term   | Expr - Term   | Term 이 문법은 Left recursion문제가 발생한다. Left recursion을 없애기 위해 비단말 기호를 추가한다.       Expr → Term Expr’ Expr → + Term Expr’   | - Term Expr’   | ε 필요한 look-ahead의 횟수 LL(1) 왼쪽에서 오른쪽으로 검사한다. Leftmost derivation 1-token look-ahead 미리보는 것(토큰)의 개수가 1개 LR(1) 오른쪽에서 왼쪽으로 검사한다. Rightmost derivation 1-token look-ahead 미리보는 것(토큰)의 개수가 1개 Predictive parsing A → α β 를 만들때, 우리는 α 또는 β 로 확장하는 정확한 production을 선택하는 확실한 방법을 원한다. α ∈ G인 일부 RHS에 대해서, α 로 부터 유도된 일부 문자열의 첫번째 토큰 집합을 FIRST(α) 로 정의한다. 일부 γ 에 대해 α → * x γ 일때, x ∈ FIRST(α) 이다. A → α 와 A → β 이 두 production이 문법에서 같이 존재할때, FIRST(α) ∩ FIRST(β) = ∅ 이어야 한다. 이는 파서가 하나의 기호를 미리보면서 올바른 선택을 하도록 한다. A → α 와 A → β 이고, ε ∈ FIRST(α) 일때, FIRST(β)는 FOLLOW(A)와 분리되어야 한다. FOLLOW(A) 한 문장 형태에서 A(A ∈ NT)를 바로 따를 수 있는 단말 기호 집합이다. 시작 기호 S에 대해서 FOLLOW(S) = {EOF} 이다. FOLLOW 집합을 만들기 위해서 FIRST 집합을 사용한다. FIRST+(A → α) 를 정의한다. ε ∈ FIRST(α)이라면, FIRST(α) ∪ FOLLOW(A) 이다. 그렇지 않으면, FIRST(α)이다. A → α 와 A → β 를 처리한다면 그 때 문법은 LL(1)이다. FIRST+(A → α) ∩ FIRST+(A → β) = ∅ FIRST 집합 예제 규칙 기호   내용 0 Goal → Expr 1 Expr → Term Expr’ 2 Expr’ → + Term Expr’ 3   | - Term Expr’ 4   → ε 5 Term → Factor Term’ 6 Term’ → * Factor Term’ 7   | / Factor Term’ 8   | ε 9 Factor → ( Expr ) 10   | number 11   | id 기호 α FIRST(α) number, id, +, -, *, /, ε number, id, +, -, *, /, ε Expr (, number, id Expr’ +, -, ε Term (, number, id Term’ *, /, ε Factor (, number, id 언어 문법이 LL(1)이 아니라면? Left factoring을 하면, 일부 문법을 LL(1) 문법으로 만들 수 있다. 알고리즘 비단말 노드 A에 대해서 반복 공통 Prefix가 있는 대체 RHS’를 가지는 비단말 기호가 없을 때까지 반복합니다. A에 대한 2개 이상의 대안에 공통되는 가장 긴 Prefix a를 찾는다. 만약 α != ε 이라면 모든 유도 결과를 바꾼다. A → αβ1 β2 β3 … αβn γ 를 아래와 같이 바꾼다. A → αA’ γ A’ → β1 β2 β3 … βn Left factoring 예제 아래의 규칙에 대해 Left factoring 수행 Left factoring 결과 Classic expression grammer Bottom-up parser 트리의 맨 끝(단말 노드)에서 시작하여 루트 노드로 만들어 간다. 입력된 문장 W에서 시작하여 Reduce에 의해 시작 기호 S를 찾아간다. 우단 유도의 역순 상태와 문장 형태를 저장하기 위해서 스택을 사용한다. LR parser 일반적인 방법 왼쪽에서 파싱을 해서 우측유도(Rightmost Derivation) 방식으로 동작한다. Reduce 어떤 문장 형태에서 특정한 생성 규칙의 RHS(Right hand side)를 찾아 LHS(Left hand side)로 바꾸는 것이다. abbcde 예제 규칙 기호   내용 1 S → aABe 2 A | Abc 3   | b 4 B → d stack Production 문장 형태 3 abbcde 2 aAbcde 4 aAde 1 aABe - S",
    "tags": "Compiler",
    "url": "/jekyll-theme-yat/compiler/2023/04/23/Compiler-Context-free-analysis.html"
  },{
    "title": "Compiler Scanner",
    "text": "Scanner Word 인식 방법 상태 머신을 사용하고, 정규 표현식으로 구문을 분석한다. 정규 표현식 Formal language(형식적인 언어)이다. 규칙에 의해 명시된 Symbol의 집합이다. 애매한 부분이 있으면 안된다. 복잡한 Scanner개발 과정을 간소화 하기 위해, Scanner Generator를 사용하여 개발할 수도 있다. 예제 while fee | fie while | fee | fie Transition table 레지스터 : r0, r1, …, r31 Recognizer(인식기) 언어 인식기는 문자열 x를 입력으로 하였을때, x가 언어의 문장인지 여부에 따라 yes 또는 no를 출력으로 하는 프로그램이다. 우리는 전환 다이어그램(DFA)을 구성하여 RE(정규 표현식)를 인식기로 컴파일 할 수 있다. Scanner는 정규 표현식과 유사한 것을 통해서 자동으로 생성될 수 있다. DFA를 구성한다. RE → NFA → DFA 변환 과정이 중요하다. 상태 최소화 기법을 사용한다. Scanner에 대한 코드를 내보낸다. 예제 현재 상태에 따라 다음이 정해진다. Identifier letter * (a|b|…|z|A|B|…|Z|) digit * (0|1|2|…|9) id * letter(letter|digit)* NFA(비결정론적 유한 오토마타), DFA(결정론적 유한 오토마타) DFA는 NFA의 특별한 경우이다. DFA 특징 어떠한 상태에도 ε-전환은 없다. NFA는 ε-전환을 가진다. DFA와 NFA의 대표적인 차이점이다. 각 상태 s와 입력 기호 a에 대해서 a로 표시된 edge는 최대 하나이다. 시작 상태인 S0에서 x로 표시된 edge를 따라 표시된 허용된 상태까지에 대해서 전환 그래프내에 고유한 경로가 존재하면 x를 허용한다. DFA와 NFA의 공통점 DFA는 NFA로 시뮬레이션 가능하다. NFA는 DFA로 변환이 가능하다. 비결정론적이란 하나의 상태에서 값이 들어왔을때, 어떤 상태로 갈지 모르는 것을 의미한다. NFA 예제 __(a|b)*abb__ state a b S0 {S0, S1} {S0} S1   {S2} S2   {S3} S0는 a!에서 여러 전환을 한다. RE → DFA RE → NFA w/ε-moves 각각의 항을 NFA로 빌드한다. 그것들을 ε-moves로 묶는다. NFA w/ε-moves 를 DFA로 만든다. NFA를 시뮬레이션 하기 위해 DFA를 만든다. 하위 집합을 만드는 것. DFA → Minimized DFA 호환 가능한 상태를 병합한다. DFA → RE 모든 쌍과 모든 경로들의 문제 S0 부터 마지막 상태까지의 경로들을 합친다. 이 과정을 반복한다. RE → NFA w/ε-moves → DFA → Minimized DFA → RE .. 1. RE to NFA Thompson’s construction(정규 표현식을 NFA로 변환하는 알고리듬)을 보통 사용한다. NFA 패턴을 사용한다. 각 연산에 대해서, NFA하위 그래프를 생성하여 전체 NFA를 구성한다. N(A+)를 만드는 방법은 N(A*)에서 S0에서 마지막 상태로 가는 ε을 제거하면 된다. 2. NFA → DFA(Subset construction) NFA를 시뮬레이션 해야한다. 두 가지 핵심 함수가 있다. move(si, a) 상태 si에서 입력 기호(심볼) a에 대해 가능한 모든 다음 상태들의 집합을 반환한다. NFA에서 전환 규칙에 따라 각 상태와 입력 기호 쌍에 대해 일어날 수 있는 상태 전환을 결정한다. ε-closure(si) 상태 si에서 ε-전환만을 사용하여 도달 가능한 모든 상태들의 집합을 반환한다. move(si, ε)처럼 추가 입력이 없을 경우에 바로 다음 상태로 전환이 가능할 때 사용한다. 알고리즘 시작 상태 설정 NFA의 시작 상태 s0에서 ε-전환에 의해 도달 가능한 모든 상태들의 집합을 DFA의 시작 상태로 설정한다. ε-closure 함수를 사용해서 상태를 찾는 것이다. 새로운 상태 집합 생성 DFA의 상태에서 입력 기호에 대해 move 함수를 통해 가능한 상태 집합을 찾는다. 찾은 상태 집합에 대해서 ε-closure 함수를 통해, 가능한 상태 집합을 찾는다. S0 = ε-closure({s0}) 최종적으로 찾은 상태 집합을 DFA에 추가한다. DFA에 대한 전환 테이블에 집합을 추가한다. 추가적인 상태가 나오지 않을 때 까지 이 과정을 반복한다. 예제 states   ε-closure(move(s, *))     DFA NFA a b c s0 q0 q1, q2, q3, q4, q6, q9 none none s1 q1, q2, q3, q4, q6, q9 none q5, q8, q9, q3, q4, q6 q7, q8, q9, q3, q4, q6 s2 q5, q8, q9, q3, q4, q6 none s2 s3 s3 q7, q8, q9, q3, q4, q6 none s2 s3 s1, s2, s3는 종료 상태이다. NFA를 DFA로 바꾼 결과 ε-전환이 없기 때문에, NFA보다 작다. 모든 전환은 결정론적이다. Use same code skeleton as before | a b c     s0 s1 none none   s1 none s2 s3   s2 none s2 s3   s3 none s2 s3 3. DFA → Minimized DFA DFA에서 동일한 상태 집합을 찾아서 각 집합을 단일 상태로 나타낸다. 알고리즘 서로 동일하지 않은 모든 상태를 찾는다. 상태 X와 Y는 다음과 같은 경우에 서로 다른 상태이다. X가 종료 상태, Y는 종료 상태가 아닐 때 서로 같은 입력 기호를 가지더라도 그 이전 상태가 다를 때 서로 동등하지 않은 쌍은 제거한다. 축소 결과 | | 동일한 상태 | a | b | c | | :—: | :—: | :—: | :—: | :—: | s0 | {s0} | s1 | s1 | none | none | s1 | {s1, s2, s3} | none | s2 | s3 | s1과 s2, s2과 s3는 동일하다. 정규 표현식의 장점 패턴을 지정하는 단순하고 강력한 표기법이다. 많은 종류의 구문을 정규 표현식으로 지정할 수 있다. Regular language의 한계점 정규 표현식은 균형있고 중첩된 구성을 기술하는데 사용할 수 없다. 균형잡힌 괄호 문자열의 집합은 정규 표현식으로 기술할 수 없다. 이러한 집합은 Context-free 문법으로 처리할 수 있다. L = {pk qk} (k는 임의의 수이다.) 정규 표현식으로 이 내용을 처리할 수 없다. Parser로 처리한다. 정규 표현식은 오직 정해진 반복 횟수와 지정되지 않은 반복 횟수만 나타내는데 사용될 수 있다. * (ε|1)(01)*(ε|0) * (01|10)+ Lex and Yacc Scanner와 Parser의 소스 코드를 만드는 데 사용된다. 또 다른 Flex(Lex와 같은 역할), Bison(Yacc과 같은 역할)도 같은 역할을 한다.",
    "tags": "Compiler",
    "url": "/jekyll-theme-yat/compiler/2023/04/22/Compiler-Scanner.html"
  },{
    "title": "Compiler Overview",
    "text": "Compiler(컴파일러) 란? 입력 : High-level 프로그래밍 언어 → 컴파일러 → 출력 : Low-level 어셈블리 언어 컴파일러는 어떤 언어로 작성된 프로그램을 컴파일 시간과 런타임 시간에 다른 언어로 번역하는 역할을 한다. 컴파일러 동작 시점 컴파일 시간(정적, 프로그램 실행 이전) 런타임 시간(동적, 프로그램 실행 중) 또는 컴파일과 런타임 시간 동시에 컴파일러 역할 프로그램을 읽고 이해한다. 필요한 작업을 정확하게 결정하고, 그 동작을 수행하는 방법을 알아낸다. 컴퓨터가 그러한 작업을 하도록 한다. 컴파일러의 중요성 아키텍처, 시스템, 프로그래밍 방법론, 언어 설계와 매우 밀접하게 상호 연결되어있다. 좋은 컴파일러의 특징 올바른 코드를 생성한다. 많은 작업을 빠르게 수행한다. 번역할 프로그래밍 언어의 모든 기능을 다룰 수 있다. 압축된 코드를 제공한다. 수정한 코드만 컴파일 할 수 있다. 해당 부분만 컴파일 한 후 이전에 컴파일된 다른 코드들과 연결시켜 주면 된다. 프로그래머는 컴파일러가 복잡한 것을 모르게 해야 한다. 복잡한 상호작용을 완벽하게 처리한다. 코드의 오류를 진단하는 것 컴파일러의 기본적인 구조 Frontend - Optimizer - Backend, 크게 3개의 구성으로 이루어진다. Frontend Scanner Lexical analyzer Parser Syntax analyzer Semantic analyzer Optimizer Code optimizer Backend Code generator Frontend 소스 코드를 분석하여, 올바른 문법의 코드를 IR로 바꾼다. 코드의 구문(syntax)과 의미(semantics)를 분석하는 역할을 한다. 특징 코드가 잘 작성되었는지 확인한다. 코드의 구문, 문법이 올바른지 확인한다. 코드가 언어에 포함되는지 확인하는 것이다. 구문, 문법 오류를 알려준다. IR과 예비 스토리지 Map을 생성한다. 백엔드를 위한 코드를 구성한다. 대부분의 프론트엔드 설계는 자동화 될 수 있다. Scanner, Parser 간단 비교 처리 Scanning Parsing   Vocabulary Grammer 사용 구문 정규 표현식 Context-free 문법 인식기 구현 DFA(결정론적 유한 오토마타) Push-down automaton 작업 수행 automaton에서 전환 작업   왜 Scanner와 Parser는 분리되어 있는가? 하는 역할이 다르기 때문이다. Scanner 구문 만으로 단어들을 분류한다. Parser 문법을 바탕으로 상세히 코드를 분석한다. 더 느리다. Scanner 소스 코드를 token 단위로 분리 한다. 코드 character stream을 words로 매핑하는 것이다. 특징 Token 의미있는 부분 괄호, 숫자, 식별자, +, -, new, while, if, comma(,) 와 같은 것 &lt;type, value&gt; 의 쌍이다. 구문의 기본 단위이다. x = x + y → &lt;id,x&gt; = &lt;id,x&gt; + &lt;id,y&gt; 공백(주석 포함)을 제거한다. 예제 234 * (56 + -79) 234 : 숫자 * : 곱셈 ( : 왼쪽 괄호 56 : 숫자 + : 덧셈 -79 : 숫자 ) : 오른쪽 괄호 12..34 오류 Parser Scanner에서 받은 Token stream에 대해서 코드 문맥과 무관한(Context-free) 구문과 문맥에 따른(Context-sensitive) 문법을 분석하고, 오류를 보고한다. IR을 생성한다. 오류 수정을 한다. Parsing시 필요한 것 Parsing할 내용이 어느 문법에 적합한지 찾을때 필요한 것 Parsing의 가장 중요한 부분은 Derivation을 만드는 것이다! 문법 G 구문의 수학적 모델 알고리즘 L(G)를 테스트 하기 위해 필요하다. Parsing 방법 Top-down parsing Bottom-up parsing Syntax analyzer(Context-free) 코드의 문맥과 무관한 구문을 분석한다. 데이터 유형 분석없이 형태만 분석하는 것이다. // ) 가 하나 더 있다 test(start : Int, end :Int, v : Int)): Int { var x : Int = 0 // for가 fr로 되어있다 // ..가 아닌 ...로 되어있다 fr(idx in start ... end) { // 연산자가 빠져있다 x idxx } // return이 아닌 retur으로 되어있다 retur x } Semantic analyzer(Context-sensitive) 코드의 문맥과 관련된 문법을 분석한다. 데이터 유형과 변수 선언과 같은 문법을 분석하는 것이다. // v의 유형이 정의되어 있지 않다 fun test(start : Int, end :Int, v)): Int { // x의 값이 초기화 되어 있지 않다 var x : Double for(idx in start .. end) { // idxs는 선언되지 않은 변수이다 x += idxs } // 반환 데이터 유형이 다르다, Double → Int return x } Optimizer IR을 최적화한다. 최적화 예시 fun calcSum(a : Int, b : Int, N : Int) : Int { var i = 0 var x : Int var y : Int x = 0 y = 0 while (i &lt; N) { x = x + (4*a/b)*i+(i+1)*(i+1) x = x+b*y i++ } return x } 상수를 분석하고, 교체 fun calcSum(a : Int, b : Int, N : Int) : Int { var i = 0 var x : Int var y : Int x = 0 y = 0 while (i &lt; N) { x = x + (4*a/b)*i+(i+1)*(i+1) x = x * b*0 // y는 0에서 값이 변하지 않기 때문에 상수이다 i++ } return x } 최적화 fun calcSum(a : Int, b : Int, N : Int) : Int { var i = 0 var x : Int var y : Int x = 0 y = 0 while (i &lt; N) { x = x + (4*a/b)*i+(i+1)*(i+1) // x = x * b*0는 x = x와 같으므로 교체 x = x i++ } return x } 쓰이지 않는 코드 삭제 fun calcSum(a : Int, b : Int, N : Int) : Int { var i = 0 var x : Int // 사용되지 않는 y를 삭제 x = 0 // 불필요한 y = 0를 삭제 while (i &lt; N) { x = x + (4*a/b)*i+(i+1)*(i+1) // x = x는 불필요하므로 삭제 i++ } return x } 공통되는 하위 수식 삭제 fun calcSum(a : Int, b : Int, N : Int) : Int { var i = 0 var x : Int var t : Int x = 0 while (i &lt; N) { t = i + 1 // (i+1)*(i+1)를 t*t로 교체 // 변수 t를 선언 x = x + (4*a/b)*i+t*t i++ } return x } 불변 반복 코드 교체 fun calcSum(a : Int, b : Int, N : Int) : Int { var i = 0 var x : Int var t : Int var u : Int x = 0 u = (4*a/b) while (i &lt; N) { t = i + 1 x = x + u*i+t*t i++ } return x } 최적화, 강도를 줄인다 fun calcSum(a : Int, b : Int, N : Int) : Int { var i = 0 var x : Int var t : Int // u = (4*a/b)를 좀더 부하가 적은 비트 마스크 연산으로 교체한다 var u : Int var v : Int x = 0 u = (a&lt;&lt;2/b) v = 0 while (i &lt; N) { t = i + 1 // u*i를 v로 교체 x = x + v+t*t // i를 곱한 값과 같다 v = v + u i++ } return x } 최적화 결과 비교 처리 최적화 전 최적화 이후 할당 2+9*N 3+5*N 곱셈 4*N N 덧셈 4*N 4*N 나누기 N 1 왼쪽 시프트 연산 없음 1 Backend IR로 Target code(Machine code)를 생성한다. 과정(모든 과정은 IR을 입력으로 받는다.) 명령어 선택 레지스터 할당 명령어 스케줄링 특징 각 IR 동작을 구현하기 위한 명령어를 선택한다. 레지스터에서 유지할 값을 결정한다. 시스템 인터페이스를 준수하는지 확인한다. 백엔드는 자동화 처리가 매우 어렵다. 명령어 선택 IR을 Target 명령어로 매핑한다. 특징 주소 모드와 같은 Target 기능을 활용한다. 패턴 일치 문제로 간주된다. ad hoc methods, pattern matching, dynamic programming 레지스터 할당 변수를 유한한 레지스터 개수로 매핑한다. 특징 레지스터는 사용될 때 값을 가진다. 한정된 자원들을 관리한다. 명령어 선택을 변경한다. 읽기와 쓰기가 가능하다. 최적의 할당 방법은 NP-완전 문제 이다. 컴파일러는 NP-완전 문제에 대한 대략적인 방법(휴리스틱, 경험적인 최적의 방법)이다. 명령어 스케줄링 특징 하드웨어에 과부하가 발생하지 않도록 명령어를 지정한다. 모든 기능 단위를 생산적으로 활용한다. 할당을 변경하면서 변수의 수명을 늘린다. 최적의 스케줄링은 거의 NP-완전 문제 이다. 휴리스틱 기술이 잘 개발되어 있다.",
    "tags": "Compiler",
    "url": "/jekyll-theme-yat/compiler/2023/04/22/Compiler-Overview.html"
  },{
    "title": "TABLE 다루기",
    "text": "CREATE TABLE을 생성 하기 위해 사용한다. 학생, 과목, 수강 TABLE을 만듭니다. CREATE TABLE 학생 ( 학번 VARCHAR2(7), 이름 VARCHAR2(20), 학과번호 VARCHAR2(3), 이수학점 INT, 평점 FLOAT, PRIMARY KEY (학번) ); CREATE TABLE 과목 ( 과목번호 VARCHAR2(5), 과목이름 VARCHAR2(30), 최대인원 INT, PRIMARY KEY (과목번호) ); CREATE TABLE 수강 ( 학번 VARCHAR2(7), 과목번호 VARCHAR2(5), PRIMARY KEY (학번, 과목번호), FOREIGN KEY (학번) REFERENCES 학생, FOREIGN KEY (과목번호) REFERENCES 과목, ); FOREIGN KEY 추가 시 공통 속성의 자료형은 같아야 한다! 이미 존재하는 TABLE을 이용하여 새 TABLE을 만들기 CREATE TABLE NEW_TABLE_NAME AS SUB-QUERY; 형식으로 이미 있는 TABLE을 기반으로 새 TABLE 생성이 가능하다. -- SELECT 결과로 TABLE이 생성된다. CREATE TABLE SW공학과학생 AS SELECT * FROM 학생 WHERE 학과번호 = '010'; INSERT TABLE에 데이터를 추가할때 사용한다. -- 대상 속성(필드, 열)을 생략 가능 INSERT INTO 학생 VALUES('9966666', '이순신', 010, 0, 0); --대상 속성을 명시 INSERT INTO 학생(학번, 이름, 학과번호, 이수학점, 평점) VALUES('9966666', '이순신', 010, 0, 0); SUB-QUERY를 통해 INSERT 하기 INSERT INTO TABLE_NAME (속성1, 속성2) SELECT 속성1, 속성2 FROM TABLE_NAME 형식으로 INSERT가 가능하다. INSERT INTO SW공학과학생 (학번, 이름, 학과번호) SELECT 학번, 이름, 학과번호 FROM 학생 WHERE 학과번호 = '020'; UPDATE 이미 입력된 레코드(행, 튜플)의 데이터를 수정하기 위해 사용한다. UPDATE 학생 SET 학과번호 = '030' WHERE 학번 = '9966666'; UPDATE 학생 SET 이수학점 = 이수학점 + 20; DELETE 레코드를 삭제하기 위해 사용한다. 조건을 명시하지 않으면 모든 레코드가 삭제된다. DELETE FROM 학생 WHERE 학번 = '9966666'; DROP TABLE을 삭제하기 위해 사용한다. DROP TABLE table_name;",
    "tags": "SQL",
    "url": "/jekyll-theme-yat/sql/2023/04/18/TABLE-%EB%8B%A4%EB%A3%A8%EA%B8%B0.html"
  },{
    "title": "Oracle SQL 학습 시작",
    "text": "Oracle SQL Oracle SQL에서는 다양한 종류의 문법이 사용됩니다. 이러한 문법은 데이터베이스에서 데이터를 조작하고 관리하는 데 사용됩니다. 주요 문법 유형은 다음과 같습니다. SQL 문법의 종류 데이터 정의 언어 (DDL): 데이터베이스 스키마를 정의하고 구조를 변경하기 위해 사용됩니다. CREATE, ALTER, DROP, TRUNCATE 등의 구문이 포함됩니다. 데이터 조작 언어 (DML): 데이터를 검색, 추가, 수정 및 삭제하기 위해 사용됩니다. SELECT, INSERT, UPDATE, DELETE 등의 구문이 포함됩니다. 데이터 제어 언어 (DCL): 데이터베이스에 대한 접근 권한 및 보안을 관리하기 위해 사용됩니다. GRANT, REVOKE 등의 구문이 포함됩니다. 트랜잭션 제어 언어 (TCL): 트랜잭션을 제어하기 위해 사용됩니다. COMMIT, ROLLBACK 등의 구문이 포함됩니다. 집계 함수 (Aggregate functions): 데이터를 집계하고 분석하기 위해 사용됩니다. AVG, COUNT, MAX, MIN, SUM 등의 함수가 포함됩니다. 윈도우 함수 (Window functions): 행 그룹 내에서 집계 함수를 계산하기 위해 사용됩니다. ROW_NUMBER, RANK, DENSE_RANK, LEAD, LAG 등의 함수가 포함됩니다. DCL이 핵심입니다!",
    "tags": "SQL",
    "url": "/jekyll-theme-yat/sql/2023/04/18/SQL-%ED%95%99%EC%8A%B5-%EC%8B%9C%EC%9E%91.html"
  },{
    "title": "SELECT문 정복하기",
    "text": "SELECT DB에서 데이터를 검색하기 위해 사용합니다. SELECT 할때 사용되는 연산자 산술 연산자 +, -, *, / 비교 연산자 =, &lt;&gt;, !=, &lt;, &gt; 등 논리 연산자 NOT, AND, OR 등 결합 연산자 | 집합 연산자 UNION ALL, UNION, INTERSECT, MINUS 기타 연산자 IN, BEWTEEN, IS NULL, LIKE, EXISTS 등 가상의 테이블을 생성 SELECT 예제를 알아보기 위해 임의의 테이블을 만들겠습니다. employee_id는 직원 ID, first_name은 이름, last_name은 성, email은 이메일 주소, phone_number는 전화번호, hire_date는 입사일, job_id는 직급, salary는 연봉, department_id는 부서 ID를 의미합니다. CREATE TABLE korean_company ( employee_id NUMBER(4) PRIMARY KEY, first_name VARCHAR2(20), last_name VARCHAR2(25), email VARCHAR2(25), phone_number VARCHAR2(20), hire_date DATE, job_id VARCHAR2(10), salary NUMBER(8,2), department_id NUMBER(2) ); INSERT INTO korean_company VALUES (100, '준호', '김', 'junho.kim@example.com', '010-1234-5678', TO_DATE('2021-01-01', 'YYYY-MM-DD'), 'CEO', 80000, 10); INSERT INTO korean_company VALUES (101, '성민', '이', 'sungmin.lee@example.com', '010-2345-6789', TO_DATE('2021-01-02', 'YYYY-MM-DD'), 'CTO', 70000, 20); INSERT INTO korean_company VALUES (102, '영희', '박', 'yeonghee.park@example.com', '010-3456-7890', TO_DATE('2021-01-03', 'YYYY-MM-DD'), 'CFO', 60000, 30); INSERT INTO korean_company VALUES (103, '철수', '최', 'cheolsu.choi@example.com', '010-4567-8901', TO_DATE('2021-01-04', 'YYYY-MM-DD'), 'Manager', 50000, 40); INSERT INTO korean_company VALUES (104, '수지', '한', 'suji.han@example.com', '010-5678-9012', TO_DATE('2021-01-05', 'YYYY-MM-DD'), 'Manager', 50000, 40); INSERT INTO korean_company VALUES (105, '민지', '강', 'minji.kang@example.com', '010-6789-0123', TO_DATE('2021-01-06', 'YYYY-MM-DD'), 'Analyst', 40000, 50); employee_id first_name last_name email phone_number hire_date job_id salary department_id 100 준호 김 junho.kim@example.com 010-1234-5678 2021-01-01 CEO 80000.00 10 101 성민 이 sungmin.lee@example.com 010-2345-6789 2021-01-02 CTO 70000.00 20 102 영희 박 yeonghee.park@example.com 010-3456-7890 2021-01-03 CFO 60000.00 30 103 철수 최 cheolsu.choi@example.com 010-4567-8901 2021-01-04 Manager 50000.00 40 104 수지 한 suji.han@example.com 010-5678-9012 2021-01-05 Manager 50000.00 40 105 민지 강 minji.kang@example.com 010-6789-0123 2021-01-06 Analyst 40000.00 50 산술/비교/논리 연산자 예제 salary가 50000보다 큰 직원만 출력 SELECT employee_id, first_name, last_name, salary FROM korean_company WHERE salary &gt; 50000; employee_id first_name last_name salary 100 준호 김 80000.00 101 성민 이 70000.00 102 영희 박 60000.00 103 철수 최 50000.00 104 수지 한 50000.00 hire_date가 2021년 1월 4일보다 이전인 직원의 이름과 입사일을 출력 SELECT first_name, hire_date FROM korean_company WHERE hire_date &lt; TO_DATE('2021-01-04', 'YYYY-MM-DD'); first_name hire_date 준호 2021-01-01 성민 2021-01-02 영희 2021-01-03 salary가 50000보다 크고, job_id가 Manager인 직원의 employee_id, first_name, last_name, salary, job_id 필드를 출력 SELECT employee_id, first_name, last_name, salary, job_id FROM korean_company WHERE salary &gt; 50000 AND job_id = 'Manager'; employee_id first_name last_name salary job_id 103 철수 최 50000.00 Manager 104 수지 한 50000.00 Manager salary가 50000보다 큰 직원들 중 hire_date가 2021년 1월 1일 이후인 사람들을 조회 SELECT employee_id, first_name, last_name, hire_date, salary FROM korean_company WHERE salary &gt; 50000 AND hire_date &gt;= TO_DATE('2021-01-01', 'YYYY-MM-DD'); employee_id first_name last_name hire_date salary 100 준호 김 2021-01-01 80000.00 101 성민 이 2021-01-02 70000.00 102 영희 박 2021-01-03 60000.00 job_id가 ‘Manager’이거나 ‘CEO’인 직원들 중 hire_date가 2021년 1월 3일 이전인 사람들을 조회 SELECT employee_id, first_name, last_name, hire_date, job_id FROM korean_company WHERE job_id IN ('Manager', 'CEO') AND hire_date &lt; TO_DATE('2021-01-03', 'YYYY-MM-DD'); employee_id first_name last_name hire_date job_id 100 준호 김 2021-01-01 CEO 103 철수 최 2021-01-04 Manager 104 수지 한 2021-01-05 Manager salary가 40000보다 큰 직원들 중 ‘이’씨 성을 가진 직원들을 조회 SELECT employee_id, first_name, last_name, salary FROM korean_company WHERE last_name LIKE '이%' AND salary &gt; 40000; employee_id first_name last_name salary 101 성민 이 70000.00 직책이 ‘C’로 시작하는 모든 직원의 이름과 직책을 가져옵니다. 그리고 LENGTH 함수를 사용하여 이름이 긴 순서로 결과를 정렬 first_name job_id 영희 CFO 성민 CTO LIKE 연산자는 특정 패턴에 일치하는 행을 찾는 데 사용되며, ‘C%’는 ‘C’로 시작하는 문자열을 의미합니다. ORDER BY 절은 결과를 정렬하는 데 사용되며, LENGTH 함수는 문자열의 길이를 반환합니다. UNION(합집합) 연산자 2개의 SELECT 문의 결과 집합을 결합하여 중복된 행을 제거하고 하나의 결과 집합으로 표시하는 데 사용됩니다. korean_company 테이블에서 job_id가 ‘CEO’인 직원과 job_id가 ‘Analyst’인 직원의 이름과 직급을 선택하면 다음과 같은 SQL 문을 작성할 수 있습니다. SELECT first_name, last_name, job_id FROM korean_company WHERE job_id = 'CEO' UNION SELECT first_name, last_name, job_id FROM korean_company WHERE job_id = 'Analyst'; 2개의 SELECT 문을 UNION으로 결합하고, 중복된 행을 제거하여 합집합으로 결과를 출력합니다. FIRST_NAME LAST_NAME JOB_ID 준호 김 CEO 민지 강 Analyst INTERSECT(교집합) 연산자 2개의 SELECT 문의 결과 집합에서 공통된 행만을 선택하여 하나의 결과 집합으로 표시하는 데 사용됩니다. korean_company 테이블에서 department_id가 10인 직원과 department_id가 20인 직원이 모두 있는 부서의 ID를 선택하는 예제입니다. SELECT department_id FROM korean_company WHERE department_id = 10 INTERSECT SELECT department_id FROM korean_company WHERE department_id = 20; 2개의 SELECT 문을 INTERSECT로 결합하고, 공통된 행을 선택하여 교집합으로 결과를 출력합니다. DEPARTMENT_ID No rows selected (공통된 행이 없으므로 결과가 없습니다.) MINUS(차집합) 연산자 첫 번째 SELECT 문의 결과에서 두 번째 SELECT 문의 결과를 제외한 행을 선택하여 하나의 결과 집합으로 표시하는 데 사용됩니다. korean_company 테이블에서 department_id가 40인 직원 중 job_id가 ‘Manager’인 직원의 이름과 직급을 선택하는 예제입니다. SELECT first_name, last_name, job_id FROM korean_company WHERE department_id = 40 AND job_id = 'Manager' MINUS SELECT first_name, last_name, job_id FROM korean_company WHERE department_id = 40 AND job_id &lt;&gt; 'Manager'; 두 개의 SELECT 문을 MINUS로 결합하고, 첫 번째 SELECT 문의 결과에서 두 번째 SELECT 문의 결과를 제외하여 차집합 결과를 출력합니다. FIRST_NAME LAST_NAME JOB_ID 수지 한 Manager 기타 연산자 IN, ANY, ALL, SOME ANY, SOME은 사실상 같은 것이다. IN, ALL, SOME, ANY 연산자의 차이점을 나타낸 표입니다. 연산자 설명 예제 IN 비교할 값 목록 중 하나와 일치하는지 확인합니다. SELECT * FROM employees WHERE department_id IN (10, 20, 30); ALL 모든 비교 조건이 참일 때 TRUE를 반환합니다. SELECT * FROM employees WHERE salary &gt; ALL (SELECT salary FROM employees WHERE department_id = 30); SOME 비교 조건 중 하나가 참일 때 TRUE를 반환합니다. SELECT * FROM employees WHERE salary &gt; SOME (SELECT salary FROM employees WHERE department_id = 30); ANY SOME과 같이 작동하며, 비교 조건 중 하나가 참일 때 TRUE를 반환합니다. SELECT * FROM employees WHERE salary &gt; ANY (SELECT salary FROM employees WHERE department_id = 30); employees 테이블에서 department_id가 10, 20, 또는 30인 모든 직원의 정보를 가져오는 쿼리는 다음과 같이 작성할 수 있습니다. SELECT * FROM employees WHERE department_id IN (10, 20, 30); employees 테이블에서 department_id가 30인 직원보다 더 높은 급여를 받는 직원의 정보를 가져오는 쿼리는 ALL, SOME, ANY 연산자를 사용하여 다음과 같이 작성할 수 있습니다. -- 부서 id가 30인 직원 중 최고 급여자 보다 높은 급여를 받는 직원 조회 SELECT * FROM employees WHERE salary &gt; ALL (SELECT salary FROM employees WHERE department_id = 30); -- 부서 id가 30인 직원 중 최소 한 명 보다 높은 급여를 받는 직원 조회 SELECT * FROM employees WHERE salary &gt; SOME (SELECT salary FROM employees WHERE department_id = 30); -- 부서 id가 30인 직원 중 최소 한 명 보다 높은 급여를 받는 직원 조회 SELECT * FROM employees WHERE salary &gt; ANY (SELECT salary FROM employees WHERE department_id = 30); `` ## 사용되는 키워드 ### DISTINCT &gt;중복된 투플을 한 번만 표시한다. ### All &gt;중복된 투플을 다 보여준다. &gt;기본 값은 ALL이다. korean_company 테이블에서 DISTINCT를 사용하여 job_id 컬럼의 중복을 제거한 결과를 출력합니다. SELECT DISTINCT job_id FROM korean_company; | job_id | | ------ | | CEO | | CTO | | CFO | | Manager| | Analyst| korean_company 테이블에서 ALL을 사용하여 salary가 50000 이상인 모든 직원의 employee_id와 job_id, salary를 출력합니다. SELECT ALL employee_id, job_id, salary FROM korean_company WHERE salary &gt;= 50000; | employee_id | job_id | salary | | ----------- | -------- | -------- | | 100 | CEO | 80000.00 | | 101 | CTO | 70000.00 | | 102 | CFO | 60000.00 | | 103 | Manager | 50000.00 | | 104 | Manager | 50000.00 | ### ORDER BY &gt;SELECT 문에서 결과를 정렬할 때 사용됩니다. 기본적으로 오름차순(ASC)으로 정렬되며, 내림차순(DESC)으로 정렬하려면 DESC 키워드를 사용합니다. korean_company 테이블에서 salary 필드를 기준으로 정렬하는 SELECT문을 작성하면 다음과 같습니다. SELECT employee_id, first_name, last_name, salary FROM korean_company ORDER BY salary DESC; 위의 SELECT문은 salary 필드를 내림차순으로 정렬한 결과를 보여줍니다. 결과는 다음과 같습니다. | employee_id | first_name | last_name | salary | | ----------- | ---------- | --------- | --------- | | 100 | 준호 | 김 | 80000.00 | | 101 | 성민 | 이 | 70000.00 | | 102 | 영희 | 박 | 60000.00 | | 103 | 철수 | 최 | 50000.00 | | 104 | 수지 | 한 | 50000.00 | | 105 | 민지 | 강 | 40000.00 | 또한, 여러 개의 필드를 기준으로 정렬하려면 ORDER BY 절에 여러 개의 필드를 콤마로 구분하여 작성할 수 있습니다. SELECT employee_id, first_name, last_name, salary, hire_date FROM korean_company ORDER BY department_id ASC, salary DESC; 위의 SELECT문은 먼저 department_id 필드를 오름차순으로 정렬하고, 그 다음으로 salary 필드를 내림차순으로 정렬한 결과를 보여줍니다. 결과는 다음과 같습니다. | employee_id | first_name | last_name | salary | hire_date | | ----------- | ---------- | --------- | --------- | ---------- | | 100 | 준호 | 김 | 80000.00 | 2021-01-01 | | 101 | 성민 | 이 | 70000.00 | 2021-01-02 | | 102 | 영희 | 박 | 60000.00 | 2021-01-03 | | 104 | 수지 | 한 | 50000.00 | 2021-01-05 | | 103 | 철수 | 최 | 50000.00 | 2021-01-04 | | 105 | 민지 | 강 | 40000.00 | 2021-01-06 | ## 다양한 함수 ### 통계 함수 * SUM * 속성의 합계 * COUNT * 레코드의 수 * AVG * 속성의 평균값 * MIN * 속성의 최솟값 * MAX * 속성의 최댓값 * **GROUP BY(중요)** * 레코드(데이터)를 그룹화하고, 각 그룹에 대한 집계 값을 반환 ### SUM, COUNT, AVG – 학과번호가 ‘010’인 학생들의 이수학점 합계를 구하기 SELECT SUM(이수학점) AS 이수학점합계 FROM 학생 WHERE 학과번호 = ‘010’; – 학생들이 수강 신청한 내역의 개수를 구하기 SELECT COUNT(*) AS 수강신청건수 FROM 수강; – 학과번호가 ‘010’인 학생들의 이수학점 평균을 구하기 SELECT AVG(이수학점) AS 이수학점합계 FROM 학생 WHERE 학과번호 = ‘010’; ### GROUP BY &gt;레코드를 그룹화하여, 각 그룹별로 레코드 조회가 가능하다. &gt;GROUP BY 뒤에 있는 속성으로 레코드를 나눈다. &gt;그룹 기준이 되는 속성만 표시가 가능하다. – 학과번호 별로 이수학점의 합계를 구하기 SELECT 학과번호, SUM(이수학점) AS 이수학점합계 FROM 학생 GROUP BY 학과번호; – 학과번호가 ‘010’이 아닌 학생들의 학번과 이수학점 합계를 구하기 – 이 코드는 작동하지 않고 오류가 발생한다! SELECT 학과번호, SUM(이수학점) AS 이수학점합계 FROM 학생 WHERE 학과번호 != ‘010’ GROUP BY 학과번호; ### HAVING &gt;그룹 별 통계 조건을 설정하기 위해 사용한다. 위 예제의 해결책은 다음과 같다. – 학과번호가 ‘010’이 아닌 학생들의 학번과 이수학점 합계를 구하기 – HAVING을 사용하면 된다. SELECT 학과번호, SUM(이수학점) AS 이수학점합계 FROM 학생 GROUP BY 학과번호 HAVING 학과번호 != ‘010; ### 튜플 변수를 이용한 SELECT &gt;튜플 변수를 사용해서, 하나의 TABLE을 두 개의 TABLE이 있는 것처럼 사용이 가능하다. &gt;TABLE 이름 뒤에 튜플 변수 이름을 붙이면 된다. &gt;**TABLE 이름에 별명을 붙여준다고 생각하면 된다!** * 튜플 변수 * 한 레코드(행, 튜플)을 나타낸다. SELECT t1.학번, t1.이름, t2.과목번호 FROM 학생 t1, 수강 t2 WHERE t1.학번 = t2.학번; – 학번이 ‘9912345’인 학생보다 이수학점이 많은 학생들의 학번과 이름을 구하기 SELECT s1.학번, s1.이름 FROM 학생 s1, 학생 s2 WHERE s2.학번 = ‘9912345’ AND s1.이수학점 &gt; s2.이수학점; ### 중첩 SELECT문 &gt;하나의 쿼리문에 SELECT문을 여러 개 사용하는 것을 의미한다. SELECT 학번 FROM 수강 WHERE 과목번호 = ‘cs100’ AND 학번 IN ( SELECT 학번 FROM 수강 WHERE 과목번호 = ‘cs300’ ); ```",
    "tags": "SQL",
    "url": "/jekyll-theme-yat/sql/2023/04/18/SELECT%EB%AC%B8-%EC%A0%95%EB%B3%B5%ED%95%98%EA%B8%B0.html"
  },{
    "title": "JOIN 정복하기",
    "text": "JOIN JOIN은 두 개 이상의 테이블에서 데이터를 연결하여 하나의 결과 집합으로 반환하는 데이터베이스의 연산입니다. JOIN을 사용하면 각 테이블의 행들을 일치하는 조건을 기반으로 결합할 수 있습니다. Oracle SQL에서 제공하는 JOIN 종류는 다음과 같습니다: INNER JOIN 두 테이블에서 JOIN 조건을 만족하는 레코드들만을 반환하는 JOIN입니다. Syntax: SELECT … FROM table1 INNER JOIN table2 ON 조인 조건 LEFT JOIN (LEFT OUTER JOIN) 왼쪽 테이블의 모든 레코드와, 오른쪽 테이블에서 JOIN 조건을 만족하는 레코드를 반환하는 JOIN입니다. Syntax: SELECT … FROM table1 LEFT JOIN table2 ON 조인 조건 RIGHT JOIN (RIGHT OUTER JOIN) 오른쪽 테이블의 모든 레코드와, 왼쪽 테이블에서 JOIN 조건을 만족하는 레코드를 반환하는 JOIN입니다. Syntax: SELECT … FROM table1 RIGHT JOIN table2 ON 조인 조건 FULL OUTER JOIN 왼쪽 테이블과 오른쪽 테이블 모두에서 JOIN 조건을 만족하는 레코드들을 반환하는 JOIN입니다. Syntax: SELECT … FROM table1 FULL OUTER JOIN table2 ON 조인 조건 CROSS JOIN (CARTESIAN JOIN) 두 테이블의 모든 레코드들끼리 JOIN하여 결과를 반환하는 JOIN입니다. Syntax: SELECT … FROM table1 CROSS JOIN table2 SELF JOIN 한 테이블 내에서 JOIN 조건을 이용하여 자기 자신을 JOIN하는 것입니다. Syntax: SELECT … FROM table1 t1 INNER JOIN table1 t2 ON 조인 조건 WHERE 조건 NATURAL JOIN 두 개의 테이블에서 동일한 이름을 가진 모든 열을 기준으로 자동으로 조인하는 방식입니다. 열 이름이 바뀌거나 추가될 경우 쉽게 오류가 발생할 수 있어서 권장하지 않습니다. 대신, 명시적인 조인 조건을 지정하는 INNER JOIN 또는 JOIN USING을 사용하는 것이 좋습니다. 이러한 방식은 조인 조건이 명시적이기 때문에 오류 발생 가능성이 적고 유지 보수가 쉽다는 장점이 있습니다.",
    "tags": "SQL",
    "url": "/jekyll-theme-yat/sql/2023/04/18/JOIN-%EC%A0%95%EB%B3%B5%ED%95%98%EA%B8%B0.html"
  },{
    "title": "데이터통신",
    "text": "2장 네트워크 모델 프로토콜 계층화는 통신 프로세스를 특정 기능을 수행하는 개별 계층으로 분할하는 것을 말합니다. 프로토콜 계층화의 원칙에는 양방향 통신, 각 계층 아래 동일한 객체, 계층 간 논리적 연결 등이 포함됩니다. TCP/IP 계층 응용 앱 프로토콜 전송 전송 프로토콜 네트워크 인터넷 프로토콜 Packet을 처리 데이터 링크 LAN,WAN과 연관, HW가 처리 Frame를 처리 물리 LAN,WAN과 연관 Bit를 처리 TCP/IP Protocol Suite는 인터넷에 연결된 장치 간 통신에 사용되는 프로토콜의 모음입니다. 응용, 전송, 인터넷 및 네트워크 액세스 계층을 포함하는 계층화 아키텍처를 갖습니다. 캡슐화는 각 계층에서 패킷에 헤더(앞) 및 트레일러(뒤)를 추가하는 과정입니다 디캡슐화는 이러한 헤더 및 트레일러를 수신 측에서 제거하는 과정입니다. 주소 지정(Addressing)은 네트워크 계층에서 패킷의 출발지와 목적지를 식별하는 데 사용됩니다. IP 주소가 이러한 목적으로 사용됩니다. 다중화 및 역다중화(Multiplexing and Demultiplexing)는 여러 신호를 하나의 신호로 결합하는 과정입니다. 역다중화는 그 반대의 과정입니다. OSI Model과 TCP/IP Protocol Suite는 비슷한 기능을 가지고 있지만, 프로토콜 레이어링 접근 방식과 레이어 수에서 차이가 있습니다. 3장 물리 계층 소개 이 장에서는 데이터와 신호, 아날로그와 디지털 데이터, 아날로그와 디지털 신호, 주기적과 비주기적 신호, 그리고 대역폭에 대해 논의합니다. 디지털과 아날로그, 신호와 데이터 종류 데이터 신호 아날로그 연속적인 정보(사람 목소리 등) 연속적인 파형 디지털 이산 값을 가짐 이산적, 0과 1과 같이 제한된 수의 정의된 값만 가짐, 합성 아날로그 신호 주기 아날로그 신호 Sine wave 주기적 아날로그 신호의 기본 유형 표현 진폭, 주파수, 위상 디지털 신호 전송 방법 베이스 밴드(Baseband) 전송 아날로그 신호로 변환 없이 디지털 신호를 채널을 통해 전송 Low-pass 채널 필요 좁은 대역폭으로 대용량 데이터 전송에 부적합 저렴한 비용 양방향 통신 근거리 전송에 주로 사용 브로드 밴드(Broadband) 전송 디지털 신호를 아날로그 신호로 변환하여 전송 한 링크에 다수의 채널로 신호를 전송 변조(Modulation)를 사용 넓은 대역폭 장거리 전송에 주로 사용 대역폭 복합 신호에 포함된 주파수 영역 Hz 단위의 대역폭 복합 신호의 주파수 영역 or 채널이 통과 시킬 수 있는 주파수 영역 Bit rate 단위의 대역폭 채널 or 링크의 Bit rate 전송 장애의 원인 감쇠(Attenuation), 왜곡(Distortion), 잡음(Noise)은 전송에 장애가 됩니다. 감쇠 에너지 손실 대응 신호 증폭기(Amplifier) 왜곡 신호 형태의 변화 대응 반대되는 신호나 다른 주파수로 만든다. 잡음 불필요한 신호가 섞임 대응 차폐 SNR(Signal-to-Noise Ratio, 신호 대 잡음 비율) SNR이 높을수록 신호가 더 강하고 잡음이 더 약하다는 것을 의미합니다. decibel로 표시한다. Data Rate와 Bit Rate의 차이 Bit Rate(비트 속도) 1초 당 전송되는 비트 수를 의미 전송되는 데이터의 양을 나타내는 것 비트/초(bps)로 표시 1 Mbps Bit rate는 1초당 100만 개의 비트를 전송할 수 있다는 것을 의미 Bit Length(비트 길이) 매체를 통해 한 비트를 보내는 데 걸리는 시간 Data Rate(데이터 속도) 1초 당 전송되는 실제 데이터의 양 1 Mbps Data rate는 1초 당 1MB의 데이터를 전송할 수 있다는 것을 의미 데이터 속도(Data Rate)의 한계 Data Rate는 세 가지 요소에 의존(영향을 받음) 가능한 대역폭 사용하는 신호 레벨 채널의 품질(노이즈) 이론적 최대 Bit Rate Nyquist Bit Rate 노이즈가 없는 채널의 이론적 최대 Bit Rate Shannon capacity 노이즈가 있는 채널의 이론적 최대 Bit Rate Nyquist Bit Rate Bit Rate = 2 * bandwidth * log2L (L은 신호의 레벨) ex) 노이즈가 없는 3000Hz의 채널로 신호를 2 신호 레벨로 전송할때, 최대 Bit Rate는? Bit Rate = 2 * 3000 * log22 = 6000bps Shannon capacity Capacity = bandwidth * log2(1+SNR) ex) 전화기는 일반적으로 대역폭 3000Hz, SNR 3162 이다. C = 3000 * log23163 = 3000 * 11.62 = 34,860bps 요약 Shannon capacity 는 최대 속도의 상한 값을 알려줌 Nyquist formula 는 얼마 만큼의 신호 레벨이 필요한지를 알려줌 성능 대역폭 Hz와 비트/초 단위의 대역폭 처리량 데이터를 얼마나 빨리 네트워크를 통해 전송할 수 있는지를 측정하는 지표 지연 (지연 시간) 전파 시간, 전송 시간, 대기 시간, 처리 지연 시간 전송 시간 매체를 통해 메시지를 보내는 데 걸리는 시간 대기 시간 메시지가 처리되기 전에 보류되는 시간 대역폭-지연 곱 한 번에 네트워크를 통해 전송할 수 있는 데이터 양 4장 디지털 전송 컴퓨터 네트워크는 정보를 한 지점에서 다른 지점으로 보내도록 설계되었고, 이 정보는 전송을 위해 디지털 신호 또는 아날로그 신호로 변환해야 합니다. 디지털-디지털 변환 디지털 데이터 → 디지털 신호로 변환 Signal Element vs Data Element 신호 요소(Signal Element) 디지털 신호(Digital Signal)의 시간 상 가장 짧은 단위 데이터 요소(Data Element) 보내야 하는 것 r 각 신호 요소 가 전달하는 데이터 요소(Data Element) 의 개수 Data Rate vs Signal Rate Data Rate 1초 당 전송되는 데이터 요소(Bits)의 개수 Bit Rate Signal Rate 1초 당 전송되는 신호(Signal) 요소의 개수 Pulse Rate, Modulation Rate, Baud Rate(디지털 신호에 필요한 대역폭을 결정한다) Data Rate(N) 와 Signal Rate(S) 의 관계 Signal Rate = Data Rate / r 전송 방법 개발 시 고려하는 부분 Baseline Wandering 수신자는 수신된 신호 세기의 평균을 계산합니다. 이 평균을 Baseline이라고 합니다. DC Components(Direct-Current, 직류) 디지털 신호의 전압 레벨이 일정하게 유지되면 스펙트럼은 매우 낮은 주파수를 만드는데, 이 주파수는 0에 가깝습니다. 주파수가 낮은 성분을 통과하지 못하는 시스템이 존재하므로, 직류가 생기지 않도록 해야합니다. Self-synchronization 송신자가 보낸 신호를 인식하기 위해 수신자의 Bit 간격과 송신자의 Bit 간격이 일치해야 합니다. 동기화가 필요합니다. Line Coding(회선 부호화) 디지털 데이터를 디지털 신호로 변환하는 과정(0과 1을 어떻게 할 것인가를 처리) 방식 Unipolar(단극형) NRZ Polar(극형) NRZ-I, NRZ-Z, RZ, Biphase(Manchester, Diff-Manchester) Bipolar(양극형) AMI, Pseudoternary Multilevel 2B/1Q, 8B/6T, 4D-PAM5 Multitransition MLT-3 Unipolar(단극형) 방식 모든 신호 레벨이 축 아래 또는 위에 있습니다. NRZ(Non-Return-to-Zero) 가장 기본적인 방법, 양전압 : 1비트, 음전압 : 0비트로 정의됩니다. 0이 기준점입니다. 문제점 DC, Clock synchronization Polar(극형) 방식 양과 음, 두 가지 전압 준위를 사용한다. NRZ-L, NRZ-I 두 가지 레벨의 전압을 사용, 양전압 : 0비트, 음전압 : 1비트로 정의됩니다. NRZ-L(Level) 전압 레벨에 따라 Bit 값 결정 sync문제가 발생한다. NRZ-I(Inversion) 다음 Bit가 0 → 반전X, 1 → 반전O Bit 1을 만날때 마다 반전하므로, sync를 제공한다. 문제점 DC 평균 신호 속도 = N/2 RZ(Return-to-Zero) NRZ의 문제점인 Sync를 제공 문제점 NRZ보다 더 많은 대역폭을 차지 Biphase(Manchester) 두 가지 전압을 사용, Bipolar(AMI, Pseudoternary)와 달리 0이 아닌 모든 비트에 대해 신호가 전송됨, 동기화와 bit를 표현하기 위해 각 bit 간격 중간에서 신호를 반전 Bit 0 → 양극에서 음극으로 반전, Bit 1 → 음극에서 양극으로 반전 DC 해결 비트 중간에서 반전되므로 Sync문제가 없다. NRZ 대비 2배의 대역폭을 가진다. Differential Manchester RZ와 NRZ-I의 개념을 결합 비트 중간에서 무조건 반전 다음 Bit가 0 → 반전O, 1 → 반전X Bipolar(양극형) 세 가지 레벨(+,0,-) 사용, 장거리 통신에 주로 사용 AMI 다음 bit 0 → 0, 1 → 전환 0이 연속되면 Sync문제가 발생한다. 해결방안 Scrambling(B8ZS, HDB3) Pseudoternary 다음 bit 0 → 전환, 1 → 0 Multilevel(다준위) m개 데이터 요소의 패턴을 n개 신호 요소의 패턴으로 인코딩하여 전송당 비트 수를 늘림 &gt;한번에 더 많은 정보 전송이 가능해 대역폭 효율성 증가 mBnL 방식에서 m 데이터 요소의 패턴을 2^m&lt;=L^n인 n 신호 요소의 패턴으로 인코딩한다. 2B1Q 2진수 1개, 4진수 1개, DSL(Digital subscriber line)기술에 사용됩니다. 4개의 전압 준위를 사용 각 펄스는 2비트를 표현 8B6T 2진수 8개, 3진수 6개, 100BASE-4T 케이블에 사용 3개의 전압 준위를 사용 729(6^3) - 256(268) = 473개의 중복 신호 요소가 있음, 동기화와 에러 검출에 사용 4D-PAM5(4차원 5레벨 펄스 진폭 변조) 4D는 데이터가 동시에 4가닥 선으로 전송되는 것을 의미, 5개의 전압 레벨(-2,-1,0,1,2)사용, 0레벨은 에러 검출에 사용 기가비트 랜에 사용 Mutitransition(다중 회선 전송) MLT-3 3개의 전압 준위(-1,0,+1)사용 Line Coding 요약 DC 있음 NRZ, AMI DC 없음 Biphase, 8B6T, 4D-PAM5 Sync 문제 있음 NRZ, NRZ-L, AMI, 2B1Q, MLT-3 Sync 문제 없음 NRZ-L, RZ, Biphase, 8B6T, 4D-PAM5 Biphase, 8B6T, 4D-PAM5는 DC, Sync문제가 없다! Block Coding(블록 부호화) 디지털 데이터 → 디지털 데이터로 변환, mB/nB 부호화 m bit를 n bit 블록으로 바꾼다. Sync와 오류 탐지를 위해 비트를 추가하는 것이다. 조건 : m&lt;n 4B/5B 4비트 → 5비트, 동기화 문제 해결, 데이터 크기 증가 4비트를 바꿀때 없는 5비트는 따로 매핑 8B/10B 에러 확인(내장 오류 검사 가능)과 동기화 개선에서 더 나음 Scrambling 동기화를 제공하기 위해 긴 0레벨 펄스를 다른 레벨의 조합으로 대체합니다. 종류 8-0 substitution Bipolar(B8ZS) High Density Bipolar 3-0(HDB3) Scrambling이 필요한 이유 LAN의 스테이션 간 전용 링크에 적합한 Biphase 체계는 넓은 대역폭 요구로 인해 장거리 통신에 부적합 Block coding과 NRZ의 조합은 DC 때문에 장거리 인코딩에 부적합 AMI 인코딩은 대역폭이 좁고 DC를 만들지 않으나, 긴 0 시퀀스는 동기화를 방해한다 B8ZS(8-0 substitution Bipolar) 노이즈를 고려해 V,B를 여러개 둬서 DC 문제를 해결함 V : Violation HDB3(High Density Bipolar 3-0) B8ZS와 유사, 4개의 0에 대해 변환, 총 펄스의 수를 짝수로 만듭니다. 마지막 대체 후 0이 아닌 펄스의 수가 홀수이면 대체 패턴은 000V가 됩니다. 이는 0이 아닌 펄스의 총 수를 짝수로 만듭니다. 마지막 치환 후 0이 아닌 펄스의 개수가 짝수이면 치환 패턴은 B00V가 됩니다. 이는 0이 아닌 펄스의 총 수를 짝수로 만듭니다. 아날로그 - 디지털 변환 아날로그 신호 → 디지털 데이터로 변환 종류 PCM DM PCM(Pulse Code Modulation, 펄스 코드 변조) 가장 일반적인 기술 아날로그 신호를 샘플링(신호를 시간 별로 자름, 중간값이 버려짐) 샘플링된 신호를 양자화 양자화된 값을 비트 스트림으로 인코딩 샘플링(Sampling) 아날로그 신호로 표본을 채집하고 그 결과에 근거하여 펄스를 제작 Nyquist 정리에 따르면 샘플링 속도는 신호에 포함된 최고 주파수의 2배 이상이어야 함, 적절한 샘플링 횟수를 정하는 것이 중요 문제점 몇 Bit로 나눠야 하는가 인코딩 각 샘플은 nb-bit code word로 바뀔 수 있다 Bit Rate = Sampling Rate * Number of bits per sample = fsnb ex) 사람 목소리의 샘플링 속도와 비트 속도는 ? 샘플링 속도 = 4000 * 2 = 8000samples/s 비트 속도 = 8000 * 8 = 64,000bps = 64kbps DM(Delta Modulation) PCM의 복잡성을 줄여 간단함, 아날로그를 바로 디지털로 바꿈 Data Transmission(데이터 전송) 데이터 전송모드 병렬 한번에 n 개의 그룹의 비트를 전송하는 것 n 비트를 전송하기 위해 n 개의 전선을 사용 장점 직렬 전송에 비해 n 배만큼 전송속도가 증가 단점 비싼 가격 직렬 통신하는 두 장치 간에 하나의 채널만 있으면 된다. 비 동기식 동기식 Async Transmission 신호 타이밍은 중요하지 않음 start bit : 0, stop bit : 1 Sync Transmission Bit stream이 Frame에 조합됨 양쪽 간에 시간 동기화 불필요 수신자는 수신된 byte를 8bit 단위의 그룹으로 분리한다. 데이터 링크 계층에서 주로 사용 장점 비동기식 보다 빠른 속도 5장 아날로그 전송 아날로그 전송은 진폭, 주파수 또는 위상의 변화로 정보를 전송하는 방식 이 장에서는 디지털-아날로그 및 아날로그-아날로그 변환에 사용되는 다양한 기술에 대해 논의한다. 디지털 - 아날로그 변환 디지털 데이터를 기반으로 아날로그 신호의 특성 중 하나를 변경하는 과정입니다. 디지털 데이터 - 아날로그 신호 변환의 네 가지 유형 진폭 편이 변조(ASK) 주파수 편이 변조(FSK) 위상 편이 변조(PSK) 사분면 진폭 변조(QAM) ASK, FSK, PSK는 아날로그 전송법입니다. QAM은 주파수를 통일하고, 진폭과 위상이 다릅니다. 디지털 - 아날로그 변환 시 중요한 것들 데이터 요소 대 신호 요소 데이터 속도 대 신호 속도 대역폭 Carrier(반송파) 신호 아날로그 전송 시, 송신 장치는 정보 전송 기반이 되는 고주파 신호를 생성하는데, 이 신호를 의미합니다. ASK(Amplitude Shift Keying) 진폭이 다른 신호 요소를 사용, 일반적으로 두 레벨만 사용하여 구현됩니다. BASK(Binary amplitude shift keying), OOK(On-Off keying) ASK의 대역폭 B = (1 + d) x S 0 &lt;= d &lt;= 1 B는 1에 가까울 수록 좋음 다중 레벨 ASK QAM으로 구현 FSK(Frequency Shift Keying) Carrier signal의 주파수를 변조하여 데이터를 나타냄 BFSK(Binary FSK) : 두개의 Carrier 주파수를 고려, 0과 1에 따라 주파수가 다름 BFSK의 대역폭 B = (1 + d) x S + 2∆∅ ASK 대역폭의 절반 수준 PSK(Phase Shift Keying) Carrier의 위상을 변조하여 2개 이상의 다른 신호 요소를 나타냄 BPSK(Binary PSK) : 2개의 신호 요소만 사용, 0° 위상과 180° 위상을 가진 요소 PSK의 대역폭 B = 1 + d x S로 계산됩니다 Quadrature PSK (QPSK)는 각 신호 요소에서 두 개의 비트를 한 번에 보내어 구현됩니다. Constellation Diagram 두 개의 반송파를 사용할 때 신호 요소의 진폭과 위상을 정의하는 데 도움이 됩니다. 보통 주파수를 통일시킵니다. 크기, 위상으로 구별합니다. 모든 위상이 0, 크기 동일/위상 다름, 크기/위상 다름 QAM(Quadrature Amplitude Modulation) 서로 다른 진폭 레벨을 가진 두 개의 반송파를 사용 아날로그 - 아날로그 아날로그를 아날로그로 변환한다. 종류 AM(진폭 변조) FM(주파수 변조) PM(위상 변조) AM(Amplitude Modulation) 신호의 진폭에 따라 반송파의 진폭이 바뀐다. Modulating signal * Carrier frequency = Modulated signal 대역폭 : BAM 2B, 변조 신호 대역폭의 2배 FM(Frequency Modulation) 변조신호의 전압 준위 변화에 따라 반송파의 주파수가 바뀐다. 대역폭 : 변조신호 대역폭의 10배 라디오가 AM, FM으로 구분되는 이유 A, B간에 위치 차이(주파수 영역이 다름)를 둬서 radio에 AM, FM이 있음 PM(Phase Modulation) 주파수가 위상에 따라 변화 6장 대역폭 활용 : 멀티 플렉싱, 스펙트럼 확산 Multiplexing(다중화)의 정의 및 범주 단일 데이터 링크를 통해 여러 신호를 동시에 전송이 가능한 기술 두 장치를 연결하는 매체의 대역폭 &gt; 장치에 필요한 대역폭 Link 물리적 경로 Channel 회선 쌍 사이에서 전송을 위한 경로 링크는 여러 개의 채널을 가질 수 있음 범주 FDM(주파수 분할 다중화) WDM(파장 분할 다중화) TDM(시분할 다중화) Frequency-Division Multiplexing(주파수 분할 다중화, FDM) 전송될 신호들의 대역폭 조합보다 링크의 대역폭이 더 클때 사용된다. 신호가 겹치지 않도록 보호 대역 만큼 떨어져야 한다. 3600개의 채널을 1개의 선으로 처리 Wavelength-Division Multiplexing(파장 분할 다중화, WDM) 기본 개념은 FDM과 같다. 광케이블의 고속 데이터 전송에 적합, SONET network에 사용 3개의 빛을 전송함 Time-Division Multiplexing(시분할 다중화) 여러 연결이 링크의 높은 대역폭을 공유하는 디지털 처리 여러 저속 채널을 하나의 고속 채널로 결합 Time slot, Frame을 사용한다. 종류 동기식 TDM 통계적 TDM 동기식 TDM 각 입력 연결은 데이터를 전송하지 않더라도 출력에 할당됨 링크의 데이터 속도는 n배 더 빠르며, 단위 지속 시간은 n배 더 짧음 A, B, C가 시간을 나눔 TDM의 문제점 Empty Slots, Data Rate Management Empty Slots 동기식 TDM은 전송할 데이터가 없다면 빈 슬롯이 생기므로 비효율적 입니다. Data Rate Management 입력 데이터 속도의 불일치 문제를 가집니다. Empty Slots Data Rate Management Frame Synchronizing TDM 구현은 FDM만큼 간단하지 않습니다. Multiplexer와 DeMultiplexer간의 동기화는 중요한 문제입니다. Frame앞에 Framing bits를 추가하여 동기화 문제를 개선합니다. Digital Signal Service(DSS) 전화 통신사는 Digital Signals 계층으로 TDM을 구현 DS-0 : 단일 디지털 채널, 64kbps DS-1 : 1,544mbps, 24개의 DS-0 채널을 다중화 DS-2 : 6,312mbps, 4개의 DS-1 채널(96개의 DS-0 채널)을 다중화 DS-3 : 44,376mbps, DS-2 채널을 다중화 DS-4 : 274,176mbps, DS-3 채널을 다중화 T-Lines DS-0, DS-1 등은 서비스 명입니다. 이를 구현하기 위해 통신사는 T-Lines를 사용합니다 E-Lines 유럽 연합의 T-Lines Statistical Time-Division Multiplexing(통계적 시분할 다중화, STDM) 대역폭 효율성 향상을 위해 슬롯이 동적으로 할당됩니다. 동기식 TDM에서, 각 입력에는 출력 프레임에 예약된 슬롯이 있습니다. → 일부 입력 라인에 전송할 데이터가 없으면 비효율적 입니다. Addressing Frame에 추가 정보 삽입 Slot size No synchronization bits Bandwidth Spread spectrum(대역 확산) 무선 신호를 다양한 주파수 대역으로 분산시켜서 전송한다, 무선 애플리케이션에서 사용(LAN, WAN) 각 스테이션에는 필요보다 더 넓은 대역폭을 할당해야 한다. 원래 대역폭 B를 Bss로 확장하는 것은 원래 신호와 독립적으로 수행 종류 FHSS DSSS Frequency Hopping Spread Spectrum(주파수 도약 확산 스펙트럼) 랜덤 도약 시퀀스를 통해 발신된 M개의 신호를 서로 다른 반송파를 사용하여 신호를 전송한다. 대상 채널에 대한 사전 검사 기능이 있어, 대상 채널에 노이즈, 전파 간섭이 있으면 그 채널을 피해 도약하는 것이 가능하다. 이로 인해 노이즈, 전파 간섭의 영향을 받지 않고 안정적인 통신이 가능하다. 대역폭 공유 주기를 랜덤으로 만들면 보안성 향상 Direct Sequence Spread Spectrum(직접 시퀀스 확산 스펙트럼) 신호를 확산 코드(무작위 비트 시퀀스)와 XOR연산을 수행하여 변환된 출력 코드를 가지고 다른 주파수 대역으로 분산시켜서 전송한다. FHSS에 비해 노이즈, 간섭에 취약하다. 사용자 마다 다른 확산 코드를 사용하도록 하여 주파수 간섭을 감소시킬 수 있다. 대역폭 공유 일부 무선 LAN은 DSSS를 사용하고, 확산 대역폭 공유 불가 특수 확산 코드를 사용하여, 확산 대역폭을 공유 가능 7장 전송 매체 전송 매체는 소스에서 목적지까지 정보를 전달할 수 있는 모든 것으로 광범위하게 정의할 수 있고, 물리 계층 아래에 위치하며 물리 계층에 의해 직접 제어된다. Unguided는 특정 매체를 사용하지 않음 Twisted-Pair Cable(꼬임 쌍선) 두 개의 도체(일반적으로 구리)로 구성, 전선 중 하나는 수신기로 신호를 전달하는 데 사용되며, 다른 하나는 접지 참조로만 사용됨 Noise, Crosstalk 는 두 전선 모두에 영향을 미쳐 원치 않는 신호를 생성할 수 있습니다. 종류 UTP STP Coaxial Cable(동축 케이블) TP 케이블보다 더 높은 주파수 범위 Fiber-Optic Cable(광 케이블) 빛으로 신호를 전송한다. Propagation Modes(전파 모드) 장점 더 넓은 대역폭 신호 감쇠 감소 전파 영향X 가벼운 무게 부식에 강함 단점 비쌈 유지보수성 Unguided Media(Wireless, 무선) 전파를 사용 사용하는 주파수마다 특성이 다름 전파 방법 지표면(2Mhz 미만) 대기(2~30Mhz) 가시선(30Mhz 이상) 종류 Radiowaves 3khz - 1ghz AM/FM 라디오, 전방향 안테나 Microwaves 1ghz - 300ghz 단방향 위성 통신, 휴대전화 Infrared 300ghz - 400thz IrDA Remote Control(리모컨) 8장 스위칭 장치들을 연결하는 방법 전환 방법 Circuit Switching(회선 전환) 두 스테이션 간에 전용 경로가 생성된다. 자원은 전체 연결 기간 동안 할당됨 전화망 물리 계층에서 사용 Packet Switching(패킷 전환) 메시지는 패킷으로 나뉜다, 자원은 전용이 아니며 서로 다른 연결 간에 공유될 수 있다 데이터 링크/네트워크 계층에서 사용 Message Switching(메시지 전환) 데이터 전송은 애플리케이션 계층에서 이루어지며 한 스테이션에서 다음 스테이션으로 전체 메시지를 전달하는 것을 포함 애플리케이션 계층에서 사용 Circuit Switching(회선 전환) 물리적 링크로 연결되는 스위치들로 구성 두 스테이션 사이에 전용 경로가 설정되고, 전체 연결 기간 동안 자원이 할당된다 연결은 각 링크 중 하나의 전용 채널을 사용 데이터는 패킷화되지 않는다 장점 만들어진 회선의 품질은 일정 단점 안쓰는 회선 낭비 전체 연결 시간동안 자원이 할당 되기 때문입니다. 전송 중 특정 경로에 문제 발생 시 전송 불가 지연 시간 요청 - 응답 간에 지연 시간이 있습니다. Packet Switching(패킷 전환) 패킷에 자원을 할당하지 않음, 패킷 크기는 고정적이거나 가변적이다. 종류 Datagram networks Virtual circuit networks Datagram networks 여러 개의 라우터를 사용 연결과정이 없어 지연 시간이 적고, 회선 전환보다 효율적, 단점도 있음 특징 각 패킷은 다른 패킷과 무관하다 전송 소요 시간이 가변적 지연 시간은 짧으나, 대기 시간이 있다 데이터 요청 순서와 응답 순서가 일치한다는 보장 없음 패킷 내에 주소 정보가 있음 패킷 목적지를 위해 Routing table을 사용하고, 패킷 내에 주소 정보가 있음 Virtual circuit networks(가상 회선) 회선 전환과 데이터 그램 네트워크를 섞음 특징 설정 및 해제 단계가 있다. 자원은 회선 전환과 같이 설정 중에 할당 가능, 데이터 그램처럼 요청 시 할당도 가능 데이터 그램처럼 패킷을 사용, 헤더에 주소를 포함 회선 전환처럼 모든 패킷은 연결 중에 설정된 같은 경로를 따른다 데이터 링크 계층에서 주로 사용 중간에 문제 발생 시 다른 경로로 전송 가능 전환 방식 비교 요약 패킷 전환 네트워크 는 전체 연결 기간 동안 자원이 전용되지 않기 때문에 회선 전환 네트워크 보다 효율적이다 데이터 그램 네트워크 는 가상 회선 네트워크보다 효율적이지만 개별 패킷 라우팅으로 인해 지연 시간이 더 김 가상 회선 네트워크는 회선 전환 네트워크보다 효율적이며 데이터그램 네트워크보다 지연이 적다 회선 전환 네트워크는 단순하고 높은 신뢰성으로 인해 여전히 WAN에서 사용된다. 9장 Data-Link Layer 물리 링크와 논리 링크의 차이 링크 특징이 다름 전송 계층이 논리 링크를 사용 물리 링크 전송 매체를 통해 전송 되는 Bit stream 논리 링크 네트워크 계층에서 전송되는 패킷 물리 링크를 통해 패킷을 전송한다. Nodes, Links Node Computer, Router Link Communication media connect nodes(노드 간의 통신) Link가 Data-link이고, 이 부분에서 이루어짐 Services 데이터 링크 계층은 네트워크 계층에 서비스를 제공 네트워크 계층 역시 상위 계층인 전송 계층에 서비스 제공 종류 물리 계층에서 얻은 서비스 Framing(Frame 생성) 네트워크 계층에서 받은 패킷을 Frame으로 구성한다. Flow Control Error Control Flow/Error Control은 전송/데이터 링크 계층에서 모두 수행된다 전송 계층은 Framing을 하지 않고, 비슷한 작업을 패킷에 대해서 진행한다 Link의 종류 Point-to-point link 특징 송,수신 측이 통신 통신 시에 추가 작업 불필요 Broadcast(Multipoint) link 특징 수신 측은 공유된 매체를 확보해야함 확보하지 않으면 A-F의 통신은 B-E통신에 노이즈가 된다 확보 후 통신을 한다면 p2p와 사실상 같다 Data-link layer 핵심 Error/Flow Control, MAC 10장 Error Detection/Correction 통신 중 예측할 수 없는 간섭으로 인해 오류가 발생할 수 있다. 오류 검출 및 수정 기술은 통신 중 데이터 무결성을 보장하기 위해 사용된다. Errors 예측 불가능한 변화 종류 Single Bit Error Bit 하나가 바뀜 Burst Error 2개 이상의 연속적인 Bit들이 바뀜 Error Detection 송신 측이 Error 검출 목적으로 추가 데이터(Redundancy, 중복)를 보낸다 수신 측은 유효한 codewords를 가진다 특징 원본 codeword가 유효하지 않은 것으로 바뀐다 Receiver에서 Discard는 오류 확인 후 버리는 것을 의미(Error 처리의 한 방법) codeword의 맨 뒤에 추가된 것이 Redundancy(추가 데이터)이다 Hamming Distance Error Control의 주요 개념 두 단어(같은 길이)의 비트 차이 수 Redundancy를 길게 할수록 Hamming distance가 길어진다. Block Codes 유효한 두 개의 codeword를 XOR하여 또 다른 유효 codeword를 만드는 코드 종류 Parity-Check code Cyclic code Checksum Parity Check code 데이터 비트에서 0과 1의 개수를 파악하고 결과에 따라 0 또는 1 비트를 추가하는데, 이 추가되는 bit를 Parity bit라고 한다. 홀수 개의 Error만 검출 가능(짝수 불가) Dataword에서 Bit 1의 개수가 짝수 → 0, 홀수 → 1 Cyclic code, Cyclic Redundancy Check(CRC) Error 검출 실패율이 매우 낮다 dataword : d(x) codeword : c(x) generator : g(x), 송/수신자 간의 약속 syndrome : s(x) error : e(x) 표기법 c(x) = d(x) + s(x) = d(x) + d(x) % g(x) s(x) = c(x) / d(x) 특징 dataword를 generator로 나눈 계산 결과를 이용한다. syndrome 크기 = generator크기 - 1 에러 검출 과정 중, 나머지가 0 → 오류X, 1 → 오류O g(x) == e(x) 이면, Error 검출 불가 generator의 앞,뒤는 1이어야 함 주로 하드웨어로 연산한다 Data-Link Layer에서 유리하다 전송 계층에서 수행X 장점 높은 에러 검출율 단점 많은 계산량(나눗셈) Checksum(검사합) 간단한 Error 검출법 네트워크/전송 계층에서 사용된다 Forward Error Correction(FEC, 순방향 오류 정정) 전송된 데이터에서 발생하는 오류를 수정하기 위한 기술 종류 Hamming Distance 데이터 워드에 추가 비트를 추가하여 Hamming Distance를 늘리고, 이 추가된 비트는 수신된 데이터의 오류를 수정하는 데 사용된다 XOR 사용 Chunk Interleaving",
    "tags": "Data communication Data communication",
    "url": "/jekyll-theme-yat/data/communication/2023/04/16/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%86%B5%EC%8B%A01.html"
  },{
    "title": "StateFlow vs SharedFlow",
    "text": "StateFlow, SharedFlow 상속관계, Cold/Hot stream Flow &lt;- SharedFlow &lt;- StateFlow Flow Cold stream, collect 를 할 때마다 emit 된 모든 값들을 받는다. ex) 어떤 Flow 를 1부터 10사이의 모든 정수를 emit(방출) 한 경우, Collector 가 해당 Flow 를 collect 하면 모든 값(1~10사이의 정수, 이때 까지 emit된 모든 값)들을 전달받음 SharedFlow, StateFlow Hot stream, collect 이 시작된 시점 이후의 emit 된 값을 전달받음 StateFlow StateFlow 는 가장 최신의 값만 내보낸다(emit) MutableStateFlow 값을 바꿀 수 있음 MutableStateFlow 는 인스턴스 생성 시 초기 값 을 필수로 설정해야 한다. StateFlow 는 State 를 표현하는 Data Model 로 사용하기에 유용함 Flow 에서는 여러 연산자들을 사용해서 다양한 값 로 바꾸고 정의할 수 있음 특히 Combine 연산자는 임의의 함수 를 사용하여 여러 StateFlow 의 값들을 결합 하는 데 유용함 class CounterModel { private val _counter = MutableStateFlow(0) val counter = _counter.asStateFlow() fun increment() { _counter.update { count → count + 1 } } } val aModel = CounterModel() val bModel = CounterModel() val sumFlow : Flow&lt;Int&gt; = aModel.counter.combine(bModel.counter) { a, b → a + b } MutableStateFlow의 대안으로, stateIn 연산자를 통해서 ColdFlow를 StateFlow로 변환할 수 있음 SharedFlow 가장 최근의 값만 내보내지 않고, collect 이전에 emit 된 값들에 대해 내보낼 값의 개수를 지정하는 것이 가능 Buffer 가 가득 찼을 경우의 처리 동작을 설정 가능 StateFlow 대신 SharedFlow를 사용하는 경우 여러 개의 값들을 가지면서, 사용하고자 할 때 초기 값을 생략하고자 할 때 추가 Buffering이 필요할 때 StateFlow는 SharedFlow이다 StateFlow 는 좁지만 널리 사용되는 상태 공유를 위한 SharedFlow 의 특수 목적, 고성능, 효율적인 구현이다. StateFlow 는 새로운 Collector(Subscriber) 에게 가장 최근의 값만을 주고, 2개 이상의 값은 담아두지 않음 아래와 같이 MutableSharedFlow 에 매개변수를 지정하고, distinctUntilChanged() 를 사용하면 SharedFlow 를 StateFlow 처럼 사용가능 val shared = MutableSharedFlow( replay = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST ) shared.tryEmit(initialValue) val state = shared.distinctUntilChanged() MutableSharedFlow 생성 매개변수 replay collect 시 전달받을 방출된(emitted) 데이터의 개수를 설정 동시성(Concurrency) 모든 StateFlow 의 메서드는 Thread-safe Coroutine 에서 외부 동기화 없이 안전하게 호출가능 연산자 융합(Operator fusion) StateFlow 은 flowOn, conflate, CONFLATED or RENDEZVOUS capacity, distinctUntilChanged, cancellable 연산자를 사용하더라도 영향을 받지 않음",
    "tags": "Android Flow",
    "url": "/jekyll-theme-yat/android/2023/04/06/StateFlow-vs-SharedFlow.html"
  },{
    "title": "How to use Compose in XML layout in Android",
    "text": "View기반 화면(XML)에서 Compose를 사용하는 방법 Compose는 상호 운용이 가능하여 뷰 기반(XML) 화면 에서도 사용할 수 있다. 1. Compose화면 코드 제작 Compose를 사용하기 위해서는 Composable 함수를 만들어야 합니다. MyComposable.kt @Composable fun MyComposable() { Scaffold( topBar = { TopAppBar( title = { Text(text = \"Compose in Fragment\") } ) }, content = { Column( modifier = Modifier.padding(16 dp), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { TextField( value = \"이름 입력\", onValueChange = { /* 이름 입력 시 로직 */ }, label = { Text(\"이름\") } ) } } ) } 2. View기반 화면 제작 Fragment를 사용하는 경우 MyComposable을 사용할 Fragment를 제작합니다. &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; // ComposeView를 추가합니다. &lt;androidx.compose.ui.platform.ComposeView android:id=\"@+id/compose_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; class MyComposeFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { binding = FragmentMyComposeBinding.inflate(inflater, container, false) binding.composeView.apply { setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnLifecycleDestroyed) setContent { // 여기에 Composable을 넣습니다. MyComposable() } } return binding.root } } Activity를 사용하는 경우 MyComposable을 사용할 Activity를 제작합니다. class MyComposeActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMyComposeBinding.inflate(layoutInflater) binding.composeView.apply { setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnLifecycleDestroyed) setContent { // 여기에 Composable을 넣습니다. MyComposable() } } } } Activity class 를 제작할 때, 보통 ComponentActivity 또는 AppCompatActivity를 상속받아 사용하는데, Android 하위 버전 호환 없이, 최신 버전만 지원하고자 하거나, Compose 만으로 App 을 제작하려고 하면 ComponentActivity 를 상속받아 사용하면 됩니다. 보통은 AppCompatActivity를 사용하면 됩니다. setContent에 보여줄 화면 함수를 넣어주면 됩니다. 화면이 나오고, Compose를 사용할 수 있습니다.",
    "tags": "Android Compose",
    "url": "/jekyll-theme-yat/android/2023/04/04/How-to-use-Compose-in-Fragment-in-Android.html"
  },{
    "title": "Activity 알아보기",
    "text": "Activity 분석 Android에서 Activity는 여러 종류가 존재한다. Activity의 상속 구조 android.app.Activity(최상위) &lt;- androidx.activity.ComponentActivity &lt;- FragmentActivity &lt;- AppCompatActivity 1. android.app.Activity Android 에서 가장 상위에 있는 Activity 2. androidx.activity.ComponentActivity 상위 Level의 컴포넌트를 구성할수 있는 Activity androidx.AppCompat 의 기능을 사용하지 않고, 최신버전만 지원하고자 하거나, Compose 만으로 App 을 제작하고자 할때 사용한다. 보통은 AppCompatActivity 를 사용한다. 3. FragmentActivity Android SDK Api level 10 이하에서 Fragment 를 사용하고자 할때 사용하는 Activity 약 10년 전에 나온 Android 버전 을 위해 사용되는데, 현재는 거의 사용할 필요가 없으므로 추가 내용은 생략 4. AppCompatActivity Android 하위 버전을 지원하는 Activity 특정 SDK버전(예를 들어 level 11) 부터 사용가능한 기능(예를 들어 ActionBar)을 이전 버전(예를 들어 level 11 미만)에서도 사용할 수 있도록 하는 Activity 예를 들어 Android 3.0(Api level 11) 부터 Activity 는 기본적으로 Appbar 로 ActionBar 를 가지고 있다. 이 버전부터 사용되는 ActionBar 를 Api level 10 이하에서도 사용하려면 AppCompatActivity 를 사용해야 한다.",
    "tags": "Android Activity",
    "url": "/jekyll-theme-yat/android/2023/04/04/Activity-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0.html"
  },{
    "title": "Android 모듈화 with ‘Now in Android’",
    "text": "Now in Android, Modularization Now in Android repository Google에서 제작 중인 안드로이드 개발용 샘플 App으로, 최신 앱 아키텍처에 따라 개발되고 있어 학습에 유용하다. ​ Now in Android를 통해 알수 있는 것 Kotlin, Coroutines, Flow, Compose, Material 3 Official App Architeture https://developer.android.com/topic/architecture App Modularization https://developer.android.com/topic/modularization Hilt Unit Test gradle version.controller of Dependency build-logic instead of buildSrc Android의 권장 아키텍처 UI Layer : View, ViewModel로 이루어짐 Data Layer : Repository, DataSource로 이루어짐 Domain Layer : Clean architecture를 따라서 UseCase를 구성하기도 함 Modularization 이유 개발 성능 향상(빌드 속도), 코드 분할(의존성 최소화)이 큰 목적 App의 크기가 커지면서, 개발자들이 각자의 모듈을 만들어서 개발을 진행하게 됨 이러한 모듈들을 하나의 App으로 묶어서 배포하기 위해 필요함 기존은 Package단위로 분할 → Module단위로 분할 수정하지 않은 모듈은 re-build가 불필요 Now in Android의 아키텍처 Now in Android의 모듈 구조 크게 2개의 앱으로 분리됨 각각 필요한 모든 모듈을 조합하는 형태 app : Main 앱 app-nia-catalog : UI 확인용 앱 core- : 베이스 코드를 가짐 common network model : 전체에서 공통으로 사용됨 ui testing feature- : 화면, 기능별로 모듈을 나눔 author bookmarks foryou etc.. etc : 기타 모듈 lint sync : CoroutineWorker를 사용한 Sync 모듈 build-logic : buildSrc 대체 모듈 별로 가진 파일 core - common DispatcherModule.kt : CoroutineDispatcher를 제공하는 모듈 Api result 에 대한 파일 sealed interface flow 확장 함수 core - network network retrofit Api 정의 응답 데이터 클래스 core - model : 사용되는 모든 데이터 model 집합, view-viewmodel 사이의 데이터도 포함 core - database : room 사용, 내부의 entity는 room에만 사용됨, 외부에서 사용되는 데이터는 core-model에 정의(core-data에서 entity복사를 수행) core - datastore Datastore-protobuf 사용(Datastore preference로 대체가능) core - data 응답 model을 entity로 변환 Repository 정의 Repository 에서 Remote(network, 온라인), Local(database, datastore, 내부)을 사용 core - design system component, icon, theme Compose를 사용한 디자인 시스템 Animation, 내부 UI 활용을 위한 Mapping Compose 사용 시에는 Mapping 함수를 미리 만들어 두는 것이 좋음 core - ui ui 모듈에서 공통으로 활용하는 ui mapping을 추가 core-designsystem, core-model을 활용 core - navigation navigation router 처리를 위한 interface feature Compose 기반의 ui 모듈 feature 에서 navigation 기반의 작업 main의 navhost에서 feature 모듈을 사용 core모듈 간의 의존성 : 모든 모듈은 core-data에서 활용됨 UI 모듈 간의 의존성 : core-model을 활용 One Activity 구성은 필수인가? One Activity 구성은 메모리 관리, Lifecycle 등에 대해서 많은 고민이 필요하다. 좋은 설계가 매우 중요 모듈은 단독으로 동작 가능한 화면이 존재 가능 Activity 모듈로 만들면, 바로 실행가능하게 코드 분리가 가능 Hilt와 같은 라이브러리로 분리된 모듈들을 App으로 조합가능 One Activity의 Lifecycle은 App의 Lifecycle과 같을 수 있음 Compose navigation Lifecycle과 Activity Lifecycle은 다름 모듈 간 화면 전환, 통신 방법 Navigation을 사용, Arguments or Repository 를 통해 데이터 전달 모듈이 많아지는 경우 전략 화면마다 feature를 나눌 것 인가? 공통 코드는 core에 담을 것 인가? 폴더 구조를 잘 구성해서 Project형태로 펼쳐서 볼 것 인가? 폴더 구조를 구성해서 Project 형태로 나누기 기존 구조 core-common, core-data, core-data-test, core-database 등 모듈 폴더 들이 nowinandroid 폴더 안에 모두 존재 nowinandroid core-common core-data core-data-test core-database core-designsystem etc.. 개수가 많아 가독성이 낮고, 복잡 Project 형태로 나눈 새로운 구조 core, feature 폴더를 구분 단순히 폴더 구조를 나누기만 하면 빌드 불가!, 추가적으로 설정이 필요 nowinandroid core core-common core-testing model core-data core-database core-datastore core-model etc.. ui core-designsystem core-ui etc.. feature feature-author feature-bookmarks feature-foryou etc.. settings.gradle.kts에 코드 추가한 뒤 빌드 가능 // Create a map to store the name of the module and its path val modules = hashMapOf&lt;String, String&gt;() // Recursively search for all build.gradle.kts files rootProject.projectDir.listFiles()?.forEach { findSubProjects(it) } // Function to find subprojects fun findSubProjects(file: File) { // Skip if the file is a hidden file if(file.name.startsWith(\".\")) { return } // If the file is a build.gradle.kts file, store the module name and path if(file.name == \"build.gradle.kts\") { modules[name] = file.parentFile.path return } // If the file is a directory, recursively search for build.gradle.kts files if(file.isDirectory) { file.listFiles()?.forEach { findSubProjects(it) } } } for(project in rootProject.children) { // Get the project name from the root project if(modules.containsKey(project.name)) { // If the project name is in the list of modules val directory = modules[project.name] ?: continue // Get the directory from the list of modules project.projectDir = File(directory) // Set the project directory to the module directory } } 코드 작성하고 저장 → Sync gradle build.gradle 파일 관리가 중요 모듈을 생성하면서 build.gradle의 중복 코드가 증가! gradle plugins로 관리 plugins에 id(“xx”) 로 추가해 관리하자 plugins { id(\"nowinandroid.android.library\") id(\"nowinandroid.android.feature\") id(\"dagger.hilt.android.plugin\") } buildSrc vs build-logic 둘의 차이는 거의없다 익숙하고 편한거 사용하면 됨 build-logic은 kotlin으로 작성이 가능하다는 차이만 있는 정도 Gradle - build-logic vs buildSrc 알아보기 본 내용은 이 슬라이드의 내용을 바탕으로 작성되었습니다",
    "tags": "Android Modularization",
    "url": "/jekyll-theme-yat/android/2022/12/19/Android-%EB%AA%A8%EB%93%88%ED%99%94-with-Now-in-Android.html"
  }]};
