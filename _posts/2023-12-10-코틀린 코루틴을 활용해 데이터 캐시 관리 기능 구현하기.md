---
layout: post
title: 코틀린 코루틴을 활용해 데이터 메모리 캐시 기능 구현하기
subtitle: Kotlin coroutines, Actor, LruCache, 시간 제한 캐시
published: true
categories: [Kotlin]
tags: [Kotlin, Cache, Coroutines, Actor, LruCache]
---

## 구현 목적

앱을 제작하면서 온라인에서 가져온 데이터를 메모리에 캐싱해야 할 필요가 있었다. 그 이유는 해당 데이터의 서버 상에서 업데이트 주기가 수 십분 ~ 수 시간 단위로 긴데, 이 데이터를 짧은 간격으로 다시 중복으로 가져오는 것은 비효율적이기 때문이다. 그래서 메모리에 캐싱하는 기능을 만들었고 효율성을 개선할 수 있었다.

### 비효율적인 기존 방식

> 총 세 가지의 지역(A, B, C)에 대해서 대기질 데이터를 가져오는 기능을 구현했다고 가정하였다.

![비효율적인 기존 방식](https://github.com/pknujsp/WeatherWizard/assets/48265129/8784eeea-d41b-4772-a2f0-100a0664cdfc)


- 흐름
  1. A의 대기질 데이터를 로드
  2. B 정보 화면으로 전환 -> B의 대기질 데이터를 로드
  4. A 정보 화면으로 재 전환 -> A의 대기질 데이터를 로드
  6. C 정보 화면으로 전환 -> C의 대기질 데이터를 로드
  8. A 정보 화면으로 재 전환 -> A의 대기질 데이터를 로드


20초간 A의 데이터를 3번 로드하였고, 이 시간동안 서버 상에서 데이터가 갱신되지 않았다면 중복된 데이터를 2번 불러오게 된다. 만약 업데이트 주기가 길고, 화면 전환이 잦다면 위와 같은 상황은 빈번하게 발생할 것이다.

최근에 날씨 앱을 제작하고 있는데, 여러 부분에서 이런 상황이 발생하였다.

- 화면을 전환하였다가 다시 돌아왔을때 데이터를 다시 불러옴(짧은 주기)
  - 날씨 정보 화면 -> 앱 설정 화면 -> 날씨 정보 화면
- 같은 지역의 데이터를 비슷한 시점에 다른 기능 구현을 위해 불러옴
  - 위젯, 알림, 앱 날씨 화면이 거의 동시에 업데이트 되는 경우
  - 계속 최신 데이터만 받아온다면, 최악의 경우 같은 데이터를 수십번 동시다발적으로 불러올 수도 있다.
- 예보 비교 화면(시간별, 일별)
  - 예를 들어, A지역의 시간별 예보를 불러온지 몇초 밖에 지나지 않은 상태에서 여러 날씨 제공사의 예보를 비교하려고 한다면, 같은 제공사의 데이터를 다시 불러올 수도 있다.

다수의 문제점이 발생하였고, 데이터를 좀더 효율적으로 관리할 필요가 있었다. 그래서 코틀린 코루틴을 활용하여 데이터를 관리하는 기능을 구현하였다.

**!이러한 상황이 무조건 비효율적이라고 정답을 내릴 수는 없다. 만약 업데이트 주기가 아주 짧으면서, 최신 데이터만을 UI에 보여주려고 한다면 위와 같은 방식을 사용하는 것이 더 나을 수도 있다.**

### 구현 방식

#### 코루틴

앱에서 코루틴을 사용하여 비동기 로직을 처리하고 있기 때문에, 코루틴으로 구현하였다.

#### 캐시 관리

- 캐시 시간 제한
- Lru Cache

**캐시 시간 제한**

캐시 기능이 필요한 이유이기 때문에, 가장 우선적으로 구현하였다.

서버에서 데이터를 가져와서 캐시에 저장할 때, 데이터의 유효 시간을 함께 저장한다. 이후 캐시를 불러올 때 현재 시간과 캐시의 유효 시간을 비교하여 캐시가 유효한지 확인한다. 만약 유효하지 않다면, 다시 서버에서 데이터를 가져와서 캐시에 저장한다.

**Lru Cache**

설계시 미처 고려하지 못한 것으로, 한창 구현하다가 저장된 캐시의 크기가 너무 커지는 문제가 발생할 수 있음을 깨달았다.

이를 해결하기 위해 Lru Cache를 사용하였다. Lru Cache는 가장 오랫동안 사용되지 않은 데이터를 삭제하는 캐시 관리 기법이며, 저장할 캐시의 최대 개수(크기)를 지정할 수 있다.

- 예를 들어, 최대 크기를 3으로 지정하였을 때, 4번째로 캐시가 추가될 때 1번째로 추가된 캐시는 삭제된다.

Lru Cache에 대해선 이전에 작성한 포스팅 [ArrayMap, SparseArray, LruCache에 대해서 알아보기](https://pknujsp.github.io/android/2023/08/13/androidx.collection-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0(SparseArray,-ArrayMap,-LruCache-/).html#h-lrucacheleast-recently-used-cache) 을 참고하면 도움이 될 것이다.


#### 데이터 동기화

여러 스레드에서 동시에 캐시에 접근할 수 있기 때문에, 데이터 동기화를 해주어야 한다.

가장 중요한 부분, 섬세한 로직이 요구되었다. 

- 적용해본 동기화 방식
  - Mutex, Synchronized
  - ConcurrentHashMap
  - ReentrantReadWriteLock
  - Actor

여러 방식으로 테스트 해보면서 Actor로 최종 구현하였다. 이 과정에서 코루틴의 동작 방식에 대해 더욱 깊게 이해할 수 있었다.

**1. Mutex, Synchronized**

제일 먼저 적용한 기법이다.

Mutex는 Mutual Exclusion의 약자로 상호 배제를 의미한다. 임계 구역을 만들고 그 구역을 통해서 스레드가 데이터에 접근한 뒤 구역을 잠궈서, 다른 스레드는 접근할 수 없도록 막는 기법이다.

스레드 A, B가 동시에 어떤 로직을 시작하려고 할 때, A가 먼저 시작하면 B는 A가 끝낼 때 까지 그 로직 수행을 못하고, A가 작업을 끝내야만 B가 수행할 수 있다. Synchrnoized도 이와 유사하다.

예를 들어, `Map`을 Mutex 또는 Synchronized로 동기화하면, 그 Map은 동시에 하나의 스레드만 다룰수 있기 때문에, 데이터 동기화가 보장되는 것이다.


**Mutex, Synchronized의 차이**

|                    |                 Mutex                 |      Synchronized      |
| :----------------: | :-----------------------------------: | :--------------------: |
|     동작 기반      | 프로그램 구동 플랫폼, 코루틴에 최적화 |          JVM           |
| 잠금해제 대기 방식 |        코루틴 동작을 일시중지         | 스레드 동작을 일시중지 |

잠금해제를 대기하는 방식에서 확실한 차이가 있다.

- Mutex : 대기하는 동안 다른 작업 가능, 코루틴에 최적화되어 있어 대기하는 동안 다른 코루틴으로 작업을 넘길 수 있다.
- Synchronized : 대기하는 동안 다른 작업 불가능

하나의 칸만 있는 화장실이 있는 상황으로 비교해보자면 다음과 같다.

- Mutex : 다른 사람이 나올때 까지 기다리는 동안, 휴대폰을 보는 등 다른 작업을 할 수 있다.
- Synchronized : 기다리는 동안 아무것도 못한다. 휴대폰도 없고 뭐도 못한다. 그냥 기다린다.


**2. ConcurrentHashMap**

우리가 직접 따로 임계 구역을 만들어 동기화 할 필요없이 자체적으로 동기화를 지원하는 Map이다.

Map을 예로 들어, Mutex, Synchronized로 임계 구역을 통해 동기화를 하게 되면 Map전체에 대해서 다른 스레드는 접근할 수 없게 된다. 하지만 ConcurrentHashMap은 Map의 일부분만 잠그고, 나머지 부분은 다른 스레드가 접근할 수 있게 해준다.

Map의 key로 1, 2가 있을 때 

- Mutex, Synchronized 를 쓴다면, 1에 대한 작업을 하고 있는 동안 2에 대한 작업을 할 수 없다.
- ConcurrentHashMap을 쓴다면, 1에 대한 작업을 하고 있는 동안 2에 대한 작업을 할 수 있다.

**3. ReentrantReadWriteLock**

ReentrantReadWriteLock은 Mutex와 Synchronized와 다르게, 읽기와 쓰기 각각에 대해 잠금을 걸 수 있다. 즉, 읽기 잠금과 쓰기 잠금을 따로 걸 수 있다.

- 쓰기 잠금을 걸었다면 다른 스레드는 읽기와 쓰기 모두 불가능하다.
- 읽기 잠금을 걸었더라도 다른 키로 접근한다면 읽을 수 있다.


**4. Actor**

Actor Model 패턴으로 동기화를 구현하는 방법이다. [Concurrency with Actor Model(행위자 모델)](https://syntaxsugar.tistory.com/entry/Actor%EC%95%A1%ED%84%B0) 페이지에 상세히 정리되어 있어 추가로 참조하면 도움이 될 것이다.

간단히 설명하자면, 