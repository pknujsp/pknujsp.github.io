---
layout: post
title: 코틀린 코루틴을 활용해 데이터 메모리 캐시 기능 구현하기
subtitle: Kotlin coroutines, Actor, LruCache, 시간 제한 캐시
published: true
categories: [Kotlin]
tags: [Kotlin, Cache, Coroutines, Actor, LruCache]
---

## 구현 목적

앱을 제작하면서 온라인에서 가져온 데이터를 메모리에 캐싱해야 할 필요가 있었다. 그 이유는 해당 데이터의 서버 상에서 업데이트 주기가 수 십분 ~ 수 시간 단위로 긴데, 이 데이터를 짧은 간격으로 다시 중복으로 가져오는 것은 비효율적이기 때문이다. 그래서 메모리에 캐싱하는 기능을 만들었고 효율성을 개선할 수 있었다.

### 비효율적인 기존 방식

> 총 세 가지의 지역(A, B, C)에 대해서 대기질 데이터를 가져오는 기능을 구현했다고 가정하였다.

![비효율적인 기존 방식](https://github.com/pknujsp/WeatherWizard/assets/48265129/8784eeea-d41b-4772-a2f0-100a0664cdfc)


- 흐름
  1. A의 대기질 데이터를 로드
  2. B 정보 화면으로 전환 -> B의 대기질 데이터를 로드
  4. A 정보 화면으로 재 전환 -> A의 대기질 데이터를 로드
  6. C 정보 화면으로 전환 -> C의 대기질 데이터를 로드
  8. A 정보 화면으로 재 전환 -> A의 대기질 데이터를 로드


20초간 A의 데이터를 3번 로드하였고, 이 시간동안 서버 상에서 데이터가 갱신되지 않았다면 중복된 데이터를 2번 불러오게 된다. 만약 업데이트 주기가 길고, 화면 전환이 잦다면 위와 같은 상황은 빈번하게 발생할 것이다.

최근에 날씨 앱을 제작하고 있는데, 여러 부분에서 이런 상황이 발생하였다.

- 화면을 전환하였다가 다시 돌아왔을때 데이터를 다시 불러옴(짧은 주기)
  - 날씨 정보 화면 -> 앱 설정 화면 -> 날씨 정보 화면
- 같은 지역의 데이터를 비슷한 시점에 다른 기능 구현을 위해 불러옴
  - 위젯, 알림, 앱 날씨 화면이 거의 동시에 업데이트 되는 경우
  - 계속 최신 데이터만 받아온다면, 최악의 경우 같은 데이터를 수십번 동시다발적으로 불러올 수도 있다.
- 예보 비교 화면(시간별, 일별)
  - 예를 들어, A지역의 시간별 예보를 불러온지 몇초 밖에 지나지 않은 상태에서 여러 날씨 제공사의 예보를 비교하려고 한다면, 같은 제공사의 데이터를 다시 불러올 수도 있다.

다수의 문제점이 발생하였고, 데이터를 좀더 효율적으로 관리할 필요가 있었다. 그래서 코틀린 코루틴을 활용하여 데이터를 관리하는 기능을 구현하였다.

**!이러한 상황이 무조건 비효율적이라고 정답을 내릴 수는 없다. 만약 업데이트 주기가 아주 짧으면서, 최신 데이터만을 UI에 보여주려고 한다면 위와 같은 방식을 사용하는 것이 더 나을 수도 있다.**

### 구현 방식

#### 코루틴

앱에서 코루틴을 사용하여 비동기 로직을 처리하고 있기 때문에, 코루틴으로 구현하였다.

#### 캐시 관리

- 캐시 시간 제한
- Lru Cache

**캐시 시간 제한**

캐시 기능이 필요한 이유이기 때문에, 가장 우선적으로 구현하였다.

서버에서 데이터를 가져와서 캐시에 저장할 때, 데이터의 유효 시간을 함께 저장한다. 이후 캐시를 불러올 때 현재 시간과 캐시의 유효 시간을 비교하여 캐시가 유효한지 확인한다. 만약 유효하지 않다면, 다시 서버에서 데이터를 가져와서 캐시에 저장한다.

**Lru Cache**

설계시 미처 고려하지 못한 것으로, 한창 구현하다가 저장된 캐시의 크기가 너무 커지는 문제가 발생할 수 있음을 깨달았다.

이를 해결하기 위해 Lru Cache를 사용하였다. Lru Cache는 가장 오랫동안 사용되지 않은 데이터를 삭제하는 캐시 관리 기법이며, 저장할 캐시의 최대 개수(크기)를 지정할 수 있다.

- 예를 들어, 최대 크기를 3으로 지정하였을 때, 4번째로 캐시가 추가될 때 1번째로 추가된 캐시는 삭제된다.

Lru Cache에 대해선 이전에 작성한 포스팅 [ArrayMap, SparseArray, LruCache에 대해서 알아보기](https://pknujsp.github.io/android/2023/08/13/androidx.collection-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0(SparseArray,-ArrayMap,-LruCache-/).html#h-lrucacheleast-recently-used-cache) 을 참고하면 도움이 될 것이다.


#### 데이터 동기화

여러 스레드에서 동시에 캐시에 접근할 수 있기 때문에, 데이터 동기화를 해주어야 한다.

가장 중요한 부분, 섬세한 로직이 요구되었다. 

- 적용해본 동기화 방식 순서
  - Mutex
  - Synchronized
  - ReentrantLock
  - 다시 Mutex
  - Actor

총 5번의 시도를 거쳐서야 원하는 결과를 얻을 수 있었다. 이 과정에서 코루틴의 동작 방식에 대해 더욱 깊게 이해할 수 있었다.

**1. Mutex**

