---
layout: post
title: Kotlin 동시성 문제 해결방법
subtitle: Mutex, Actor, Synchronized 등
published: true
categories: Kotlin
tags: [Kotlin]
---

## 동시성을 고려하여 동기화가 필요한 경우
---

```kotlin
var count = 0
const val repeatCount = 1000000

fun main() = runBlocking {
    launch(Dispatchers.Default) {
        repeat(repeatCount) {
            count++
        }
        println(count)
    }

    launch(Dispatchers.Default) {
        repeat(repeatCount) {
            count++
        }
        println(count)
    }
    println("기대값 : ${repeatCount * 2}")
}
```

```
기대값 : 2000000
981272
1862564
```

2000000이라는 기대값과는 다르게 981272, 1862564이 결과로 출력되었습니다.

이는 두 개의 코루틴이 동기화를 하지 않고 count 변수에 대해 연산을 수행하기 때문에 발생하는 문제입니다.

## 해결책
---
> 여러 스레드 간에 공유되며 동시에 접근이 가능한 객체에 대해 어떠한 코드를 수행할 때 동기화를 해주는 것이 필요합니다.

### 1. AtomicInteger
---

> `java.util.concurrent.atomic`에 포함되어 있습니다.

* 원자적 연산을 지원합니다.
  * 원자적 연산이란, 연산이 수행되는 동안 다른 스레드가 접근하지 못하도록 하는 것을 의미합니다.
* 멀티 스레드 환경에서 동기화되어 안전하게 사용할 수 있습니다.

```kotlin

val atomicCount = AtomicInteger(0)

launch(Dispatchers.Default) {
    repeat(repeatCount) {
        atomicCount.incrementAndGet()
    }
}

```

위와 같이 간단하게 사용할 수 있습니다.

### 2. Mutex
---
> 하나의 스레드만 공유 데이터에 접근할 수 있도록 lock을 걸어주는 방식입니다.

* 상호 배제(Mutual Exclusion) 방식입니다.
* lock이 걸린 경우, 다른 스레드는 unlock이 될 때 까지 대기하거나, 해당 작업을 무시하고 다른 작업을 수행하도록 할 수 있습니다.


```kotlin

val mutex = Mutex()
var mutexCount = 0

launch(Dispatchers.Default) {
    repeat(repeatCount) {
        mutex.withLock {
            mutexCount++
        }

        // OR

        mutex.lock()
        try {
            mutexCount++
        } finally {
            mutex.unlock()
        }
    }
}

```

* 위와 같이 `mutex.withLock()`을 사용하여 간단하게 사용이 가능합니다.
* `withLock()`
  * 이미 lock이 걸린 경우, 대기합니다.
  * lock이 걸리지 않은 경우, lock을 걸고 작업을 수행합니다.
  * 작업이 끝나면 unlock 합니다.


### 3. 단일 스레드를 사용
---
> 동기화가 필요한 연산에 대해서 하나의 스레드로만 동작하도록 하는 방식입니다.

```kotlin

var singleThreadCount = 0
val singleThread = newSingleThreadContext("Concurrency")

launch(Dispatchers.Default) {
    repeat(repeatCount) {
        withContext(singleThread) {
            singleThreadCount++
        }
    }
}

```

* `newSingleThreadContext()`를 사용하여 단일 스레드를 생성합니다.
* `withContext()`를 사용하여 해당 스레드에서 작업을 수행합니다.
* Default context <-> singleThread context 간에 지속적으로 전환이 발생하기 때문에 성능이 저하될 수 있습니다.


### 4. Actor
---
> 메시지를 전달받아 순차적으로 처리하는 방식으로 작동합니다.

* actor에 flow와 비슷한 방식으로 동작하며, 자체적으로 Channel을 가지고 있습니다.
* actor에게 메시지를 전달하면, 해당 메시지를 순차적으로 처리합니다.


```kotlin

sealed interface Message

data object Increment : Message

class Result(val response: CompletableDeferred<Int>) : Message

@ObsoleteCoroutinesApi
fun CoroutineScope.counterActor() = actor<Message> {
    var counter = 0
    for (message in channel) {
        when (message) {
            is Increment -> counter++
            is Result -> message.response.complete(counter)
        }
    }
}

val actorCounter = counterActor()

launch(Dispatchers.Default) {
    repeat(repeatCount) {
        actorCounter.send(Increment)
    }
}

val response = CompletableDeferred<Int>()
actorCounter.send(Result(response))

```

* `actor()`를 사용하여 actor를 생성합니다.
* 해야하는 작업에 대해 메시지를 전달합니다.