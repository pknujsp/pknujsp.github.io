---
layout: post
title: 코루틴에서의 예외 처리 정리
subtitle: 예외 처리
published: true
categories: [Kotlin, Coroutines]
tags: [Kotlin, Coroutines]
---

## 코루틴에서 예외가 발생하면, 부모 코루틴으로 예외가 **전파**되고, 부모와 형제 코루틴이 모두 취소된다.

```kotlin
fun main(): Unit = runBlocking {
    // A
    launch {
        // A-A
        launch {
            throw Error("A-A의 예외")
        }

        // A-B
        launch {
            println("A-B")
        }

        // A-C
        launch {
            println("A-C")
        }
    }

    // B
    launch {
        println("B")
    }
}

B
Exception in thread "main" java.lang.Error: A-A의 예외
```

`A-A`에서 발생한 예외가 전파되어, 모든 코루틴`[A-B, A-C, B]`이 취소된다. 다음 그림은 위 코드내 코루틴의 계층도를 나타낸다.


<img src="https://github-production-user-asset-6210df.s3.amazonaws.com/48265129/284049686-ffb3488f-f5cf-4109-96b4-39630d8a049c.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20231119%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20231119T100818Z&X-Amz-Expires=300&X-Amz-Signature=ee142b11b3c2ca5189c7f60243d5ebb73585b6146bac4ceffff145a7aaca9e9e&X-Amz-SignedHeaders=host&actor_id=48265129&key_id=0&repo_id=685439824">


작업하나가 실패하더라도 다른 작업에 영향을 주지 않아야 하는 경우, 이를 처리하는 방법을 알아보자.

## 코루틴에서 발생한 오류를 전파시키지 않도록 하는 방법

### SupervisorJob

> `SupervisorJob`를 사용하는 코루틴은 다른 코루틴에게 영향을 주지 않는다.

- `SupervisorJob` : 자식 코루틴들은 서로 독립적으로 동작하여, 해당 코루틴에서 발생한 예외가 부모와 형제 코루틴에게 영향을 주지 않는다.
- `Job` : 부모와 자식 코루틴은 서로 연결되어 있어, 예외가 전파된다.


```kotlin
suspend fun main(): Unit = coroutineScope {
    // A
    launch {
        println("A")
    }

    // B
    launch {
        println("B")
    }

    // C
    val scope = CoroutineScope(SupervisorJob())
    scope.launch {
        try {
            println("C")
            throw Exception("C의 예외")
        } catch (e: Exception) {
            println(e)
        }
    }
}

A
B
C
java.lang.Exception: C의 예외
```

`C`에서 예외가 발생하였으나, 다른 코루틴에게 영향을 주지 않았다.

<img src="https://github-production-user-asset-6210df.s3.amazonaws.com/48265129/284049715-9f84130c-96d0-473a-9359-4d9f3e0ddef3.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20231119%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20231119T100844Z&X-Amz-Expires=300&X-Amz-Signature=e10639f9cb24b58c2676fbdc6371dabb9720c58d2c2e0fb75a1d6f28524cc657&X-Amz-SignedHeaders=host&actor_id=48265129&key_id=0&repo_id=685439824">

#### 사용 방법

```kotlin
// 1. Scope를 만들 때 SupervisorJob을 컨텍스트로 포함시키기
val scope = CoroutineScope(SupervisorJob())
scope.launch {
    // ...
}

// 2. 기존 Scope에 SupervisorJob을 추가하기
launch(SupervisorJob()) {
    // ...
}
```

#### 부적절한 사용 : `withContext(SupervisorJob())`

`withContext(SupervisorJob())`으로 사용하면, 의도와 달리 예외가 전파된다. 왜냐하면 `withContext`은 새로운 코루틴을 만드는 것이 아니라 기존 코루틴의 context를 임시적으로 변경하는 것이기 때문이다. 다시 말해, `SupervisorJob`으로 지정하여도 코루틴의 동작 방식을 바꿀 수 없기 떄문에 `SupervisorJob`의 특성이 적용되지 않는다.  


```kotlin
suspend fun analyzeData(dataList: List<Data>) = 
    withContext(SupervisorJob()) {
        dataList.forEach { data ->
            launch {
                val result = analyze(data)
                notifyResult(result)
            }
        }
    }
```

`launch`내에서 예외가 발생하면 다른 코루틴이 모두 취소된다.


### supervisorScope

> `supervisorScope`내의 코루틴은 서로 독립적으로 동작하여, 예외가 발생해도 다른 코루틴에게 영향을 주지 않는다.

Scope내에서 생성되는 코루틴은 `SupervisorJob`으로 동작한다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    // A
    launch {
        println("A")
    }

    // B
    launch {
        println("B")
    }

    // C
    supervisorScope {
        launch {
            try {
                println("C")
                throw Exception("C의 예외")
            } catch (e: Exception) {
                println(e)
            }
        }
    }
}

A
B
C
java.lang.Exception: C의 예외
```


### Exception클래스가 `CancellationException`를 상속받도록 하기

#### 예시 : 값이 홀수일 때 예외를 발생시키는 코드

예외가 발생하면 부모, 자식 코루틴이 종료된다. 짝수일 때는 정상적으로 동작해야 하는데 취소되기 때문에 개선이 필요하다.

```kotlin
data class OddException(val value: Int) : Exception()

suspend fun main(): Unit = coroutineScope {
    repeat(100) {
        launch {
            if (it % 2 == 1) {
                throw OddException(it)
            }
            println(it)
        }
    }
}

0
2
4
Exception in thread "main" OddException(value=1)
```

`OddException`를 `CancellationException`를 상속받도록 하면, 예외는 부모로 전파되지 않고, 예외가 발생한 코루틴만 취소된다.

```kotlin
data class OddException(val value: Int) : CancellationException()

0
2
4
6
8
10
12
14
...
98
```

## 코루틴에서 발생한 예외를 감지하는 방법

### try-catch, 일반적인 방법

가장 기초적인 방법으로 `try-catch`를 사용하여 예외를 감지할 수 있다.

코루틴 빌더 내에서 `try-catch`를 사용하면 된다.

```kotlin
launch {
    try {
        throw Exception("예외 발생")
    } catch (e: Exception) {
        // try 내에서 발생한 예외에 대한 대응 로직을 작성
    }
}
```

그러나 `try`문 내에 자식 코루틴이 있는 경우, 자식 코루틴에서 발생한 예외는 `try-catch`로 감지할 수 없다.

### try-catch로 예외를 감지할 수 없는 경우

#### try문 내에 자식 코루틴이 있을 때

다음 코드와 같이 내부적으로 또 다른 코루틴이 있다면 그 코루틴에서 발생하는 예외는 `catch`로 감지할 수 없다. 즉, 계층 구조가 있는 코루틴에서는 `try-catch`로 예외를 감지할 수 없다는 것이다.

```kotlin
try {
    launch {
        // 자식 코루틴 A
        throw Exception("코루틴 A 예외")
    }

    // 새로운 Scope에서 코루틴 B를 실행
    val scope = CoroutineScope(Dispatchers.Default)
    scope.launch {
        throw Exception("코루틴 B 예외")
    }
} catch (e: Exception) {
    // 호출되지 않음
    // 자식 코루틴의 예외를 감지할 수 없다.
}
```

이러한 경우에는 루트 코루틴에서 `CoroutineExceptionHandler`를 사용하면 자식 코루틴의 예외를 감지할 수 있다.


### CoroutineExceptionHandler

> Scope내의 코루틴에서 발생한 예외를 감지할 수 있다


```kotlin
supervisorScope {
    val exceptionHandler = CoroutineExceptionHandler { _, throwable ->
        println("예외 감지: $throwable")
    }

    println("ROOT")

    launch(exceptionHandler) {
        println("job : ROOT-A")

        launch {
            println("job : ROOT-A-B")

            launch {
                println("job : ROOT-A-B-C")

                supervisorScope {
                    launch {
                        throw Exception("ROOT-A-B-C의 예외")
                    }
                }
            }
        }
    }

    launch(exceptionHandler) {
        println("job : ROOT-B")
        throw Exception("ROOT-B의 예외")
    }
}

ROOT
job : ROOT-A
job : ROOT-B
예외 감지: java.lang.Exception: ROOT-B의 예외
job : ROOT-A-B
job : ROOT-A-B-C
예외 감지: java.lang.Exception: ROOT-A-B-C의 예외
```

![CoroutineExceptionHandler](https://github-production-user-asset-6210df.s3.amazonaws.com/48265129/284040241-2e86317b-873f-40fa-a917-8cddeb6dd4fb.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20231119%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20231119T100906Z&X-Amz-Expires=300&X-Amz-Signature=bdbaf6162877e714826a393dce02dfa576328879e1fefa30f1f9f0e019507d1b&X-Amz-SignedHeaders=host&actor_id=48265129&key_id=0&repo_id=685439824)

### 주의 사항

#### 예외에 대해 복구한 후 후속 작업을 해야한다면 부적합

> 예외가  `CoroutineExceptionHandler`에서 감지되었을 때, 해당 코루틴은 이미 실패 상태로 완료된 것이다. 따라서 `CoroutineExceptionHandler`에서 예외를 복구하고 다음 작업을 진행하는 것은 불가능하다.

- `try-catch`를 사용하여 따로 처리
  - 예외에 대해서 대응하고 작업을 이어나가려면, 해당 코드를 `try-catch` 로 감싸서 예외를 직접 처리해야 한다.

#### `delay()`, `yield()` 등의 취소가능한 중단 함수는 취소될 때 `CancellationException`을 발생시킨다.

다음은 50MS 동안 대기한 후에 코루틴 `B`를 취소시키는 코드이다.

```kotlin
suspend fun main(): Unit = coroutineScope {
    val exceptionHandler = CoroutineExceptionHandler { _, throwable ->
        println("예외 감지: $throwable")
    }

    // A
    launch {
        println("A 시작, 200ms 대기")
        delay(200)
        println("200ms 대기 종료, A 완료")
    }

    // B
    val b = launch {
        try {
            delay(100)
        } catch (e: Exception) {
            println("catch에서 예외 처리: $e")
        }
        println("B 완료")
    }

    delay(50)
    b.cancel()
}

A 시작, 200ms 대기
catch에서 예외 처리: kotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled; job=StandaloneCoroutine{Cancelling}@17036f98
B 완료
200ms 대기 종료, A 완료
```

위 코드에는 다음과 같은 문제가 있다.

1. `B`가 취소되었음에도 불구하고 `B 완료`가 출력됨
2. `SupervisorJob`, `supervisorScope`에서 처리되지 않음에도 `B`의 예외가 전파되지 않고 `A`가 정상적으로 동작함


##### 문제의 원인 및 해결 방법

코루틴이 취소된다면 동작중인 `delay`는 `CancellationException`을 발생시키는데, `catch`에서 이 예외를 잡아서 대응을 하였기 때문에 `A 완료`가 출력된 것이며, 이 예외가 `catch`에서 잡히면서 부모로 전파되지 않아 `A`가 정상적으로 동작한 것이다.

이는 다음과 같이 정확하게 잡아야하는 예외를 감지하도록 하면 **해결**된다.

```kotlin
try {
    delay(100)
} catch (e: IllegalArgumentException) {
    println("catch에서 예외 처리: $e")
}
println("B 완료")

A 시작, 200ms 대기
200ms 대기 종료, A 완료
```

`CancellationException`를 잡지 않고 정상적으로 코루틴 취소 예외가 부모 코루틴으로 전파되어 `A`가 취소되며 `B 완료`가 출력되지 않는다.

> `CoroutineExceptionHandler`에서 `CancellationException`는 감지하지 않는다.

> `CancellationException`은 코루틴이 취소 될 때 작동하는 메커니즘의 일부이므로, 오류가 아니기 때문에 굳이 이 예외를 감지하여 처리할 필요가 없다.