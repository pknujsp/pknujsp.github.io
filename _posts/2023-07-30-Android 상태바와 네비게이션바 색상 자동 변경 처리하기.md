---
layout: post
title: Android 시스템 바(상태바, 네비게이션바) 색상 자동 변경 처리하기
subtitle: Bitmap, Flow, Coroutines, FragmentLifecycleCallbacks을 활용하여 자동으로 색상 변경되도록 하는 방법
published: true
categories: Android
tags: [Android]
---

## Android 시스템 바(상태바, 네비게이션바) 색상 자동 변경 처리하기

### 아래의 내용을 통하여 시스템 바의 색상/레이아웃을 변경하는 방법을 확인할 수 있습니다.

[Android 시스템 바 레이아웃 변경하기](https://pknujsp.github.io/android/2023/07/22/Android-%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B0%94-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0.html)


## 시스템 바 색상 변경시 생기는 문제점
---
> 아래와 같이 배경 색상이 다른 화면이 표시되는 경우, 화면의 배경색과 시스템 바의 색상이 겹쳐서 보이지 않는 문제가 발생합니다.


|                                                                                                                       |                                                                                                                       |
| :-------------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------: |
| <img src="https://github.com/pknu-wap/2023_1_WAP_APP_TEAM_MEDI/assets/48265129/c34fbf7e-9425-45d4-8f92-445c7c7e629b"> | <img src="https://github.com/pknu-wap/2023_1_WAP_APP_TEAM_MEDI/assets/48265129/d5b8cff1-51ac-42e0-9c77-62af784ec02c"> |

**Activity**, **Fragment**, **Compose** 화면 구성 요소가 변경될 때 이와 같은 상황이 발생하게 됩니다.

**본 글에서는 Fragment가 변경될 때의 경우에 대처하는 방법을 설명하겠습니다.**

## 화면이 변경될 떄 마다 대처하는 방법

- **Activity** 가 변경되는 경우
  - `onCreate()`에서 색상 변경 코드를 작성
  - XML에서 미리 지정해놓은 테마(스타일)적용
- **Fragment** 가 변경되는 경우
  - 시스템 바의 색상이 변경되어야 하는 Fragment 마다 각각 색상 변경 코드를 작성하여야 함

위와 같은 방법은 코드의 중복이 발생하고, 상당히 번거로운 작업이 됩니다.

특히 수 많은 Fragment가 변경되는 경우라면 굉장한 반복 작업이 될 것입니다.

이러한 고된 작업을 하지 않기 위해서 우선 **FragmentLifecycleCallbacks** 사용을 고려할 수 있습니다.

## FragmentLifecycleCallbacks으로 Fragment의 상태를 감지하기
---

> **FragmentLifecycleCallbacks**를 **FragmentManager** 에 등록하여 Fragment의 상태(생명주기)를 감지할 수 있습니다.

```kotlin
supportFragmentManager.registerFragmentLifecycleCallbacks(
    object : FragmentManager.FragmentLifecycleCallbacks() {
        override fun onFragmentResumed(fm: FragmentManager, f: Fragment) {
            super.onFragmentResumed(fm, f)

            // 이 함수는 아래에서 설명하겠습니다.
            systemBarColorAnalyzer.convert()
        }
    },
    true,
)
```

- **Callback**을 등록할 **FragmentManager**는 **Activity**에서 **FragmentManager**를 사용하는 것을 권장합니다.
  - `registerFragmentLifecycleCallbacks()`를 사용할 때 Argument로 true를 전달하면 View에 표시되는 모든 Fragment의 상태를 감지를 할 수 있습니다.

이제 Fragment의 상태를 한 곳에서 감지할 수 있게 되었습니다.

본격적으로 시스템 바의 색상을 자동으로 변경하는 방법을 알아봅시다.

## 시스템 바의 색상을 자동으로 변경하는 방법

Fragment의 개수가 2 ~ 3개 정도로 아주 적으면, 경우에 따라 각각의 Fragment에서 시스템 바의 색상을 변경하는 코드를 작성하거나 위 Callback의 `onFragmentResumed()`에서 Fragment 별로 분기문을 만들어 색상을 변경하는 방법이 더 효율적일 수 있습니다.

**그러나**, Fragment의 개수는 수십 개, 많으면 수백 개가 될 수 있습니다.

이러한 경우에는 분기문으로 처리하는 것은 당연히 매우 부적절한 방법입니다.

따라서, **Fragment**가 **Resumed** 상태가 되었을 때, 시스템 바 위치에 있는 **View**의 배경색을 분석하여 색상을 변경하는 방법을 사용하도록 하겠습니다.

### 자동으로 변경하는 로직

로직을 간단히 설명하면 아래와 같습니다.

1. Fragment `onResumed` 응답을 받습니다.
2. 시스템 바 위치에 있는 View의 배경색을 분석합니다.
   1. 코루틴을 사용하여 다른 스레드에서 비동기로 처리합니다.
   2. Fragment 여러 개가 보여지면 `onResumed`응답이 여러 번 발생할 수 있습니다.
   3. 80MS 이내에 여러 번의 응답이 발생하면, 마지막 응답에 대해서만 처리합니다.
3. 색상을 흑백으로 변환합니다.
4. 변환된 흑백 값에 따라 시스템 바의 색상을 변경합니다.
   1. 값이 140 이상 -> 검은색
   2. 값이 140 미만 -> 흰색
   3. 140은 여러 번 테스트를 통해 결정한 기준 값입니다. 흑백 값 범위는 0 ~ 255 입니다.

아래에서 상세히 설명하겠습니다.

시스템 바 색상 처리를 구현한 클래스로 `SystemBarColorAnalyzer`를 만들었습니다.

### 1. Fragment onResumed 응답을 받습니다.

```kotlin
override fun onFragmentResumed(fm: FragmentManager, f: Fragment) {
    super.onFragmentResumed(fm, f)
    systemBarColorAnalyzer.convert()
}
```

1. 응답 수신
2. `convert()`, 시스템 바 색상 변경처리 시작


### 2. 시스템 바 위치에 있는 View의 배경색을 분석합니다.


```kotlin
private val waitLock = Mutex()
private var waiting: Job? = null
private val coroutineScope = MainScope() + CoroutineName("SystemBarColorAnalyzer")
private val onChangedFragmentFlow = MutableSharedFlow<Unit>(onBufferOverflow = BufferOverflow.SUSPEND, replay = 0, extraBufferCapacity = 2)
private val delayTime = 80L

fun convert() {
    coroutineScope.launch {
        waitLock.withLock {
            if (waiting?.isActive == true) waiting?.cancel()
            waiting = launch(Dispatchers.Default) {
                delay(delayTime)
                onChangedFragmentFlow.emit(Unit)
            }
        }

    }
}
```

1. `convert()` 함수가 호출되면, 비동기로 처리합니다.
2. `waiting Job`이 존재하면, 취소합니다.
3. 새로운 `waiting Job`을 생성하고, `delayTime : 80ms` 시간동안 대기합니다. 
4. 만약 `delayTime`이내에 추가 요청이 발생하면, 2번 작업을 다시 수행합니다.
5. `delayTime`이내에 추가 요청이 없으면, `onChangedFragmentFlow`에 새로운 요청이 발생했음을 알립니다.


### 3. 색상을 흑백으로 변환합니다.

```kotlin
init {
    coroutineScope.launch(Dispatchers.Default) {
        onChangedFragmentFlow.collect {
            val convertJob = launch(start = CoroutineStart.LAZY) {
                val colors = startConvert()
                withContext(Dispatchers.Main) {
                    systemBarController?.setStyle(colors.first, colors.second)
                }
            }

            decorView.doOnPreDraw {
                convertJob.start()
            }
            convertJob.join()
        }
    }
}
```



![android_systembar_updating](https://github.com/pknu-wap/2023_1_WAP_APP_TEAM_MEDI/assets/48265129/382f30d5-a3ce-4229-b25c-6d75011c663d)

![android_systembar](https://github.com/pknu-wap/2023_1_WAP_APP_TEAM_MEDI/assets/48265129/ce1a5548-ece2-4f23-b953-6f1fd1df681e)